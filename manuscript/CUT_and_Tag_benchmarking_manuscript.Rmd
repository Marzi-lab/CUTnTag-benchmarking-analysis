---
title: "CUTnTag_analysis_v2"
author: "Paulina Urbanaviciute"
date: "23/10/2023"
output:
  rmarkdown::html_document:
    theme: default
    highlight: tango
    code_folding: hide
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
    number_sections: no
    self_contained: yes
    df_print: paged
---

This document contains the downstream R analysis scripts used to generate tables and figures for the manuscript 'CUT&Tag recovers up to half of ENCODE ChIP-seq histone acetylation peaks in modifications of H3K27'.

```{r setup, include=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
# setup
# load R packages
library(dplyr)
library(stringr)
library(tidyr)
library(plyr)
library(corrplot)
library(reshape2)
library(ggpubr)
library(ggbreak)
library(gplots)
library(ggplot2)
library(viridis)
library(GenomicRanges)
library(IRanges)
library(chromVAR)
library(ChIPseeker) 
library(rtracklayer)
library(clusterProfiler)
library(BRGenomics)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(org.Hs.eg.db)
library(RColorBrewer)
library(DiffBind)
library(circlize)
library(svglite)
library(preprocessCore)
library(data.table)

# set working directory
storedir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis"
workdir="/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking"
```

# General
## Alignment summary 
```{r , echo = TRUE, message=FALSE, warning=FALSE}
datadir1 = paste0(storedir,"/bowtie2_summary/")
sampleList1 = c("ActiveMotif", "Diagenode_100x", "Diagenode_50x", "Abcam-ab177178", 
  "Abcam-ab4729", "H3K27me3", "H3K27ac_SRR8383507", "H3K27ac_SRR8383508", "H3K27ac_SRR8581604_CnR", "H3K27me3_SRR11074238", "H3K27me3_SRR11074239", "H3K27me3_SRR9073702_CnR")

datadir2 = paste0(workdir, "/alignment/sam/bowtie2_summary/")
sampleList2 = c("IGF128036", "IGF128037", "IGF128038", "IGF128039", "IGF128040", "IGF128041", "IGF128042", "IGF128043")

## collect the alignment results from the bowtie2 alignment summary files
alignResult = c()
for (x in seq(1:2)) {
  datadir = paste0("datadir",x)
  sampleList = paste0("sampleList",x)
  sampleSet <- ifelse(datadir == "datadir1", "first", "second")

  for(sample in get(sampleList)){
    alignRes = read.table(paste0(get(datadir), sample, "_bowtie2.txt"), 
                          header = FALSE, fill = TRUE)
    alignRate = substr(alignRes$V1[6], 1, nchar(as.character(alignRes$V1[6]))-1)
    alignResult = data.frame(Sample = sample, 
                             Set = sampleSet,
                             SequencingDepth = alignRes$V1[1] %>% 
                               as.character %>% as.numeric, 
                             MappedFragNum_hg19 = alignRes$V1[4] %>% 
                               as.character %>% as.numeric + alignRes$V1[5] %>% 
                               as.character %>% as.numeric,
                             AlignmentRate_hg19 = alignRate %>% 
                               as.numeric) %>% rbind(alignResult, .)
  }
  alignResult <- rbind(alignResult)
}

# add antibody information
metadata <- read.table(paste0(workdir,"/sampleinfo/rep_metadata.txt"), sep=",")
colnames(metadata)[1] <- "Sample"
colnames(metadata)[2] <- "Info"
metadata$hmark <- "H3K27ac"
metadata[grep("ab9733",metadata$Info),]$hmark <- "H3K27me3"
metadata$Label <- paste0(metadata$hmark,"-", substr(metadata$Info, 6, nchar(metadata$Info)) )

alignResult <- alignResult %>%
  mutate(SampleLabel = ifelse(Sample %in% metadata$Sample, metadata$Label[match(Sample, metadata$Sample)], Sample))

alignResult <- alignResult %>% mutate(AlignmentRate_hg19 = paste0(AlignmentRate_hg19, "%"))
alignResult <- alignResult[order(alignResult$Sample),]


## edit SampleLabel; changing Kaya Okur sample names from SRR IDs to easy-to-read labels
alignResult$SampleLabel[alignResult$Sample == "H3K27ac_SRR8383507"] <- "H3K27ac-Kaya-Okur-1"
alignResult$SampleLabel[alignResult$Sample == "H3K27ac_SRR8383508"] <- "H3K27ac-Kaya-Okur-2"
alignResult$SampleLabel[alignResult$Sample == "H3K27me3_SRR11074238"] <- "H3K27me3-Kaya-Okur-1"
alignResult$SampleLabel[alignResult$Sample == "H3K27me3_SRR11074239"] <- "H3K27me3-Kaya-Okur-2"
alignResult$SampleLabel[alignResult$Sample == "H3K27ac_SRR8581604_CnR"] <- "H3K27ac-Meers-CnR"
alignResult$SampleLabel[alignResult$Sample == "H3K27me3_SRR9073702_CnR"] <- "H3K27me3-Meers-CnR"
alignResult$SampleLabel[alignResult$Sample == "Abcam-ab177178"] <- "H3K27ac-ab177178-HDup"
alignResult$SampleLabel[alignResult$Sample == "Abcam-ab4729"] <- "H3K27ac-ab4729-HDup"
alignResult$SampleLabel[alignResult$Sample == "ActiveMotif"] <- "H3K27ac-ActiveMotif-HDup"
alignResult$SampleLabel[alignResult$Sample == "Diagenode_100x"] <- "H3K27ac-Diag100x-HDup"
alignResult$SampleLabel[alignResult$Sample == "Diagenode_50x"] <- "H3K27ac-Diag50x-HDup"
alignResult$SampleLabel[alignResult$Sample == "H3K27me3"] <- "H3K27me3-ab9733-HDup"

alignResult
# save formatted table
# write.csv(alignResult, paste0(workdir,"/alignment/alignment_stats/bowtie_summary.csv"))

# alignResult <- read.csv(paste0(workdir,"/alignment/alignment_stats/bowtie_summary.csv"),row.names=1)
# alignResult
```

## Duplicates
```{r, echo=TRUE}
datadir1 = paste0(storedir,"/picard_summary/")
sampleList1 = c("ActiveMotif", "Diagenode_100x", "Diagenode_50x", "Abcam-ab177178", 
  "Abcam-ab4729", "H3K27me3", "H3K27ac_SRR8383507", "H3K27ac_SRR8383508", "H3K27ac_SRR8581604_CnR", "H3K27me3_SRR11074238", "H3K27me3_SRR11074239", "H3K27me3_SRR9073702_CnR")

datadir2 = paste0(workdir, "/removeDuplicate/picard_summary/")
sampleList2 = c("IGF128036", "IGF128037", "IGF128038", "IGF128039", "IGF128040", "IGF128041", "IGF128042", "IGF128043")

## collect the duplicate stats from picard rmdup files
dupResult = c()
for (x in seq(1:2)) {
  datadir = paste0("datadir",x)
  sampleList = paste0("sampleList",x)

  for (sample in get(sampleList)) {
    dupRes = read.table(paste0(get(datadir), sample, "_picard.rmDup.txt"), header = TRUE, fill = TRUE)
    dupResult = data.frame(Sample = sample, MappedFragNum_hg19 = dupRes$READ_PAIRS_EXAMINED[1] %>% as.character %>% as.numeric, DuplicationRate = dupRes$PERCENT_DUPLICATION[1] %>% as.character %>% as.numeric * 100) %>% mutate(UniqueFragNum = (MappedFragNum_hg19 * (1-DuplicationRate/100)) %>% round()) %>% rbind(dupResult, .)
  }
  dupResult <- rbind(dupResult)
}
dupResult$UniqueFragNum = (dupResult$MappedFragNum_hg19 * (1-dupResult$DuplicationRate/100)) %>% round()

alignDupSummary = left_join(alignResult, dupResult, by = c("Sample","MappedFragNum_hg19")) %>% mutate(AlignmentRate_hg19 = AlignmentRate_hg19)
alignDupSummary$DuplicationRate <- paste0(round(alignDupSummary$DuplicationRate,2),"%")
alignDupSummary<-alignDupSummary[order(alignDupSummary$Sample),]
alignDupSummary

```


# Fragment Length Distribution
## Without duplicates {.tabset}
```{r , echo=TRUE}
datadir1 = paste0(storedir,"/fragmentLen/rmDup/")
sampleList1 = c("ActiveMotif", "Diagenode_100x", "Diagenode_50x", "Abcam-ab177178", 
  "Abcam-ab4729", "H3K27me3", "H3K27ac_SRR8383507", "H3K27ac_SRR8383508", "H3K27ac_SRR8581604_CnR", "H3K27me3_SRR11074238", "H3K27me3_SRR11074239", "H3K27me3_SRR9073702_CnR")

datadir2 = paste0(workdir, "/alignment/sam/fragmentLen/")
sampleList2 = c("IGF128036", "IGF128037", "IGF128038", "IGF128039", "IGF128040", "IGF128041", "IGF128042", "IGF128043")

## collect fragment lengths
fragLen = c()
for (x in seq(1:2)) {
  datadir = paste0("datadir",x)
  sampleList = paste0("sampleList",x)

  for (sample in get(sampleList)) {
  fragLen = read.table(paste0(get(datadir), sample, "_rmDup_fragmentLen.txt"),header = FALSE) %>% 
  mutate(fragLen = V1 %>% as.numeric, fragCount = V2 %>% as.numeric, 
    Weight = as.numeric(V2)/sum(as.numeric(V2)), Sample = sample) %>% rbind(fragLen, .)
  }
  fragLen <- rbind(fragLen)
}

# add samplelabel
fragLen = merge(fragLen, alignResult[c("Sample","SampleLabel")], by="Sample")
```

### Extended sample list
``` {r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=13, fig.height=5}
fig1 = fragLen %>% ggplot(aes(x = SampleLabel, y = fragLen, weight = Weight, fill = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_violin(bw = 5) +
  scale_y_continuous(breaks = seq(0, 800, 50)) +
  ggpubr::rotate_x_text(angle = 20) +
  ggtitle("Fragment length distribution") +
  ylab("Fragment Length") +
  xlab("") +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(plot.title = element_text(size = 18, face="bold")) +
  scale_fill_viridis( discrete = TRUE, begin = 0.1, end = 0.85, option = "plasma", alpha = 0.9) 

fig2 = fragLen %>% ggplot(aes(x = fragLen, y = fragCount, color = SampleLabel, fill = SampleLabel, group = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_line(size = 0.6) +
  xlab("Fragment Length") +
  ylab("Count") +
  coord_cartesian(xlim = c(0, 500)) +
  theme(
    legend.position = c(0.995, 0.995),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.margin = margin(4, 4, 4, 4),
    legend.key.size = unit(0.3, "cm"),
    legend.title=element_blank()
    ) +
  scale_color_discrete(name="") +
  scale_colour_viridis( discrete = TRUE, begin = 0.1, end = 0.85, option = "plasma", alpha = 0.9)

# p <- ggarrange(fig1, fig2, ncol = 2, widths=c(1,1.5), align="h")
p <- ggarrange(fig1, fig2, ncol = 2, widths=c(1,1), align="h")
p

# # save plot
# ggsave(path = paste0(workdir,"/alignment/sam/fragmentLen"),
#         filename = "rmDup.fragmentLen.svg",
#         dpi = 1200, width = 18.0,
#         height = 6.0, units ="in",
#         plot=p)

```
### Main sample list
``` {r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=11, fig.height=4}
# keep only second dataset and external C&T datasets
extSamples <- c("H3K27ac_SRR8383507", "H3K27ac_SRR8383508", "H3K27me3_SRR11074238", "H3K27me3_SRR11074239")
keepSamples <- c( alignDupSummary[alignDupSummary$Set == "second",]$Sample , extSamples)
fragLen <- fragLen[fragLen$Sample %in% keepSamples,]


fig1 = fragLen %>% ggplot(aes(x = SampleLabel, y = fragLen, weight = Weight, fill = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_violin(bw = 5) +
  scale_y_continuous(breaks = seq(0, 800, 50)) +
  ggpubr::rotate_x_text(angle = 20) +
  ggtitle("Fragment length distribution") +
  ylab("Fragment Length") +
  xlab("") +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(plot.title = element_text(size = 18, face="bold")) +
  scale_fill_viridis( discrete = TRUE, begin = 0.1, end = 0.85, option = "magma", alpha = 0.9) 

fig2 = fragLen %>% ggplot(aes(x = fragLen, y = fragCount, color = SampleLabel, fill = SampleLabel, group = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_line(size = 0.6) +
  xlab("Fragment Length") +
  ylab("Count") +
  coord_cartesian(xlim = c(0, 500)) +
  theme(
    legend.position = c(0.995, 0.995),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.margin = margin(4, 4, 4, 4),
    legend.key.size = unit(0.3, "cm"),
    legend.title=element_blank()
    ) +
  scale_color_discrete(name="") +
  scale_colour_viridis(discrete = TRUE, begin = 0.1, end = 0.85, option = "magma", alpha = 0.9)

p <- ggarrange(fig1, fig2, ncol = 2, widths=c(1,1), align="h")
p

# # save plot
# ggsave(path = paste0(workdir,"/alignment/sam/fragmentLen"),
#         filename = "fragmentLen_distribution_rmDup_plot.pdf",
#         dpi = 1200, width = 28.0,
#         height = 8.0, units ="in",
#         plot=p)
# ggsave(path = paste0(workdir,"/alignment/sam/fragmentLen"),
#         filename = "fragmentLen_distribution_rmDup_plot.svg",
#         dpi = 1200, width = 28.0,
#         height = 8.0, units ="in",
#         plot=p)
```

## With duplicates {.tabset}
### Extended sample list
```{r, echo=FALSE}

datadir1 = paste0(storedir,"/fragmentLen/withDup/")
sampleList1 = c("ActiveMotif", "Diagenode_100x", "Diagenode_50x", "Abcam-ab177178", 
  "Abcam-ab4729", "H3K27me3", "H3K27ac_SRR8383507", "H3K27ac_SRR8383508", "H3K27ac_SRR8581604_CnR", "H3K27me3_SRR11074238", "H3K27me3_SRR11074239", "H3K27me3_SRR9073702_CnR")

datadir2 = paste0(workdir, "/alignment/sam/fragmentLen/")
sampleList2 = c("IGF128036", "IGF128037", "IGF128038", "IGF128039", "IGF128040", "IGF128041", "IGF128042", "IGF128043")


## collect fragment lengths
fragLen = c()
for (x in seq(1:2)) {
  datadir = paste0("datadir",x)
  sampleList = paste0("sampleList",x)

  for (sample in get(sampleList)) {
  fragLen = read.table(paste0(get(datadir), sample, "_withDup_fragmentLen.txt"),header = FALSE) %>% 
  mutate(fragLen = V1 %>% as.numeric, fragCount = V2 %>% as.numeric, 
    Weight = as.numeric(V2)/sum(as.numeric(V2)), Sample = sample) %>% rbind(fragLen, .)
  }
  fragLen <- rbind(fragLen)
}

# add samplelabel
fragLen = merge(fragLen, alignResult[c("Sample","SampleLabel")], by="Sample")
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=13, fig.height=5}

fig1 = fragLen %>% ggplot(aes(x = SampleLabel, y = fragLen, weight = Weight, fill = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_violin(bw = 5) +
  scale_y_continuous(breaks = seq(0, 800, 50)) +
  ggpubr::rotate_x_text(angle = 20) +
  ggtitle("Fragment length distribution") +
  ylab("Fragment Length") +
  xlab("") +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(plot.title = element_text(size = 18, face="bold")) +
  scale_fill_viridis( discrete = TRUE, begin = 0.1, end = 0.85, option = "plasma", alpha = 0.9) 

fig2 = fragLen %>% ggplot(aes(x = fragLen, y = fragCount, color = SampleLabel, fill = SampleLabel, group = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_line(size = 0.6) +
  xlab("Fragment Length") +
  ylab("Count") +
  coord_cartesian(xlim = c(0, 500)) +
  theme(
    legend.position = c(0.995, 0.995),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.margin = margin(4, 4, 4, 4),
    legend.key.size = unit(0.3, "cm"),
    legend.title=element_blank()
    ) +
  scale_color_discrete(name="") +
  scale_colour_viridis( discrete = TRUE, begin = 0.1, end = 0.85, option = "plasma", alpha = 0.9)

# p <- ggarrange(fig1, fig2, ncol = 2, widths=c(1,1.5), align="h")
p <- ggarrange(fig1, fig2, ncol = 2, widths=c(1,1), align="h")
p

# # save plot
# ggsave(path = paste0(workdir,"/alignment/sam/fragmentLen"),
#         filename = "withDup.fragmentLen.svg",
#         dpi = 1200, width = 18.0,
#         height = 6.0, units ="in",
#         plot=p)

```
### Main sample list
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=12, fig.height=4}
# keep only second dataset and external C&T datasets
extSamples <- c("H3K27ac_SRR8383507", "H3K27ac_SRR8383508", "H3K27me3_SRR11074238", "H3K27me3_SRR11074239")
keepSamples <- c( alignDupSummary[alignDupSummary$Set == "second",]$Sample , extSamples)
fragLen <- fragLen[fragLen$Sample %in% keepSamples,]

fig1 = fragLen %>% ggplot(aes(x = SampleLabel, y = fragLen, weight = Weight, fill = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_violin(bw = 5) +
  scale_y_continuous(breaks = seq(0, 800, 50)) +
  ggpubr::rotate_x_text(angle = 20) +
  ggtitle("Fragment length distribution") +
  ylab("Fragment Length") +
  xlab("") +
  theme(legend.position = "none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(plot.title = element_text(size = 18, face="bold")) +
  scale_fill_viridis( discrete = TRUE, begin = 0.1, end = 0.85, option = "plasma", alpha = 0.9) 

fig2 = fragLen %>% ggplot(aes(x = fragLen, y = fragCount, color = SampleLabel, fill = SampleLabel, group = SampleLabel)) +
  theme_bw(base_size = 15) +
  geom_line(size = 0.6) +
  xlab("Fragment Length") +
  ylab("Count") +
  coord_cartesian(xlim = c(0, 500)) +
  theme(
    legend.position = c(0.995, 0.995),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.margin = margin(4, 4, 4, 4),
    legend.key.size = unit(0.3, "cm"),
    legend.title=element_blank()
    ) +
  scale_color_discrete(name="") +
  scale_colour_viridis( discrete = TRUE, begin = 0.1, end = 0.85, option = "plasma", alpha = 0.9)

# p <- ggarrange(fig1, fig2, ncol = 2, widths=c(1,1.5), align="h")
p <- ggarrange(fig1, fig2, ncol = 2, widths=c(1,1), align="h")
p

# # save plot
# ggsave(path = paste0(workdir,"/alignment/sam/fragmentLen"),
#         filename = "fragmentLen_distribution_withDup_plot.pdf",
#         dpi = 1200, width = 28.0,
#         height = 8.0, units ="in",
#         plot=p)
# ggsave(path = paste0(workdir,"/alignment/sam/fragmentLen"),
#         filename = "fragmentLen_distribution_withDup_plot.svg",
#         dpi = 1200, width = 28.0,
#         height = 8.0, units ="in",
#         plot=p)

```


# Peak counts {.tabset}
## Main samples
``` {r, echo=TRUE, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}

h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="individual" # opts: allsample, newsample, individual
callerdir=c("SEACR","MACS2")
dupList = c("rmDup","withDup")


blacklist_counts = c()
peakList = list()
peakList_unfilt = list()
callInfo = list()


for (dup in dupList) {
  
  for (sample in sampleList) {
  
    # for SEACR, define the threshold
    if (sample %in% h3k27me3_sampleList) { threshold = 0.1} 
    if (sample %in% h3k27ac_sampleList) { threshold = 0.01}
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"} 
  
      for (caller in callerdir) {
    
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q1e-5_peaks.",setting,"Peak") }
          
        # check
        # print(paste0(workdir,"/ephemeral/peakCalling/",caller,"/",sample,"_",dup,"_", suffix))
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(paste0(workdir,"/ephemeral/peakCalling/",caller,"/",
                                                      sample,"_",dup,"_", suffix), as = "GRanges") # reads in narrowPeak columns:
       
        # store all peaks in a list
        peakList_unfilt = c(peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        blacklist_counts = c(blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        peakList = c(peakList, peak_filt)
        # store peak calling information
        callInfo = c(callInfo, paste0(sample,"_",caller,"_",dup))
  }
    
}
}

# name peak lists
names(peakList) = callInfo
names(peakList_unfilt) = callInfo
names(blacklist_counts) = callInfo

```



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(peakList[[i]])) }
names(Total_CT_peaks) <- callInfo

data.frame(Total_CT_peaks)
```
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=10}
# split peak set information and plot bar plot
df=data.frame(Total_CT_peaks)
df$PeakSet = rownames(df)
df$Sample <- str_split_fixed(df$PeakSet, "_", n=3)[,1]
df$Caller <- str_split_fixed(df$PeakSet, "_", n=3)[,2]
df$Dup <- str_split_fixed(df$PeakSet, "_", n=3)[,3]

# add samplelabel
df = merge(df, alignResult[c("Sample","SampleLabel")], by="Sample")

# extract epigenetic mark information
df$EpMark <- str_split_fixed(df$SampleLabel, "-", n=3)[,1]
df$Source = "InHouse"

options(scipen=999)
PeakN_plot = ggplot(df, aes(SampleLabel, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = position_dodge(width = 0.75), stat = "identity") + 
  scale_fill_viridis(discrete = TRUE, begin = 0.15, end = 0.7, alpha = 0.7, option="plasma") +
  theme_light(base_size=25) + 
  ggtitle("Number of peaks") +
  xlab("Sample") +
  ylab("") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(axis.text = element_text(size = 25)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35)) +
  theme(legend.text = element_text(size = 20)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, 100000) +
  facet_wrap(~Caller)

PeakN_plot

org_df = df
org_df$control = "none"
```

## Main + External dataset
```{r,echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}

h3k27ac_sampleList = c("H3K27ac_SRR8383507", "H3K27ac_SRR8383508")
h3k27me3_sampleList = c("H3K27me3_SRR11074238", "H3K27me3_SRR11074239")
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# set="individual" # opts: allsample, newsample, individual
callerdir=c("SEACR","MACS2")
dupList = c("rmDup","withDup")


ext_blacklist_counts = c()
ext_peakList = list()
ext_peakList_unfilt = list()
ext_callInfo = list()


for (dup in dupList) {
  
  if  (dup == "rmDup") { duplabel="" }
  if  (dup == "withDup") { duplabel="_withDup" }
  
  for (sample in sampleList) {
  
      for (caller in callerdir) {
    
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0("SEACR",duplabel,".bed") }
        if (caller == "MACS2") { suffix=paste0("MACS2",duplabel,".bed") }
          
        # check
        # print(paste0(storedir,"/peakCalling/",caller,"/",sample,"_",dup,"_", suffix))
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(paste0(storedir,"/peaks/", dup, "/",
                                                      sample,"_", suffix), as = "GRanges")
       
        # store all peaks in a list
        ext_peakList_unfilt = c(ext_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        ext_blacklist_counts = c(ext_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        ext_peakList = c(ext_peakList, peak_filt)
        # store peak calling information
        ext_callInfo = c(ext_callInfo, paste0(sample,"_",caller,"_",dup))
  }
    
}
}

# name peak lists
names(ext_peakList) = ext_callInfo
names(ext_peakList_unfilt) = ext_callInfo
names(ext_blacklist_counts) = ext_callInfo

```

```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(ext_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(ext_peakList[[i]])) }
names(Total_CT_peaks) <- ext_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=22, fig.height=8}
# split peak set information and plot bar plot
ext_df=data.frame(Total_CT_peaks)
ext_df$PeakSet = rownames(ext_df)
ext_df$EpMark <- str_split_fixed(ext_df$PeakSet, "_", n=4)[,1]
ext_df$Sample <- paste0(str_split_fixed(ext_df$PeakSet, "_", n=4)[,1],"_", str_split_fixed(ext_df$PeakSet, "_", n=4)[,2])
ext_df$Caller <- str_split_fixed(ext_df$PeakSet, "_", n=4)[,3]
ext_df$Dup <- str_split_fixed(ext_df$PeakSet, "_", n=4)[,4]

# add samplelabel
ext_df = merge(ext_df, alignResult[c("Sample","SampleLabel")], by="Sample")

# add external dataset group ID before combining with in house samples
ext_df$Source = "External"
ext_df <- rbind(ext_df, df)

# Plot peak counts
options(scipen=999)
PeakN_plot = ggplot(ext_df, aes(SampleLabel, Total_CT_peaks, fill=Dup
                                # , width = 0.9*Fac
                                )) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", colour="grey1", alpha=0.5) + 
  scale_fill_manual(name = "", values = c("violet","purple4")) +
  theme_light(base_size=25) + 
  ggtitle("Number of sample peaks") +
  xlab("Sample") +
  ylab("") +
  # theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(axis.text = element_text(size = 25)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "right") +
  theme(strip.background = element_rect(fill="grey50")) +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, 130000) +
  facet_grid( EpMark ~ Caller, scales="free_y", space = "free_y") +
  coord_flip()

PeakN_plot

## save
# Open a svg file
svglite(paste0(workdir,"/peakCalling/barplot_peakCounts.svg"), width = 15, height = 15)
PeakN_plot
# Close the svg file
dev.off()
```

## Unfiltered peak list
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=22, fig.height=8}
# get both inhouse and external dataset peak lists
ext_peakList_unfilt <- c(peakList_unfilt, ext_peakList_unfilt) 
ext_callInfo <- c(callInfo, ext_callInfo)

# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(ext_peakList_unfilt)){ Total_CT_peaks = c(Total_CT_peaks, length(ext_peakList_unfilt[[i]])) }
names(Total_CT_peaks) <- ext_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=22, fig.height=8}
options(scipen=999)
PeakN_plot = ggplot(ext_df, aes(SampleLabel, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", colour="grey1", alpha=0.5) + 
  scale_fill_manual(name = "", values = c("violet","purple4")) +
  theme_light(base_size=25) + 
  ggtitle("Number of peaks (raw)") +
  xlab("Sample") +
  ylab("") +
  theme(axis.text = element_text(size = 25)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35)) +
  theme(legend.text = element_text(size = 20)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, 300000) +
  facet_grid(EpMark ~ Caller, scales="free_y",space="free")  + coord_flip()

PeakN_plot

```

## Main + External + CnR and High Duplicate samples (Supplementary)
```{r}
# read in peak genomic regions
CnR_sampleList = c("H3K27ac_SRR8581604_CnR", "H3K27me3_SRR9073702_CnR")
HDup_sampleList = c("ActiveMotif","Diagenode_100x","Diagenode_50x","Abcam-ab177178", "Abcam-ab4729","H3K27me3")
sampleList = c(CnR_sampleList, HDup_sampleList)
HDup_sampleList_ac <-  c("ActiveMotif","Diagenode_100x","Diagenode_50x","Abcam-ab177178", "Abcam-ab4729")

callerdir=c("SEACR","MACS2")
dupList = c("rmDup","withDup")

sup_blacklist_counts = c()
sup_peakList = list()
sup_peakList_unfilt = list()
sup_callInfo = list()


for (dup in dupList) {
  
  if  (dup == "rmDup") { duplabel="" }
  if  (dup == "withDup") { duplabel="_withDup" }
  
  for (sample in sampleList) {
  
      for (caller in callerdir) {
    
        # for peak caller and duplicate status, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0("SEACR",duplabel,".bed") }
        if (caller == "MACS2") { suffix=paste0("MACS2",duplabel,".bed") }
          
        # check
        file = paste0(storedir,"/peaks/",dup,"/",sample,"_", suffix)
        # print(file)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(file, as = "GRanges")
       
        # store all peaks in a list
        sup_peakList_unfilt = c(sup_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        sup_blacklist_counts = c(sup_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% 
          BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        sup_peakList = c(sup_peakList, peak_filt)
        # store peak calling information
        sup_callInfo = c(sup_callInfo, paste0(sample,"_",caller,"_",dup))
  }
    
}
}

# name peak lists
names(sup_peakList) = sup_callInfo
names(sup_peakList_unfilt) = sup_callInfo
names(sup_blacklist_counts) = sup_callInfo

```

```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(sup_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(sup_peakList[[i]])) }
names(Total_CT_peaks) <- sup_callInfo

data.frame(Total_CT_peaks)
```

```{r}
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=22, fig.height=12}

# split peak set information and plot bar plot
sup_df=data.frame(Total_CT_peaks)
sup_df$PeakSet = rownames(sup_df)
sup_df$EpMark <- "H3K27ac"
sup_df$EpMark[sup_df$PeakSet %in% grep("me3",sup_df$PeakSet,value=TRUE)] <- "H3K27me3"
sup_df$Sample <- str_remove(sup_df$PeakSet, "SEACR|MACS2") %>% str_remove("withDup|rmDup") %>% str_replace("__","")
sup_df$Caller <- str_extract(sup_df$PeakSet, "SEACR|MACS2")
sup_df$Dup <- str_extract(sup_df$PeakSet, "rmDup|withDup")


# add samplelabel
sup_df = merge(sup_df, alignResult[c("Sample","SampleLabel")], by="Sample")
sup_df$Source = "Supplementary"

cols = intersect(colnames(sup_df), colnames(ext_df))
sup_df <- rbind(sup_df[cols], ext_df[cols])

## edit: add ENCODE peak counts for comparison/reference
enc_df <- rbind(data.frame(Sample="ENCODE H3K27ac", Total_CT_peaks=NROW(ENCODE_H3K27ac), PeakSet="ENCODE_H3K27ac",
                     EpMark="H3K27ac",Caller="MACS2",Dup="rmDup",SampleLabel="ENCODE H3K27ac",Source="ENCODE"),
                data.frame(Sample="ENCODE H3K27me3", Total_CT_peaks=NROW(ENCODE_H3K27me3), PeakSet="ENCODE_H3K27me3",
                     EpMark="H3K27me3",Caller="MACS2",Dup="rmDup",SampleLabel="ENCODE H3K27me3",Source="ENCODE")
                )
plotdf = rbind(sup_df, enc_df)

options(scipen=999)
plotdf$SampleLabel <- factor(plotdf$SampleLabel, levels=unique(plotdf$SampleLabel))
PeakN_plot = ggplot(plotdf, aes(SampleLabel, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", colour="grey1",
           alpha=0.5) + 
  scale_fill_manual(name = "", values = c("violet","purple4")) +
  theme_bw(base_size=25) + 
  ggtitle("Number of sample peaks") +
  xlab("Sample") +
  ylab("") +
  # theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(axis.text = element_text(size = 25)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "right") +
  # theme(strip.background = element_rect(fill="grey50")) +
  theme(strip.text = element_text(size=24)) +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(sup_df$Total_CT_peaks)+100) +
  facet_grid( EpMark ~ Caller, scales="free_y", space = "free_y") +
  coord_flip()

PeakN_plot


## save
# Open a svg file
svglite(paste0(workdir,"/peakCalling/barplot_sup_peakCounts.svg"), width = 20, height = 14)
PeakN_plot
# Close the svg file
dev.off()
```

# Blacklist peak counts
For main samples + external dataset
```{r}
ext_blacklist_counts <- c(blacklist_counts, ext_blacklist_counts)

blacklist_countDF <- data.frame(blacklist_counts=ext_blacklist_counts)
blacklist_countDF$PeakSet <- rownames(blacklist_countDF)
peakcount <- merge(df, blacklist_countDF, by="PeakSet")
peakcount$BlkProp <- (peakcount$blacklist_counts / peakcount$Total_CT_peaks * 100) %>% round(2)
peakcount
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=14, fig.height=16}
blacklist_plot = ggplot(peakcount, aes(SampleLabel, BlkProp, fill=Dup)) +
geom_bar(aes(fill = Dup), width = 0.7, position = position_dodge(width = 0.75), 
         stat = "identity",alpha = 0.7) +
  theme_light(base_size = 25) + 
  theme(plot.margin = unit(c(0.5,0.5,0.5,1), "cm")) +
  ylim(0, 8) +
  ylab("") +
  xlab("Sample") +
  ggtitle("Proportion of CUT&Tag peaks in blacklisted regions") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "bottom") +
  # scale_fill_viridis(name = "Peak caller", labels = c("SEACR", "MACS2"), discrete = TRUE, begin = 0.1, end = 0.7, option = "viridis") +
  scale_fill_viridis(name = "", discrete = TRUE, begin = 0.1, end = 0.7, option = "plasma") +
  facet_grid(Caller~EpMark, scale="free_x", space="free_x")

blacklist_plot
```


# Peak widths

## By peak caller {.tabset}
### H3K27ac 
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8, fig.show="hold"}

info = df # df = only in-house datasets; ext_df = both internal and external
peakTest = c(ext_peakList, peakList) # peakList = only in-house datasets; ext_peakList = only external datasets

# SEACR H3K27ac peaks {3 antibodies +/- external dataset; rmDup and withDup}
peakset_l <- info$PeakSet[info$Caller == "SEACR" & info$EpMark == "H3K27ac" & info$Dup == "rmDup"]
SEACR_rmDup_ac = peakTest[peakset_l]
peakset_l <- info$PeakSet[info$Caller == "SEACR" & info$EpMark == "H3K27ac" & info$Dup == "withDup"]
SEACR_withDup_ac = peakTest[peakset_l]

# MACS2 H3K27ac peaks {3 antibodies +/- external dataset; rmDup and withDup}
peakset_l <- info$PeakSet[info$Caller == "MACS2" & info$EpMark == "H3K27ac" & info$Dup == "rmDup"]
MACS2_rmDup_ac = peakTest[peakset_l]
peakset_l <- info$PeakSet[info$Caller == "MACS2" & info$EpMark == "H3K27ac" & info$Dup == "withDup"]
MACS2_withDup_ac = peakTest[peakset_l]

# SEACR H3K27me3 peaks {1 antibody +/- external dataset; rmDup and withDup}
peakset_l <- info$PeakSet[df$Caller == "SEACR" & info$EpMark == "H3K27me3" & info$Dup == "rmDup"]
SEACR_rmDup_me = peakTest[peakset_l]
peakset_l <- info$PeakSet[info$Caller == "SEACR" & info$EpMark == "H3K27me3" & info$Dup == "withDup"]
SEACR_withDup_me = peakTest[peakset_l]

# MACS2 H3K27ac peaks {1 antibody +/- external dataset; rmDup and withDup}
peakset_l <- info$PeakSet[info$Caller == "MACS2" & info$EpMark == "H3K27me3" & info$Dup == "rmDup"]
MACS2_rmDup_me = peakTest[peakset_l]
peakset_l <- info$PeakSet[info$Caller == "MACS2" & info$EpMark == "H3K27me3" & info$Dup == "withDup"]
MACS2_withDup_me = peakTest[peakset_l]

 
# H3K27ac widths
SEACR_rmDup_ac_widths = unlist(as(SEACR_rmDup_ac, "GRangesList")) %>% GenomicRanges::width()
SEACR_withDup_ac_widths = unlist(as(SEACR_withDup_ac, "GRangesList")) %>% GenomicRanges::width()
MACS2_rmDup_ac_widths = unlist(as(MACS2_rmDup_ac, "GRangesList")) %>% GenomicRanges::width()
MACS2_withDup_ac_widths = unlist(as(MACS2_withDup_ac, "GRangesList")) %>% GenomicRanges::width()
# H3K27me3 widths
SEACR_rmDup_me_widths = unlist(as(SEACR_rmDup_me, "GRangesList")) %>% GenomicRanges::width()
SEACR_withDup_me_widths = unlist(as(SEACR_withDup_me, "GRangesList")) %>% GenomicRanges::width()
MACS2_rmDup_me_widths = unlist(as(MACS2_rmDup_me, "GRangesList")) %>% GenomicRanges::width()
MACS2_withDup_me_widths = unlist(as(MACS2_withDup_me, "GRangesList")) %>% GenomicRanges::width()


# plot boxplot for peak widths
options(scipen=999) # prevent scientififc notation

# H3K27ac
features <- list(SEACR_rmDup_ac_widths, 
        SEACR_withDup_ac_widths, 
        MACS2_rmDup_ac_widths,
        MACS2_withDup_ac_widths
)
names(features) <- c("SEACR_rmDup", 
        "SEACR_withDup", 
        "MACS2_rmDup",
        "MACS2_withDup"
)
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        ylab = "Width (bp)", 
        main = "H3K27ac peak widths", log = "y", ylim = c(1, max(unlist(features))))
# lapply(features, function(x){ median(x) } ) 
```

### H3K27me3
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8, fig.show="hold"}
# H3K27me3
features <- list(SEACR_rmDup_me_widths, 
        SEACR_withDup_me_widths, 
        MACS2_rmDup_me_widths,
        MACS2_withDup_me_widths
)
names(features) <- c("SEACR_rmDup", 
        "SEACR_withDup", 
        "MACS2_rmDup",
        "MACS2_withDup"
)
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        ylab = "Width (bp)", 
        main = "H3K27me3 peak widths", log = "y", ylim = c(1, max(unlist(features))))
# lapply(features, function(x){ median(x) } ) 

```

## By sample {.tabset}
```{r}
# load ENCODE ChIP peaks
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")
```

### Summary
```{r}
# add external dataset to peaklist for peak widths)
peaksTest = c(peakList, ext_peakList)

peakWidth = c()
for(peak in peaksTest){
  peakW = GenomicRanges::width(peak) %>% summary() %>% round() %>% list()
  peakWidth = c(peakWidth, peakW)
}

# calculate peak width summary stats
WSummary = c()
for(i in 1:length(peakWidth)){
  WSummary = data.frame(Sample = names(peaksTest)[i], MinW = array(peakWidth[[i]][1]), MedianW = array(peakWidth[[i]][3]), MeanW = array(peakWidth[[i]][4]), MaxW = array(peakWidth[[i]][6])) %>% rbind(., WSummary)
}

WSummary
```

### H3K27ac
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8, fig.show="hold"}
# repeat for each sample peak set seperately
info = ext_df[ext_df$Source != "Supplementary",] # df = only in-house datasets; ext_df = both internal and external
peakTest = c(ext_peakList, peakList) # peakList = only in-house datasets; ext_peakList = only external datasets

### Loop over all peak sets 
peakTest = c(ext_peakList, peakList) # peakList = only in-house datasets; ext_peakList = only external datasets
peakWidths = c()
for (i in 1:length(peakTest)) {
  peaks = peakTest[[i]]
  # name = names(peakTest)[i]
  widths = unlist(as(peaks, "GRangesList")) %>% GenomicRanges::width()
  peakWidths = c(peakWidths, list(widths))
}
names(peakWidths) <- names(peakTest)

# plot boxplot for peak widths
options(scipen=999) # prevent scientific notation

# H3K27ac
peaksets <- info$PeakSet[info$EpMark == "H3K27ac"]
features <- peakWidths[peaksets]
par(mar=c(18,5,5,5))
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        ylab = "Width (bp)", 
        main = "H3K27ac peak widths", 
        log = "y", 
        ylim = c(1, max(unlist(features))),
        las=2,
        cex.names=0.2)

## save
# # Open a pdf file
# pdf(paste0(workdir,"/peakCalling/boxplot_peak_width_h3k27ac.pdf"), width = 15, height = 10)
# par(mar=c(18,5,5,5))
# boxplot(features,
#         outline = TRUE,
#         names = names(features),
#         ylab = "Width (bp)",
#         main = "H3K27ac peak widths",
#         log = "y",
#         ylim = c(1, max(unlist(features))),
#         las=2,
#         cex.names=0.2)
# # Close the pdf file
# dev.off()

# Pull all median values
# lapply(features, function(x){ median(x) } ) 
```

### H3K27me3
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8, fig.show="hold"}
# H3K27me3
peaksets <- info$PeakSet[info$EpMark == "H3K27me3"]
features <- peakWidths[peaksets]
par(mar=c(20,5,5,5))
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        ylab = "Width (bp)", 
        main = "H3K27me3 peak widths", 
        log = "y", 
        ylim = c(1, max(unlist(features))),
        las=2,
        cex.names=0.2)

# ## save ##
# # Open a pdf file
# pdf(paste0(workdir,"/peakCalling/boxplot_peak_width_h3k27me3.pdf"), width = 12, height = 10)
# par(mar=c(20,5,5,5))
# boxplot(features,
#         outline = TRUE,
#         names = names(features),
#         ylab = "Width (bp)",
#         main = "H3K27me3 peak widths",
#         log = "y",
#         ylim = c(1, max(unlist(features))),
#         las=2,
#         cex.names=0.2)
# # Close the pdf file
# dev.off()

# Pull all median values
# lapply(features, function(x){ median(x) } ) 
```

### ENCODE
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8, fig.show="hold"}
# set peak sets of interest
peakTest = c(ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3) # peakList = only in-house datasets; ext_peakList = only external datasets

### Loop over all peak sets 
peakWidths = c()
for (i in 1:length(peakTest)) {
  peaks = peakTest[[i]]
  # name = names(peakTest)[i]
  widths = unlist(as(peaks, "GRangesList")) %>% GenomicRanges::width()
  peakWidths = c(peakWidths, list(widths))
}
names(peakWidths) <- names(peakTest)

features = peakWidths
par(mar=c(12,5,5,5))
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        ylab = "Width (bp)", 
        main = "ENCODE ChIP-seq peak widths", 
        log = "y", 
        ylim = c(1, max(unlist(features))),
        las=2,
        cex.names=0.2)

# Pull all median values
# lapply(features, function(x){ median(x) } ) 

```


### Combination (Supplementary)
```{r, fig.width=10, fig.height=18}

info = ext_df[ext_df$Source != "Supplementary",] # df = only in-house datasets; ext_df = both internal and external
info = plyr::arrange(info, EpMark, Caller, Sample)
info$plotlab = paste0(info$SampleLabel," ", info$Caller, " ", info$Dup)
peakTest = c(ext_peakList, peakList, ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3) # peakList = only in-house datasets; ext_peakList = only external datasets

### Loop over all peak sets 
peakWidths = c()
for (i in 1:length(peakTest)) {
  peaks = peakTest[[i]]
  # name = names(peakTest)[i]
  widths = unlist(as(peaks, "GRangesList")) %>% GenomicRanges::width()
  peakWidths = c(peakWidths, list(widths))
}
names(peakWidths) <- names(peakTest)

# rename peakWidths list using matching plotlab values in info DF
renamed_list <- info$plotlab[match(names(peakWidths), info$PeakSet)]
renamed_list <- ifelse(is.na(renamed_list), names(peakWidths), renamed_list)
names(peakWidths) <- renamed_list

# stack numbers into dataframe 
df <- stack(peakWidths)
# Rename the columns for clarity
names(df) <- c("Width", "PeakSet")
df$dup = str_extract(df$PeakSet, "rmDup|withDup")
df$caller = str_extract(df$PeakSet, "MACS2|SEACR")
df$epmark = str_extract(df$PeakSet, "H3K27ac|H3K27me3")
df$sample = str_replace_all(df$PeakSet, " MACS2| SEACR| rmDup| withDup|H3K27ac-|H3K27me3-", "")
df$samplelabel = str_replace_all(df$PeakSet, "H3K27ac-|H3K27me3-", "")
df$samplelabel[df$samplelabel == "ENCODE_H3K27ac"] <- "ENCODE H3K27ac"
df$samplelabel[df$samplelabel == "ENCODE_H3K27me3"] <- "ENCODE H3K27me3"

df$caller[df$samplelabel %in% c("ENCODE H3K27ac","ENCODE H3K27me3")] <- "ENCODE"
df$dup[is.na(df$dup) == TRUE] <- "na"
df = df[order(df[,4], df[,3]), ]
# df$samplelabel <- factor(df$samplelabel, levels=unique(df$samplelabel))
df$caller <- factor(df$caller, levels=c("ENCODE","MACS2","SEACR"))

# add colour
df$colour <- NA
df$colour[df$samplelabel == "ENCODE H3K27ac"] <- "grey30"
df$colour[df$samplelabel == "ENCODE H3K27me3"] <- "grey40"
df$colour[df$caller == "SEACR" & df$dup == "rmDup"] <- "purple"
df$colour[df$caller == "SEACR" & df$dup == "withDup"] <- "purple4"
df$colour[df$caller == "MACS2" & df$dup == "rmDup"] <- "red"
df$colour[df$caller == "MACS2" & df$dup == "withDup"] <- "red4"

# rename
df$label[df$caller != "ENCODE"] <- paste0(df$sample[df$caller != "ENCODE"], " (", df$caller[df$caller != "ENCODE"],")")
df$label[df$caller == "ENCODE"] <- df$samplelabel[df$caller == "ENCODE"] 
df$label <- factor(df$label, levels=unique(df$label))

# plot
ggplot(df, aes(x=log(Width), y=label, fill=colour)) + 
  geom_boxplot(alpha=0.9) +
  facet_grid(rows=c("epmark"), scales="free", space="free_y") +
  ylab("") +
  xlab("log width (bp)") +
  theme_bw(base_size=25) +
  scale_fill_manual(values=c(grey30="grey30", grey40="grey40",purple="purple",purple4="purple4",red="red", red4="red4"), 
                    labels=c(grey30="ENCODE H3K27ac", grey40="ENCODE H3K27me3",purple="SEACR rmDup",purple4="SEACR withDup",
                             red="MACS2 rmDup",red4="MACS2 withDup"),
                    breaks=c("grey30","grey40", "red","red4","purple","purple4"),
                    name="Key") +
  theme(legend.position = "top",
        legend.key.size = unit(1, 'cm'),
        legend.key.height = unit(0.5, 'cm'),
        legend.text = element_text(size=20)) + 
  guides(fill=guide_legend(nrow=3,byrow=TRUE))


# save plot (svg)
# ggsave(path = paste0(workdir,"/peakCalling"),
#         filename = paste0("peakWidths_duplicates.svg"),
#         dpi = 1200, width = 9.0,
#         height = 13.0, units ="in")
```



# Fraction of reads in sample and ENCODE peaks
Calculate fragments within CT peaks and ENCODE ChIP-seq peaks

```{r}
# load ENCODE ChIP peaks 
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")
```


```{r}
# # Loop over each sample
# # -- Reading in bam files is quite resource intensive, so can take some time

# ext_df$bamSample[ext_df$Source == "InHouse"] <- ext_df$Sample[ext_df$Source == "InHouse"]
# ext_df$bamSample[ext_df$Source == "External"]  <- ext_df$SampleLabel[ext_df$Source == "External"] %>% gsub("-","_",.)
# 
# peakTest <- c(peakList, ext_peakList, list(ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3))
# insample = ext_df$bamSample[ext_df$Source == "InHouse"] %>% unique %>% sort()
# exsample <- ext_df$bamSample[ext_df$Source == "External"] %>% unique %>% sort()
# sampleList <- c(insample, exsample)
# dupList = c("rmDup", "withDup")
# callerList = c("MACS2", "SEACR")
# encodelist = c("ENCODE_H3K27ac", "ENCODE_H3K27me3")
# 
# peaksetNames <- ext_df$PeakSet %>% unique
# 
# inPeakData_df = c()
# for (sample in sampleList) {
# 
#   for (dup in dupList) {
# 
#   ## define bam file path
#     # in house dataset
#      if (sample %in% insample) {
#        bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam") }
#     # external dataset, previously analysed
#      if (sample %in% exsample) {
#        if (dup == "rmDup") {
#          bamFile = paste0(storedir, "/bam/",dup,"/",sample,"_bowtie2_",dup,".mapped.sorted.bam") }
#        if (dup == "withDup") {
#          bamFile = paste0(storedir, "/bam/",dup,"/",sample,"_",dup,"_bowtie2.mapped.bam") }
#      }
# 
#       for (caller in callerList) {
#         ## define peak set
#         set = paste0(sample,"_",caller,"_",dup)
#         ## announce peak set counted against
#         print(paste0("For peak set ", set))
#         peak.gr = peakTest[[set]]
#         # peak.gr = GenomicRanges::GRanges(seqnames = peaks$seqnames, IRanges(start = peaks$start, end = peaks$end), strand = "*")
#         fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#         inPeakN = counts(fragment_counts)[,1] %>% sum
#         inPeakData_df = rbind(inPeakData_df, data.frame(bamSample = paste0(sample,"_",dup), PeakSet = set, inPeakN = inPeakN))
#       }
# 
#       for (encode in encodelist) {
#         ## define peak set
#         set = encode
#         ## announce peak set counted against
#         print(paste0("For peak set ", set))
#         peak.gr = peakTest[[set]]
#         fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#         inPeakN = counts(fragment_counts)[,1] %>% sum
#         inPeakData_df = rbind(inPeakData_df, data.frame(bamSample = paste0(sample,"_",dup), PeakSet = set, inPeakN = inPeakN))
#       }
#   }
# }
# write.csv(inPeakData_df, paste0(workdir,"/alignment/frip/inpeak_fragment_counts_v2_me3broad.csv"))

```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=14, fig.height=20}
# Plot fragment in peak proportions
# inPeakData_df <- read.csv(paste0(workdir,"/alignment/frip/inpeak_fragment_counts.csv"), row.names = 1)
inPeakData_df <- read.csv(paste0(workdir,"/alignment/frip/inpeak_fragment_counts_v2_me3broad.csv"), row.names = 1)

## external dataset; longer sample name
data = inPeakData_df$bamSample[nchar(inPeakData_df$bamSample) > 18] %>% str_split_fixed("_",n=3) %>% data.frame() 
inPeakData_df$Dup[nchar(inPeakData_df$bamSample) > 18]  <-  data[,3]
inPeakData_df$Sample[nchar(inPeakData_df$bamSample) > 18]  <- paste0(data$X1,"_",data$X2)
## internal dataset; shorter name
data = inPeakData_df$bamSample[nchar(inPeakData_df$bamSample) < 18] %>% str_split_fixed("_",n=2) %>% data.frame() 
inPeakData_df$Dup[nchar(inPeakData_df$bamSample) < 18 ] <- data[,2]
inPeakData_df$Sample[nchar(inPeakData_df$bamSample) < 18 ] <- data[,1]

# add fragment count data
inPeakData_df <- merge(alignDupSummary, inPeakData_df, by="Sample")
# select the appropriate comparison fragment count
inPeakData_df$compareCount = ifelse(inPeakData_df$Dup == "rmDup", inPeakData_df$UniqueFragNum, inPeakData_df$MappedFragNum_hg19)
# calculate frip score
inPeakData_df$frip = inPeakData_df$inPeakN / inPeakData_df$compareCount * 100

# add plotting groups -- group by sample SEACR/MACS2 peaks and ENCODE H3K27ac/H3K27me3
inPeakData_df$group <- NA
inPeakData_df$group[grep("SEACR",inPeakData_df$PeakSet)] <- "SEACR"
inPeakData_df$group[grep("MACS2",inPeakData_df$PeakSet)] <- "MACS2"
inPeakData_df$group[grep("ENCODE_H3K27ac",inPeakData_df$PeakSet)] <- "ENCODE_H3K27ac"
inPeakData_df$group[grep("ENCODE_H3K27me3",inPeakData_df$PeakSet)] <- "ENCODE_H3K27me3"

inPeakData_df

org_inPeakData_df = inPeakData_df

frip_plot = ggplot(inPeakData_df, aes(SampleLabel, frip, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.7) +
  theme_light(base_size = 25) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  ylim(0, 100) +
  ylab("% of fragments in peaks") +
  xlab("Sample") +
  ggtitle("Proportion of CUT&Tag fragments in peaks") +
  theme(axis.text.x = element_text(angle = 50, hjust = 1)) +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25)) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "bottom") +
  scale_fill_manual(name = "", values = c("steelblue","#043259")) +
  facet_wrap(~group, scales="free_y", ncol=1, nrow=4, strip.position = "top") 

frip_plot
```

### Summary (Main Figure)
``` {r, fig.width=22, fig.height=8}
ggplot(inPeakData_df, aes(SampleLabel, frip, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.9, colour="black") +
  theme_light(base_size = 25) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  ylim(0, 100) +
  ylab("% of fragments in peaks") +
  xlab("") +
  ggtitle("CUT&Tag fragments in ENCODE and sample peaks") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25)) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "bottom") +
  theme(
      strip.background=element_rect(colour="grey40",fill="grey80"),
      strip.text = element_text(colour = 'black')) +
    scale_fill_manual(name = "", values = c("#e1b1b2","#ed6871")) +
  facet_wrap(~group, scales="free_x", ncol=4, nrow=1, strip.position = "top")  + coord_flip()

# # save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_frip_score_facet.svg",
#         dpi = 1200, width = 20.0,
#         height = 9.0, units ="in")

```

## FRiP averages {.tabset}

### ENCODE H3K27ac FRIP - across antibodies
#### main + external samples
```{r , fig.width=7.5, fig.height=5.5}
# ENCODE H3K27ac FRIP - across antibodies
inPeakData_df$antibody = paste0(str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,1], "-", str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,2]) 

df = inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$group == "ENCODE_H3K27ac",c("Sample","Dup","frip","group","SampleLabel","antibody")]
df %<>% dplyr::group_by(antibody) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=antibody, y=meanFrip)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("Antibody") +
  ggtitle("Fragments in ENCODE H3K27ac") +
  theme(axis.text.x = element_text(angle=45, hjust=1))
```

#### Diagenode ENCODE H3K27ac FRIP
```{r , fig.width=5.5, fig.height=5.5}
# diagenode ENCODE H3K27ac FRIP
inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$SampleLabel %in% c("H3K27ac-diag-1","H3K27ac-diag-2") & inPeakData_df$group == "ENCODE_H3K27ac",c("Sample","Dup","frip","group","SampleLabel")] %>% pull(frip) %>% mean -> m
inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$SampleLabel %in% c("H3K27ac-diag-1","H3K27ac-diag-2") & inPeakData_df$group == "ENCODE_H3K27ac",c("Sample","Dup","frip","group","SampleLabel")] %>% pull(frip) %>% sd -> s

print(paste0("Mean: ", m))
print(paste0("Standard deviation: ", s))
```

### H3K27ac sample FRIP in ENCODE and sample peaks
#### main samples
```{r, fig.width=9.5, fig.height=5.5}
# H3K27ac FRIP 
inPeakData_df$EpMark = str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,1]
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$EpMark == "H3K27ac" & !(inPeakData_df$Sample %in% c("H3K27ac_SRR8383507","H3K27ac_SRR8383508")),
                   c("Sample","Dup","frip","group","SampleLabel","EpMark","antibody")]
df %<>% dplyr::group_by(group) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=group, y=meanFrip, fill=group)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("PeakSet") +
  ggtitle("H3K27ac fragments in ENCODE and Sample Peaks")
```

#### main + external samples
```{r, fig.width=9.5, fig.height=5.5}
# H3K27ac FRIP 
inPeakData_df$EpMark = str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,1]
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$EpMark == "H3K27ac" ,
                   c("Sample","Dup","frip","group","SampleLabel","EpMark","antibody")]
df %<>% dplyr::group_by(group) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=group, y=meanFrip, fill=group)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("PeakSet") +
  ggtitle("H3K27ac fragments in ENCODE and H3K27ac Sample Peaks")
```

#### external samples
```{r, fig.width=9.5, fig.height=5.5}
# H3K27ac FRIP 
inPeakData_df$EpMark = str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,1]
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$EpMark == "H3K27ac" & inPeakData_df$Sample %in% c("H3K27ac_SRR8383507","H3K27ac_SRR8383508"),
                   c("Sample","Dup","frip","group","SampleLabel","EpMark","antibody")]
df %<>% dplyr::group_by(group) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=group, y=meanFrip, fill=group)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("PeakSet") +
  ggtitle("H3K27ac fragments in ENCODE and Sample Peaks")
```

### ENCODE H3K27me3 FRIP - across antibodies
#### for main + external samples
```{r , fig.width=7.5, fig.height=5.5}
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$group == "ENCODE_H3K27me3" ,
                   c("Sample","Dup","frip","group","SampleLabel","antibody")]
df %<>% dplyr::group_by(antibody) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=antibody, y=meanFrip)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("Antibody") +
  ggtitle("Fragments in ENCODE H3K27me3") +
  theme(axis.text.x = element_text(angle=45,hjust=1))
```

###  H3K27me3 sample FRIP in ENCODE and sample peaks
#### main samples
```{r , fig.width=10, fig.height=5.5}
# H3K27me3 FRIP in house samples
inPeakData_df$EpMark = str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,1]
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & 
                     inPeakData_df$EpMark == "H3K27me3" & !(inPeakData_df$Sample %in% c("H3K27me3_SRR11074238","H3K27me3_SRR11074239")),
                   c("Sample","Dup","frip","group","SampleLabel","EpMark","antibody")]
df %<>% dplyr::group_by(group) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=group, y=meanFrip, fill=group)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("EpMark") +
  ggtitle("H3K27me3 fragments in ENCODE and H3K27me3 Sample Peaks")
```

#### main + external samples
```{r , fig.width=9.5, fig.height=5.5}
inPeakData_df$EpMark = str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,1]
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & 
                     inPeakData_df$EpMark %in% grep("H3K27me3", unique(inPeakData_df$EpMark), value=T),
                   c("Sample","Dup","frip","group","SampleLabel","EpMark","antibody")]
df %<>% dplyr::group_by(group) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=group, y=meanFrip, fill=group)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("EpMark") +
  ggtitle("H3K27me3 fragments in ENCODE and H3K27me3 Sample Peaks")
```

#### external samples
```{r , fig.width=9.5, fig.height=5.5}
inPeakData_df$EpMark = str_split_fixed(inPeakData_df$SampleLabel, pattern="-", n=3)[,1]
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & 
                     inPeakData_df$Sample %in% c("H3K27me3_SRR11074238","H3K27me3_SRR11074239"),
                   c("Sample","Dup","frip","group","SampleLabel","EpMark","antibody")]
df %<>% dplyr::group_by(group) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=group, y=meanFrip, fill=group)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("EpMark") +
  ggtitle("H3K27me3 fragments in ENCODE and H3K27me3 Sample Peaks")
```

### Target mark ENCODE enrichment 
(target mark FRIP / total FRIP)
#### by epigenetic modification
```{r enrichemnt in corresponding ENCODE mark, fig.width=7.5, fig.height=5.5}
# reformat data
df = inPeakData_df[inPeakData_df$Dup == "rmDup" , c("Sample","Dup","frip","group","SampleLabel","antibody","EpMark","Set")]
df_w = pivot_wider(df, names_from=c("group"), values_from="frip")

# inhouse H3K27ac
df1 = df_w[df_w$Set == "second" & df_w$EpMark == "H3K27ac",]
df1$ENCODE_Ratio = df1$ENCODE_H3K27ac / (df1$ENCODE_H3K27ac + df1$ENCODE_H3K27me3)
# inhouse H3K27me3
df2 = df_w[df_w$Set == "second" & df_w$EpMark == "H3K27me3",]
df2$ENCODE_Ratio = df2$ENCODE_H3K27me3 / (df2$ENCODE_H3K27ac + df2$ENCODE_H3K27me3)

# published H3K27ac
df3 = df_w[df_w$Set == "first" & df_w$Sample %in% c("H3K27ac_SRR8383507", "H3K27ac_SRR8383508"),]
df3$ENCODE_Ratio = df3$ENCODE_H3K27ac / (df3$ENCODE_H3K27ac + df3$ENCODE_H3K27me3)
# published H3K27me3
df4 = df_w[df_w$Set == "first" & df_w$Sample %in% c("H3K27me3_SRR11074238", "H3K27me3_SRR11074239"),]
df4$ENCODE_Ratio = df4$ENCODE_H3K27me3 / (df4$ENCODE_H3K27ac + df4$ENCODE_H3K27me3)

plotdata = rbind(df1, df2) %>% dplyr::group_by(EpMark) %>% dplyr::summarize(mean=mean(ENCODE_Ratio), sd=sd(ENCODE_Ratio))
plotdata
ggplot(plotdata, aes(x=EpMark, y=mean)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("Epigenetic Mark") +
  ggtitle("Inhouse CT sample target enrichment")

plotdata = rbind(df3, df4) 
plotdata$EpMark <- str_extract(plotdata$EpMark, "H3K27ac|H3K27me3")
plotdata %<>% dplyr::group_by(EpMark) %>% dplyr::summarize(mean=mean(ENCODE_Ratio), sd=sd(ENCODE_Ratio))
plotdata
ggplot(plotdata, aes(x=EpMark, y=mean)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("Epigenetic Mark") +
  ggtitle("External CT sample target enrichment")
```

#### by antibody 
```{r, fig.width=7.5, fig.height=5.5}
plotdata = rbind(df1, df2,df3,df4) %>% dplyr::group_by(antibody) %>% dplyr::summarize(mean=mean(ENCODE_Ratio), sd=sd(ENCODE_Ratio))
plotdata
ggplot(plotdata, aes(x=antibody, y=mean)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("Antibody") +
  ggtitle("Antibody target mark enrichment") + 
  theme(axis.text.x = element_text(angle=45,hjust=1))
```


### MACS2 FRiP - across antibodies
```{r , fig.width=7.5, fig.height=5.5}
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$group == "MACS2",
                   c("Sample","Dup","frip","group","SampleLabel","antibody")]
df %<>% dplyr::group_by(antibody) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df

ggplot(df, aes(x=antibody, y=meanFrip)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("Antibody") +
  ggtitle("MACS2 FRiP scores")  + 
  theme(axis.text.x = element_text(angle=45,hjust=1))
```

### SEACR FRIP - across antibodies
```{r , fig.width=7.5, fig.height=5.5}
df = inPeakData_df[inPeakData_df$Dup == "rmDup" & inPeakData_df$group == "SEACR",c("Sample","Dup","frip","group","SampleLabel","antibody")]
df %<>% dplyr::group_by(antibody) %>% dplyr::summarise(meanFrip = mean(frip), sdFrip = sd(frip))
df
ggplot(df, aes(x=antibody, y=meanFrip)) +
  geom_bar( stat="identity", fill="skyblue", alpha=0.8 ) + 
  theme_classic(base_size = 18) +
  geom_errorbar(aes(ymin = meanFrip-sdFrip, ymax = meanFrip+sdFrip), width=0.4) +
  ylab("Average FRiP scores") +
  xlab("Antibody") +
  ggtitle("SEACR FRiP scores") + 
  theme(axis.text.x = element_text(angle=45,hjust=1))
```


## Summary Extended (Supplementary)
```{r}
# # load ENCODE ChIP peaks
# datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
# ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
# ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")

# combine with high-dup (Di's) CUT&Tag and Meers CnR samples
# sampleSet=c("Abcam-ab177178", "Diagenode_50x",
#             "Diagenode_100x", "H3K27ac_SRR8581604_CnR", "H3K27me3", "H3K27me3_SRR9073702_CnR",
#             "Abcam-ab4729", "ActiveMotif")
# 
# # rerun select samples
# # sampleSet=c("Abcam-ab177178", "Abcam-ab4729")
# # sampleSet=c("ActiveMotif")
# 
# peakpath="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis/peaks/"
# # bampath="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis/bam/"
# bampath="/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking/alignment/bam/"
# dup_l=c("rmDup","withDup")
# caller_l=c("MACS2","SEACR")
# encodelist = c("ENCODE_H3K27ac", "ENCODE_H3K27me3")
# 
# ## Sample peak FRiP scores
# # frip_df = c()
# # frip_df <- frip_df[!(frip_df$sample %in% sampleSet),]
# 
# for (sample in sampleSet) {
#   for (caller in caller_l) {
#     for (dup in dup_l) {
#       
#       # peak set name
#       setName=paste0(sample,"_",caller,"_",dup)
#       print(paste0("Analysing: ", setName))
#     
#       # # define peak file path
#       # peakFile = paste0(peakpath, dup, "/", sample, "_", caller,".bed")
#       
#       # define peak and bam file path
#       if (dup == "rmDup"){
#         # bamFile = paste0(bampath, dup, "/", sample, "_bowtie2_", dup, ".mapped.sorted.bam")
#         bamFile = paste0(bampath, sample, "_bowtie2_", dup, ".mapped.sorted.bam")
#         peakFile = paste0(peakpath, dup, "/", sample, "_", caller,".bed")
#       }
#       if (dup == "withDup"){
#         # bamFile = paste0(bampath, dup, "/", sample, "_",dup, "_bowtie2.mapped.bam")
#         bamFile = paste0(bampath, sample, "_",dup, "_bowtie2.mapped.sorted.bam")
#         peakFile = paste0(peakpath, dup, "/", sample, "_", caller,"_",dup,".bed")
#       }
#       
#       print(paste0("file: ", bamFile))
#       
#       # read in peak regions, and filter for blacklist and irregular chromosomes
#       print("Reading and filtering peaks...")
#       peak.gr = ChIPseeker::readPeakFile(peakFile, as = "GRanges") %>% IRanges::subsetByOverlaps(., hg19_blacklist, invert = TRUE) %>%
#         BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
# 
#       # count fragments intersecting peaks
#       print("Counting overlapping fragments...")
#       fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#       counts = counts(fragment_counts)[,1] %>% sum
#       frip_df = rbind(frip_df, data.frame(setName = setName,
#                                           Sample=sample,
#                                           Caller=caller,
#                                           Dup=dup,
#                                           FragCount = counts))
#     }
#   }
#   
# }
# 
# ## ENCODE peak FRiP scores
# for (sample in sampleSet) {
#     for (dup in dup_l) {
#       for (encode in encodelist) {
#               ## define peak set
#               setName = encode
#               ## announce peak set counted against
#               print(paste0("For peak set ", setName))
#               
#               if (setName=="ENCODE_H3K27ac") {peak.gr = ENCODE_H3K27ac}
#               if (setName=="ENCODE_H3K27me3") {peak.gr = ENCODE_H3K27me3}
#               
#                # define bam file path
#               if (dup == "rmDup"){
#                 # bamFile = paste0(bampath, dup, "/", sample, "_bowtie2_", dup, ".mapped.sorted.bam")
#                 bamFile = paste0(bampath, sample, "_bowtie2_", dup, ".mapped.sorted.bam")
#                 # peakFile = paste0(peakpath, dup, "/", sample, "_", caller,".bed")
#               }
#               if (dup == "withDup"){
#                 # bamFile = paste0(bampath, dup, "/", sample, "_",dup, "_bowtie2.mapped.bam")
#                 bamFile = paste0(bampath, sample, "_",dup, "_bowtie2.mapped.sorted.bam")
#                 # peakFile = paste0(peakpath, dup, "/", sample, "_", caller,"_",dup,".bed")
#               }
#       
#               print(paste0("file: ", bamFile))
#       
#               fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#               counts = counts(fragment_counts)[,1] %>% sum
#               frip_df = rbind(frip_df, data.frame(setName = setName,
#                                           Sample=sample,
#                                           Caller=setName,
#                                           Dup=dup,
#                                           FragCount = counts))
#             }
#     }
# }

# write.csv(frip_df, paste0(workdir,"/alignment/frip/inpeak_fragment_counts_supplementary.csv"))

```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=22, fig.height=12}
# read in counts
inPeakData_df <- read.csv(paste0(workdir,"/alignment/frip/inpeak_fragment_counts_supplementary.csv"), row.names = 1)
# add fragment count data
inPeakData_df <- merge(alignDupSummary, inPeakData_df, by="Sample")
# select the appropriate comparison fragment count
inPeakData_df$compareCount = ifelse(inPeakData_df$Dup == "rmDup", inPeakData_df$UniqueFragNum, inPeakData_df$MappedFragNum_hg19)
# calculate frip score
inPeakData_df$frip = inPeakData_df$FragCount / inPeakData_df$compareCount * 100

# add plotting groups -- group by sample SEACR/MACS2 peaks and ENCODE H3K27ac/H3K27me3
inPeakData_df$group <- NA
inPeakData_df$group[grep("SEACR",inPeakData_df$setName)] <- "SEACR"
inPeakData_df$group[grep("MACS2",inPeakData_df$setName)] <- "MACS2"
inPeakData_df$group[grep("ENCODE_H3K27ac",inPeakData_df$setName)] <- "ENCODE_H3K27ac"
inPeakData_df$group[grep("ENCODE_H3K27me3",inPeakData_df$setName)] <- "ENCODE_H3K27me3"
inPeakData_df

# combine with all other samples 
cols = intersect(colnames(org_inPeakData_df), colnames(inPeakData_df))
plotdf = rbind(inPeakData_df[cols], org_inPeakData_df[cols])

ggplot(plotdf, aes(SampleLabel, frip, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.9, colour="black") +
  theme_light(base_size = 25) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  ylim(0, 100) +
  ylab("% of fragments in peaks") +
  xlab("") +
  ggtitle("CUT&Tag fragments in ENCODE and sample peaks") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25,face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "bottom") +
  theme(
      strip.background=element_rect(colour="grey40",fill="grey80"),
      strip.text = element_text(colour = 'black')) +
    scale_fill_manual(name = "", values = c("#e1b1b2","#ed6871")) +
  facet_wrap(~group, scales="free_x", ncol=4, nrow=1, strip.position = "top")  + coord_flip()

# save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_frip_score_facet_supp.svg",
#         dpi = 1200, width = 20.0,
#         height = 10.0, units ="in")
```

# Fraction of reads in sample and ENCODE peak intersecting regions (Supplementary)
```{r}
# # load ENCODE peak regions
# datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
# ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
# ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")

# find intersection with CT sample peaks

# bampath="/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking/alignment/bam/"
# # list CT peak ranges
# peakTest <- c(peakList, ext_peakList, sup_peakList, list(ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3))
# # list sample groups to loop over
# ext_df$bamSample[ext_df$Source == "InHouse"] <- ext_df$Sample[ext_df$Source == "InHouse"]
# ext_df$bamSample[ext_df$Source == "External"]  <- ext_df$SampleLabel[ext_df$Source == "External"] %>% gsub("-","_",.)
# insample = ext_df$bamSample[ext_df$Source == "InHouse"] %>% unique %>% sort()
# exsample = ext_df$bamSample[ext_df$Source == "External"] %>% unique %>% sort()
# supsample = sup_df$Sample[sup_df$Source == "Supplementary"] %>% unique %>% sort()
# sampleList <- c(insample, exsample, supsample)
# 
# acSample= c(ext_df$bamSample[ext_df$EpMark == "H3K27ac"], sup_df$Sample[sup_df$Source == "Supplementary" & sup_df$EpMark == "H3K27ac"]) %>% unique
# meSample= c(ext_df$bamSample[ext_df$EpMark == "H3K27me3"], sup_df$Sample[sup_df$Source == "Supplementary" & sup_df$EpMark == "H3K27me3"]) %>% unique
# 
# dupList = c("rmDup", "withDup")
# callerList = c("MACS2", "SEACR")
# 
# # peaksetNames <- ext_df$PeakSet %>% unique
# 
# inPeakData_df = c()
# for (sample in sampleList) {
#   if (sample %in% acSample) {encode.gr = ENCODE_H3K27ac} 
#   if (sample %in%  meSample) {encode.gr = ENCODE_H3K27me3} 
# 
#     for (dup in dupList) {
#   
#     ## define bam file path
#        # in house dataset
#        if (sample %in% insample) {
#          bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam") }
# 
#        # supplementary dataset
#       if (sample %in% c(exsample, supsample)) {
#          if (dup == "rmDup"){
#                 bamFile = paste0(bampath, sample, "_bowtie2_", dup, ".mapped.sorted.bam") }
#          if (dup == "withDup"){
#                 bamFile = paste0(bampath, sample, "_",dup, "_bowtie2.mapped.sorted.bam") }
#       }
#     
#        print(paste0("file: ", bamFile))
#   
#         for (caller in callerList) {
#           ## define peak set
#           set = paste0(sample,"_",caller,"_",dup)
#           ## announce peak set counted against
#           print(paste0("For peak set ", set))
#           peak.gr = peakTest[[set]]
#           
#           # find intersecting regions within peak set, attempt 1
#           fo <- findOverlaps(peak.gr, encode.gr)
#           peak.gr = pintersect(peak.gr[queryHits(fo)], encode.gr[subjectHits(fo)])
#           
#           # peak.gr = GenomicRanges::GRanges(seqnames = peaks$seqnames, IRanges(start = peaks$start, end = peaks$end), strand = "*")
#           fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#           inPeakN = counts(fragment_counts)[,1] %>% sum
#           inPeakData_df = rbind(inPeakData_df, data.frame(
#                         Sample=sample,
#                         PeakSet = set, 
#                         Caller = caller,
#                         Dup=dup,
#                         inPeakN = inPeakN))
#         }
#     }
# }

# write.csv(inPeakData_df, paste0(workdir,"/alignment/frip/inpeak_intersect_fragment_counts_supp.csv"))

```

```{r}
# Count ENCODE reads in peak set
# # list CT peak ranges
# peakTest <- c(peakList, ext_peakList, sup_peakList)
# # restrict only to rmDup peak sets
# peakTest = peakTest[grep("rmDup", names(peakTest))]
# peakNames = names(peakTest)
# 
# # bam paths
# bampath="/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking/alignment/bam/"
# acBam = paste0(bampath,"H3K27ac_ENCFF384ZZM.bam")
# meBam = paste0(bampath,"H3K27me3_ENCFF676ORH.bam")
# 
# # H3K27ac ENCODE FRiPs
# acENCODE_inPeakData_df = c()
# for (i in 1:length(peakTest)) {
#   bamFile = acBam
#   encode.gr = ENCODE_H3K27ac
#   peak.gr = peakTest[[i]]
#   setName = peakNames[[i]]
#   
#   # find intersecting regions within peak set, attempt 1
#   fo <- findOverlaps(peak.gr, encode.gr)
#   peak.gr = pintersect(peak.gr[queryHits(fo)], encode.gr[subjectHits(fo)])
#           
#           # peak.gr = GenomicRanges::GRanges(seqnames = peaks$seqnames, IRanges(start = peaks$start, end = peaks$end), strand = "*")
#           fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = FALSE, by_rg = FALSE, format = "bam")
#           inPeakN = counts(fragment_counts)[,1] %>% sum
#           acENCODE_inPeakData_df = rbind(acENCODE_inPeakData_df, data.frame(
#                         Sample="ENCODE_H3K27ac",
#                         PeakSet = setName, 
#                         inPeakN = inPeakN))
# }
# 
# # H3K27me3 ENCODE FRiPs
# meENCODE_inPeakData_df = c()
# for (i in 1:length(peakTest)) {
#   bamFile = meBam
#   encode.gr = ENCODE_H3K27me3
#   peak.gr = peakTest[[i]]
#   setName = peakNames[[i]]
#   
#   # find intersecting regions within peak set, attempt 1
#   fo <- findOverlaps(peak.gr, encode.gr)
#   peak.gr = pintersect(peak.gr[queryHits(fo)], encode.gr[subjectHits(fo)])
#   
#           # peak.gr = GenomicRanges::GRanges(seqnames = peaks$seqnames, IRanges(start = peaks$start, end = peaks$end), strand = "*")
#           fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = FALSE, by_rg = FALSE, format = "bam")
#           inPeakN = counts(fragment_counts)[,1] %>% sum
#           meENCODE_inPeakData_df = rbind(meENCODE_inPeakData_df, data.frame(
#                         Sample="ENCODE_H3K27me3",
#                         PeakSet = setName, 
#                         inPeakN = inPeakN))
# }
# 
# inPeakData_df = rbind(acENCODE_inPeakData_df, meENCODE_inPeakData_df)
# write.csv(inPeakData_df, paste0(workdir,"/alignment/frip/inpeak_intersect_fragment_counts_encode_supp.csv"))

# # save int as bed to check
# df = data.frame(seqnames(int), start(int), end(int))
# write.table(df, "/Volumes/pu1918/ephemeral/AD_cutandtag/test.bed", row.names = FALSE,col.names = FALSE, quote=FALSE, sep="\t")
```


``` {r, fig.width=22, fig.height=12}
# read in CT counts
ctcounts <- read.csv(paste0(workdir,"/alignment/frip/inpeak_intersect_fragment_counts_supp.csv"), row.names=1)
# restrict ctcounts to rmDup CT peaks
ctcounts = ctcounts[ctcounts$Dup == "rmDup",] 
ctcounts$group <- "CUT&Tag reads"
# merge with all mapped read counts
plotdf <- merge(ctcounts, alignDupSummary, by="Sample")
# select the appropriate comparison fragment count
plotdf$compareCount = ifelse(plotdf$Dup == "rmDup", plotdf$UniqueFragNum, plotdf$MappedFragNum_hg19)
# calculate frip score
plotdf$frip = plotdf$inPeakN / plotdf$compareCount * 100

# read in ENCODE counts
encodecounts <- read.csv(paste0(workdir,"/alignment/frip/inpeak_intersect_fragment_counts_encode_supp.csv"), row.names=1)
# reduce to relevant epigenetic mark
mesamples <- grep("H3K27me3|IGF128038|IGF128039", encodecounts$PeakSet, value=TRUE) %>% unique
othsamples <- encodecounts$PeakSet[!(encodecounts$PeakSet %in% mesamples)] %>% unique
acencodecounts = encodecounts[encodecounts$Sample == "ENCODE_H3K27ac" & encodecounts$PeakSet %in% othsamples,]
meencodecounts = encodecounts[encodecounts$Sample == "ENCODE_H3K27me3" & encodecounts$PeakSet %in% mesamples,]
encodecounts = rbind(acencodecounts, meencodecounts)
# add missing columns to encodecounts
encodecounts$Caller <- str_extract(encodecounts$PeakSet, "MACS2|SEACR")
encodecounts$group <- "ENCODE reads"
encodecounts$SampleLabel <- encodecounts$Sample
# calculate frips
ENCODE_total_frags = c(9770603, 12064137) # H3K27ac / H3K27me3
# select the appropriate comparison fragment count
encodecounts$compareCount = ifelse(encodecounts$Sample == "ENCODE_H3K27ac", ENCODE_total_frags[1], ENCODE_total_frags[2])
# calculate frip score
encodecounts$frip = encodecounts$inPeakN / encodecounts$compareCount * 100

# combine tables
cols = intersect(colnames(plotdf), colnames(encodecounts))
plotdf = rbind(plotdf[cols], encodecounts[cols])
  

# edit sample labels
plotdf$SampleLabel[plotdf$SampleLabel == "ActiveMotif"] <- "H3K27ac-ActiveMotif-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Abcam-ab4729"] <- "H3K27ac-ab4729-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Abcam-ab177178"] <- "H3K27ac-ab177-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Diagenode_100x"] <- "H3K27ac-Diag100x-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Diagenode_50x"] <- "H3K27ac-Diag50x-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27ac_SRR8581604_CnR"] <- "H3K27ac-Meers-CnR"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3"] <- "H3K27me3-ab9733-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3_SRR9073702_CnR"] <- "H3K27me3-Meers-CnR"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27ac_SRR8383507"] <- "H3K27ac-Kaya-Okur-1"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27ac_SRR8383508"] <- "H3K27ac-Kaya-Okur-2"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3_SRR11074238"] <- "H3K27me3-Kaya-Okur-1"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3_SRR11074239"] <- "H3K27me3-Kaya-Okur-2"

# rename peak sets
namedf = plotdf[plotdf$group == "CUT&Tag reads", c("PeakSet","SampleLabel")] %>% unique()
namedf$PeakSetName <- namedf$SampleLabel
cols <- c("PeakSet","PeakSetName")
plotdf <- merge(plotdf, namedf[cols], by="PeakSet")

# add epmark info
plotdf$EpMark <- str_extract(plotdf$PeakSetName, "H3K27ac|H3K27me3")

# plot
ggplot(plotdf, aes(PeakSetName, frip, fill=group)) +
  geom_bar(aes(fill = group), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.9, colour="black") +
  theme_light(base_size = 25) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  ylim(0, 100) +
  ylab("% of fragments in peaks") +
  xlab("") +
  ggtitle("CUT&Tag fragments in ENCODE and sample peak intersection") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25,face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "bottom") +
  theme(
      strip.background=element_rect(colour="grey40",fill="grey80"),
      strip.text = element_text(colour = 'black')) +
    scale_fill_manual(name = "", values = c("skyblue","steelblue")) +
  facet_grid(EpMark~Caller, scales="free_y",space = "free")  + coord_flip()

# # save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_intersect_frip_score_facet_supp.svg",
#         dpi = 1200, width = 20.0,
#         height = 12.0, units ="in")
```


# Fraction of reads in ENCODE H3K27ac ChIP-seq and ATAC-seq peaks
ATAC-seq libraries: ENCLB918NXF, ENCLB758GEG from https://www.encodeproject.org/experiments/ENCSR483RKN/
ATAC data reprocessed for reads aligned to hg19 -- comparing peaks called

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
peakdir ="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ATAC/peaks"
ATAC_path = file.path(peakdir, "K562_ATACseq.mRp.clN_peaks.narrowPeak")
ATAC = ChIPseeker::readPeakFile(ATAC_path, as = "GRanges") %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE) 

overlaps_ATAC_ENCODE = GenomicRanges::countOverlaps(query = ATAC, subject = ENCODE_H3K27ac)
overlaps_ENCODE_ATAC = GenomicRanges::countOverlaps(query = ENCODE_H3K27ac, subject = ATAC)

l = length(overlaps_ATAC_ENCODE[overlaps_ATAC_ENCODE != 0])
print(paste0("Number of ATAC peaks overlapping ENCODE: ", l))
l = length(overlaps_ENCODE_ATAC[overlaps_ENCODE_ATAC != 0])
print(paste0("Number of ENCODE peaks overlapping ATAC: ", l))

l = length(ATAC)
print(paste0("Number of ATAC peaks: ", l))
l = length(ENCODE_H3K27ac)
print(paste0("Number of ENCODE peaks: ", l))

set="individual"
dup="rmDup"
sampleList <- ext_df$Sample[ext_df$Source == "InHouse"] %>% unique
sampleList_KO_ac <- ext_df$Sample[ext_df$Source == "External" & ext_df$EpMark == "H3K27ac"] %>% unique
sampleList_KO_me <- ext_df$Sample[ext_df$Source == "External" & ext_df$EpMark == "H3K27me3"] %>% unique

# path to external bam files
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis/bam/"

## C&T fragments in ATAC-only peaks 
ATAC_not_ENCODE = IRanges::subsetByOverlaps(ATAC, ENCODE_H3K27ac, invert = TRUE)
## C&T fragments in ENCODE-only peaks
ENCODE_not_ATAC = IRanges::subsetByOverlaps(ENCODE_H3K27ac, ATAC, invert = TRUE)
## C&T fragments in ENCODE/ATAC overlapping peaks
ENCODE_and_ATAC = IRanges::subsetByOverlaps(ENCODE_H3K27ac, ATAC)

```

## C&T fragments in ENCODE H3K27ac peaks 
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# # set peak regions of interest
# peakRes = data.frame(ENCODE_H3K27ac)
# 
# # Count reads from in-house CUT&Tag dataset
# Total_ENCODE_inPeakData = c()
# for(sample in sampleList){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ENCODE_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ENCODE_inPeakData = rbind(Total_ENCODE_inPeakData, data.frame(Sample = sample, Total_ENCODE_inPeakN = Total_ENCODE_inPeakN))
# }
# 
# # Count reads from Kaya Okur CUT&Tag dataset
# ## H3K27ac
# Total_ENCODE_inPeakData_KO_ac = c()
# for(sample in sampleList_KO_ac){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27ac_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ENCODE_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ENCODE_inPeakData_KO_ac = rbind(Total_ENCODE_inPeakData_KO_ac, data.frame(Sample = sample, Total_ENCODE_inPeakN = Total_ENCODE_inPeakN))
# }
# ## H3K27me3
# Total_ENCODE_inPeakData_KO_me = c()
# for(sample in sampleList_KO_me){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27me3_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ENCODE_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ENCODE_inPeakData_KO_me = rbind(Total_ENCODE_inPeakData_KO_me, data.frame(Sample = sample, Total_ENCODE_inPeakN = Total_ENCODE_inPeakN))
# }
# 
# Total_ENCODE_inPeakData <- rbind(Total_ENCODE_inPeakData, Total_ENCODE_inPeakData_KO_ac) %>% rbind(.,Total_ENCODE_inPeakData_KO_me)
# Total_ENCODE_inPeakData

# write.csv(Total_ENCODE_inPeakData, paste0(workdir,"/alignment/frip/Total_ENCODE_inPeakData.csv"))
```

## C&T fragments in ATAC peaks 
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# set peak regions of interest
# peakRes = data.frame(ATAC)
# 
# # Count reads from in-house CUT&Tag dataset
# Total_ATAC_inPeakData = c()
# for(sample in sampleList){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ATAC_inPeakData = rbind(Total_ATAC_inPeakData, data.frame(Sample = sample, Total_ATAC_inPeakN = Total_ATAC_inPeakN))
# }
# 
# # Count reads from Kaya Okur CUT&Tag dataset
# ## H3K27ac
# Total_ATAC_inPeakData_KO_ac = c()
# for(sample in sampleList_KO_ac){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27ac_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ATAC_inPeakData_KO_ac = rbind(Total_ATAC_inPeakData_KO_ac, data.frame(Sample = sample, Total_ATAC_inPeakN = Total_ATAC_inPeakN))
# }
# ## H3K27me3
# Total_ATAC_inPeakData_KO_me = c()
# for(sample in sampleList_KO_me){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27me3_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ATAC_inPeakData_KO_me = rbind(Total_ATAC_inPeakData_KO_me, data.frame(Sample = sample, Total_ATAC_inPeakN = Total_ATAC_inPeakN))
# }
# 
# Total_ATAC_inPeakData <- rbind(Total_ATAC_inPeakData, Total_ATAC_inPeakData_KO_ac) %>% rbind(., Total_ATAC_inPeakData_KO_me)
# Total_ATAC_inPeakData

# write.csv(Total_ATAC_inPeakData, paste0(workdir,"/alignment/frip/Total_ATAC_inPeakData.csv"))
```

## C&T fragments in ATAC-only peaks 
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# # set peak regions of interest
# peakRes = data.frame(ATAC_not_ENCODE)
# 
# # Count reads from in-house CUT&Tag dataset
# ATAC_inPeakData = c()
# for(sample in sampleList){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   ATAC_inPeakData = rbind(ATAC_inPeakData, data.frame(Sample = sample, ATAC_inPeakN = ATAC_inPeakN))
# }
# 
# # Count reads from Kaya Okur CUT&Tag dataset
# ## H3K27ac
# ATAC_inPeakData_KO_ac = c()
# for(sample in sampleList_KO_ac){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27ac_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   ATAC_inPeakData_KO_ac = rbind(ATAC_inPeakData_KO_ac, data.frame(Sample = sample, ATAC_inPeakN = ATAC_inPeakN))
# }
# ## H3K27me3
# ATAC_inPeakData_KO_me = c()
# for(sample in sampleList_KO_me){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27me3_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   ATAC_inPeakData_KO_me = rbind(ATAC_inPeakData_KO_me, data.frame(Sample = sample, ATAC_inPeakN = ATAC_inPeakN))
# }
# 
# ATAC_inPeakData <- rbind(ATAC_inPeakData, ATAC_inPeakData_KO_ac) %>% rbind(., ATAC_inPeakData_KO_me)
# ATAC_inPeakData
# 
# # write.csv(ATAC_inPeakData, paste0(workdir,"/alignment/frip/ATAC_inPeakData.csv"))

```

## C&T fragments in ENCODE-only peaks
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# # set peak regions of interest
# peakRes = data.frame(ENCODE_not_ATAC)
# 
# # Count reads from in-house CUT&Tag dataset
# ENCODE_inPeakData = c()
# for(sample in sampleList){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ENCODE_inPeakN = counts(fragment_counts)[,1] %>% sum
#   ENCODE_inPeakData = rbind(ENCODE_inPeakData, data.frame(Sample = sample, ENCODE_inPeakN = ENCODE_inPeakN))
# }
# 
# # Count reads from Kaya Okur CUT&Tag dataset
# ## H3K27ac
# ENCODE_inPeakData_KO_ac = c()
# for(sample in sampleList_KO_ac){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27ac_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ENCODE_inPeakN = counts(fragment_counts)[,1] %>% sum
#   ENCODE_inPeakData_KO_ac = rbind(ENCODE_inPeakData_KO_ac, data.frame(Sample = sample, ENCODE_inPeakN = ENCODE_inPeakN))
# }
# ## H3K27me3
# ENCODE_inPeakData_KO_me = c()
# for(sample in sampleList_KO_me){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27me3_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ENCODE_inPeakN = counts(fragment_counts)[,1] %>% sum
#   ENCODE_inPeakData_KO_me = rbind(ENCODE_inPeakData_KO_me, data.frame(Sample = sample, ENCODE_inPeakN = ENCODE_inPeakN))
# }
# 
# ENCODE_inPeakData <- rbind(ENCODE_inPeakData,ENCODE_inPeakData_KO_ac) %>% rbind(.,ENCODE_inPeakData_KO_me)
# ENCODE_inPeakData
# 
# # write.csv(ENCODE_inPeakData, paste0(workdir,"/alignment/frip/ENCODE_inPeakData.csv"))
```

## C&T fragments in ENCODE/ATAC overlapping peaks
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# select peak regions of interest
# peakRes = data.frame(ENCODE_and_ATAC)
# 
# # Count reads from in-house CUT&Tag dataset
# ENCODE_and_ATAC_inPeakData = c()
# for(sample in sampleList){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ENCODE_and_ATAC_inPeak = counts(fragment_counts)[,1] %>% sum
#   ENCODE_and_ATAC_inPeakData = rbind(ENCODE_and_ATAC_inPeakData, data.frame(Sample = sample, ENCODE_and_ATAC_inPeak = ENCODE_and_ATAC_inPeak))
# }
# 
# # Count reads from Kaya Okur CUT&Tag dataset
# ## H3K27ac
# ENCODE_and_ATAC_inPeakData_KO_ac = c()
# for(sample in sampleList_KO_ac){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27ac_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ENCODE_and_ATAC_inPeak = counts(fragment_counts)[,1] %>% sum
#   ENCODE_and_ATAC_inPeakData_KO_ac = rbind(ENCODE_and_ATAC_inPeakData_KO_ac, data.frame(Sample = sample, ENCODE_and_ATAC_inPeak = ENCODE_and_ATAC_inPeak))
# }
# ## H3K27me3
# ENCODE_and_ATAC_inPeakData_KO_me = c()
# for(sample in sampleList_KO_me){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27me3_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   ENCODE_and_ATAC_inPeak = counts(fragment_counts)[,1] %>% sum
#   ENCODE_and_ATAC_inPeakData_KO_me = rbind(ENCODE_and_ATAC_inPeakData_KO_me, data.frame(Sample = sample, ENCODE_and_ATAC_inPeak = ENCODE_and_ATAC_inPeak))
# }
# 
# ENCODE_and_ATAC_inPeakData <- rbind(ENCODE_and_ATAC_inPeakData, ENCODE_and_ATAC_inPeakData_KO_ac) %>% rbind(.,ENCODE_and_ATAC_inPeakData_KO_me)
# ENCODE_and_ATAC_inPeakData
# 
# # write.csv(ENCODE_and_ATAC_inPeakData, paste0(workdir,"/alignment/frip/ENCODE_and_ATAC_inPeakData.csv"))

```

## ENCODE fragments in ATAC-only peaks
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis"
# ENCODE_sampleList = c("H3K27ac_ENCFF384ZZM", "H3K27me3_ENCFF676ORH")
# peakRes = data.frame(ATAC)
# ENCODE_ATAC_inPeakData = c()
# 
# for(sample in ENCODE_sampleList){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   bamFile = paste0(datadir, "/ENCODE_files/bam/", sample, ".bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = FALSE, by_rg = FALSE, format = "bam")
#   ENCODE_ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   ENCODE_ATAC_inPeakData = rbind(ENCODE_ATAC_inPeakData, data.frame(Sample = sample, ENCODE_ATAC_inPeakN = ENCODE_ATAC_inPeakN))
# }
# 
# ENCODE_total_frags = c(9770603, 12064137)
# ENCODE_ATAC_inPeakData$UniqueFragNum = ENCODE_total_frags
# ENCODE_ATAC_inPeakData$Percentage = ENCODE_ATAC_inPeakData$ENCODE_ATAC_inPeakN / ENCODE_ATAC_inPeakData$UniqueFragNum * 100
# 
# ENCODE_ATAC_inPeakData
```

```{r, echo=FALSE, eval=TRUE, fig.height=5, fig.width=6, message=FALSE, warning=FALSE}
# ENCODE_sampleList = c("H3K27ac_ENCFF384ZZM", "H3K27me3_ENCFF676ORH")
# ENCODE_in_ATAC = c(271145, 400642)
# ENCODE_total_frags = c(9770603, 12064137)
# 
# ENCODE_ATAC_inPeakData = data.frame(Sample = ENCODE_sampleList, UniqueFragNum = ENCODE_total_frags, ATAC_inPeakN = ENCODE_in_ATAC)
# ENCODE_ATAC_inPeakData$Percentage = ENCODE_ATAC_inPeakData$ATAC_inPeakN / ENCODE_ATAC_inPeakData$UniqueFragNum * 100
# 
# ENCODE_ATAC_inPeakData
```



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# 
# # Merge with sample unique fragment counts in relevant samples
# Nreplicate=2 # Nreplicate=3 for set="allsamples"; Nreplicate=2 for set="newsamples"
# sampleList_rep <- c(rep("ab177",Nreplicate),rep("ab4729",Nreplicate), rep("ab9733",Nreplicate),rep("diag",Nreplicate), 
#                     rep("H3K27ac_KO",Nreplicate), rep("H3K27me3_KO",Nreplicate))
# sampleName <- c("Abcam-ab177178_r1","Abcam-ab177178_r2","Abcam-ab4729_r1",
#                  "Abcam-ab4729_r2","H3K27me3_r1","H3K27me3_r2","Diagenode_50x_r1",
#                  "Diagenode_50x_r2","H3K27ac_SRR8383507","H3K27ac_SRR8383508","H3K27me3_SRR11074238","H3K27me3_SRR11074239")
# samplenameDF<-data.frame(ShortName=sampleList_rep, Sample=sampleName)
# group_dupResult <- dupResult[c("Sample", "UniqueFragNum")] %>% left_join(samplenameDF, by="Sample") %>% na.omit()
# sum_dupResult <- group_dupResult %>% group_by(ShortName) %>% summarise(UniqueFragNum=sum(UniqueFragNum))
# colnames(sum_dupResult)[1]<-"Sample"
# 
# peakData = sum_dupResult %>% left_join(Total_ENCODE_inPeakData, by = "Sample") %>% left_join(ENCODE_inPeakData, by = "Sample") %>% left_join(Total_ATAC_inPeakData, by = "Sample") %>% left_join(ATAC_inPeakData, by = "Sample")  %>% left_join(ENCODE_and_ATAC_inPeakData, by = "Sample")
# 
# peakData$Percentage_ATAC = peakData$Total_ATAC_inPeakN / peakData$UniqueFragNum * 100
# peakData$Percentage_ENCODE = peakData$Total_ENCODE_inPeakN / peakData$UniqueFragNum * 100
# peakData$Percentage_ATAC_only = peakData$ATAC_inPeakN / peakData$UniqueFragNum * 100
# peakData$Percentage_ENCODE_only = peakData$ENCODE_inPeakN / peakData$UniqueFragNum * 100
# peakData$Percentage_ATAC_ENCODE = peakData$ENCODE_and_ATAC_inPeakN / peakData$UniqueFragNum * 100
# 
# peakData = peakData %>% dplyr::select(Sample, UniqueFragNum, Total_ENCODE_inPeakN, ENCODE_inPeakN, Total_ATAC_inPeakN, ATAC_inPeakN, Percentage_ENCODE, Percentage_ENCODE_only, Percentage_ATAC, Percentage_ATAC_only, Percentage_ATAC_ENCODE)
# 
# colnames(peakData) = c("Sample", "Unique Fragments", "Fragments in ENCODE H3K27ac peaks", "Fragments in ENCODE H3K27ac peaks (exc ATAC)", "Fragments in ATAC peaks", "Fragments in ATAC peaks (exc ENCODE)", "% of fragments in ENCODE H3K27ac (total)", "% of fragments in ENCODE H3K27ac (exc. ATAC)", "% of fragments in ATAC (total)", "% of fragments in ATAC (exc. ENCODE)", "% of fragments in ENCODE / ATAC overlapping regions")
# peakData
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=7, fig.height=3.5}
# ATAC_peakData = peakData[c("Sample", "% of fragments in ENCODE H3K27ac (total)", "% of fragments in ATAC (total)", "% of fragments in ENCODE / ATAC overlapping regions", "% of fragments in ENCODE H3K27ac (exc. ATAC)", "% of fragments in ATAC (exc. ENCODE)")]
# 
# labelDF <- data.frame(Sample=c("ab177","ab4729","ab9733","diag","H3K27ac_KO","H3K27me3_KO"),
#                       SampleLabel=c("H3K27ac\nAbcam-ab177178","H3K27ac\nAbcam-ab4729","H3K27me3\nAbcam-ab9733","H3K27ac\nDiagenode_50x",
#                                     "H3K27ac\nKaya_Okur","H3K27me3\nKaya_Okur"))
# 
# ATAC_peakData <- merge(ATAC_peakData, labelDF,by="Sample")
# ATAC_peakData <- ATAC_peakData[-1]
# ATAC_peakData_melt = melt(ATAC_peakData, id.vars = c("SampleLabel"))
# 
# ENCODE_ATAC_plot = ggplot(ATAC_peakData_melt, aes(SampleLabel, value)) +
#   geom_bar(aes(fill = variable), width = 0.5, position = position_dodge(width = 0.6), stat = "identity", colour = "black") +
#   scale_fill_viridis(discrete = TRUE, begin = 0.1, end = 0.85, option = "rocket", alpha = 0.9) +
#   ylim(0, 100) +
#   theme_bw(base_size = 20) +
#   ylab("% of fragments in peaks") +
#   xlab(NULL) +
#   ggtitle("Fragments in ENCODE H3K27ac ChIP-seq and ATAC-seq peaks") +
#   ggpubr::rotate_x_text(angle = 45) +
#   theme(axis.text = element_text(size = 18)) +
#   theme(axis.title = element_text(size = 18)) +
#   theme(plot.title = element_text(size = 22, face="bold")) +
#   theme(legend.text = element_text(size = 18)) +
#   theme(legend.title = element_blank()) +
#   theme(legend.position = "bottom") +
#   theme(legend.key.height = unit(0.7, "cm")) +
#   guides(fill = guide_legend(nrow = 3))
# 
# ENCODE_ATAC_plot
```


### Summary (Main figure)
``` {r, fig.width=19, fig.height=6.5, warning=FALSE}
Total_ENCODE_inPeakData = read.csv(paste0(workdir,"/alignment/frip/Total_ENCODE_inPeakData.csv"), row.names = 1)
Total_ATAC_inPeakData = read.csv(paste0(workdir,"/alignment/frip/Total_ATAC_inPeakData.csv"), row.names = 1)
ATAC_inPeakData = read.csv(paste0(workdir,"/alignment/frip/ATAC_inPeakData.csv"), row.names = 1)
ENCODE_inPeakData = read.csv(paste0(workdir,"/alignment/frip/ENCODE_inPeakData.csv"), row.names = 1)
ENCODE_and_ATAC_inPeakData = read.csv(paste0(workdir,"/alignment/frip/ENCODE_and_ATAC_inPeakData.csv"), row.names = 1)

# Combine all fragment count categories
peakData = Total_ENCODE_inPeakData %>% 
  left_join(ENCODE_inPeakData, by = "Sample") %>% 
  left_join(Total_ATAC_inPeakData, by = "Sample") %>% 
  left_join(ATAC_inPeakData, by = "Sample") %>% 
  left_join(ENCODE_and_ATAC_inPeakData, by = "Sample")

# Make data frame longer
peakData_l = pivot_longer(peakData, cols=c(2:ncol(peakData)), names_to="group", values_to="count")

# Merge with sample fragment counts
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27ac_SRR8383507"] = "SRR8383507"
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27ac_SRR8383508"] = "SRR8383508"
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27me3_SRR11074238"] = "SRR11074238"
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27me3_SRR11074239"] = "SRR11074239"
peakData_l = merge(peakData_l, alignDupSummary, by="Sample", all=FALSE)

# Calculate proportion of total fragment counts
peakData_l$frip = (peakData_l$count / peakData_l$UniqueFragNum) * 100

org_peakData_l = peakData_l

# plot for main figure
peakData_l$group <- factor(peakData_l$group, levels = c("Total_ENCODE_inPeakN","Total_ATAC_inPeakN", 
                                                        "ENCODE_and_ATAC_inPeak", 
                                                        "ENCODE_inPeakN", "ATAC_inPeakN" ), 
                           labels = c("All ENCODE H3K27ac", "All ATAC", 
                                      "ENCODE H3K27ac -\n ATAC Overlap", 
                                      "ENCODE H3K27ac\nexc. ATAC", "ATAC exc. \nENCODE H3K27ac"))
peakData_l

ggplot(peakData_l, aes(SampleLabel, frip)) +
  geom_bar(aes(fill = "#7d3366"), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.7, colour="black") +
  theme_light(base_size = 25) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  ylim(0, 100) +
  ylab("% of fragments in peaks") +
  xlab("") +
  ggtitle("CUT&Tag fragments in ENCODE H3K27ac and ATAC peaks") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25)) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "none") +
  theme(
      strip.background=element_rect(colour="grey40",fill="grey80"),
      strip.text = element_text(colour = 'black')) +
  scale_fill_manual(values = c("#7d3366")) +
  facet_wrap(~group, scales="free_x", ncol=5, strip.position = "top") + coord_flip()

# # save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_encode_atac_frip_score_facet.svg",
#         dpi = 1200, width = 19.5,
#         height = 7.0, units ="in")
```

#### H3K27me3 CT Frips in all ATAC and ENCODE H3K27ac overlap regions
```{r}
# view data for H3K27me3 CT reads in ATAC regions
peakData_l[peakData_l$group %in% c("All ATAC", "ENCODE H3K27ac -\n ATAC Overlap") & peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2","H3K27me3_SRR11074238","H3K27me3_SRR11074239"), c("Sample","group","count","DuplicationRate","UniqueFragNum","frip")]
```

#### Average H3K27me3 CT frip in all ATAC regions
```{r}
df = peakData_l[peakData_l$group %in% c("All ATAC") & peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2","H3K27me3_SRR11074238","H3K27me3_SRR11074239"), c("Sample","SampleLabel","Set","group","count","DuplicationRate","UniqueFragNum","frip")]

df %>% group_by(Set) %>% summarize(avg.frip=mean(frip), sd.frip=sd(frip))
```
#### Average H3K27ac CT frip in all ATAC regions
```{r}
df = peakData_l[peakData_l$group %in% c("All ATAC") & !(peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2","H3K27me3_SRR11074238","H3K27me3_SRR11074239")), c("Sample","SampleLabel","Set","group","count","DuplicationRate","UniqueFragNum","frip")]
df
df %>% group_by(Set) %>% summarize(avg.frip=mean(frip), sd.frip=sd(frip))
```

#### Average H3K27ac CT frip in overlap and non-overlap regions
```{r}
df = peakData_l[!(peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2","H3K27me3_SRR11074238","H3K27me3_SRR11074239")), c("Sample","SampleLabel","Set","group","count","DuplicationRate","UniqueFragNum","frip")]
df
df %>% dplyr::group_by(group) %>% dplyr::summarize(avg.frip=mean(frip), sd.frip=sd(frip))
```

### Summary Extended (Supplementary)
```{r}
# bampath="/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking/alignment/bam/"
# sampleList = sup_df$Sample[sup_df$Source == "Supplementary"] %>% unique
# dup_l = list("rmDup")
# peakRes_l = list(Total_ENCODE_inPeakN=ENCODE_H3K27ac, Total_ATAC_inPeakN=ATAC, ENCODE_and_ATAC_inPeak=ENCODE_and_ATAC, 
#                  ENCODE_inPeakN=ENCODE_not_ATAC, ATAC_inPeakN=ATAC_not_ENCODE)
# 
# fripdf = c()
# for (sample in sampleList) {
#     for (dup in dup_l) {
#       for (peaks in peakRes_l) {
#         
#         # define peak and bam file path
#         if (dup == "rmDup") { 
#           bamFile = paste0(bampath, sample, "_bowtie2_", dup, ".mapped.sorted.bam") }
#         print(bamFile)
#         
#         # count highdup / CnR fragments in these peaks
#         for (i in 1:length(peakRes_l)) {
#           peakRes = peakRes_l[[i]] %>% data.frame
#           name = names(peakRes_l)[[i]]
#           print(name)
#           peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#           fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#           count = counts(fragment_counts)[,1] %>% sum
#           fripdf = rbind(fripdf, data.frame(Sample = sample, group = name, count = count))
#       }
#       }
#     }
#   }

# write.csv(fripdf, paste0(workdir,"/alignment/frip/atac_inPeakData_supp.csv"))
fripdf = read.csv(paste0(workdir,"/alignment/frip/atac_inPeakData_supp.csv"), row.names=1)
fripdf_copy = fripdf
peakData_l = merge(fripdf_copy, alignDupSummary, by="Sample")

# Calculate proportion of total fragment counts
peakData_l$frip = (peakData_l$count / peakData_l$UniqueFragNum) * 100
peakData_l
```

``` {r, fig.width=20, fig.height=9}
# Add original samples
cols=intersect(colnames(peakData_l), colnames(org_peakData_l))
peakData_l <- rbind(peakData_l[cols],org_peakData_l[cols])

# Assign labels to peak set factor
peakData_l$group <- factor(peakData_l$group, levels = c("Total_ENCODE_inPeakN","Total_ATAC_inPeakN", 
                                                        "ENCODE_and_ATAC_inPeak", 
                                                        "ENCODE_inPeakN", "ATAC_inPeakN" ), 
                           labels = c("All ENCODE H3K27ac", "All ATAC", 
                                      "ENCODE H3K27ac -\n ATAC Overlap", 
                                      "ENCODE H3K27ac\nexc. ATAC", "ATAC exc. \nENCODE H3K27ac"))

# Edit sample labels
plotdf = peakData_l %>% unique
plotdf$SampleLabel[plotdf$SampleLabel == "ActiveMotif"] <- "H3K27ac-ActiveMotif-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Abcam-ab4729"] <- "H3K27ac-ab4729-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Abcam-ab177178"] <- "H3K27ac-ab177-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Diagenode_100x"] <- "H3K27ac-Diag100x-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "Diagenode_50x"] <- "H3K27ac-Diag50x-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27ac_SRR8581604_CnR"] <- "H3K27ac-Meers-CnR"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3"] <- "H3K27me3-ab9733-HDup"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3_SRR9073702_CnR"] <- "H3K27me3-Meers-CnR"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27ac_SRR8383507"] <- "H3K27ac-Kaya-Okur-1"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27ac_SRR8383508"] <- "H3K27ac-Kaya-Okur-2"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3_SRR11074238"] <- "H3K27me3-Kaya-Okur-1"
plotdf$SampleLabel[plotdf$SampleLabel == "H3K27me3_SRR11074239"] <- "H3K27me3-Kaya-Okur-2"

# Plot
ggplot(plotdf, aes(SampleLabel, frip)) +
  geom_bar(aes(fill = "#7d3366"), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.7, colour="black") +
  theme_light(base_size = 25) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  ylim(0, 100) +
  ylab("% of fragments in peaks") +
  xlab("") +
  ggtitle("CUT&Tag fragments in ENCODE H3K27ac and ATAC peaks") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "none") +
  theme(
      strip.background=element_rect(colour="grey40",fill="grey80"),
      strip.text = element_text(colour = 'black')) +
  scale_fill_manual(values = c("#7d3366")) +
  facet_wrap(~group, scales="free_x", ncol=5, strip.position = "top") + coord_flip()

# save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_encode_atac_frip_score_facet.svg",
#         dpi = 1200, width = 19.5,
#         height = 9.0, units ="in")
```

### Remove short frags
Fragments under 100 bp in lengths were removed and FRiP scores in ATAC were quantified. 

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# remove fragments < 100bp, and recalculate in ATAC or overlap peaks

# # set peak regions of interest
# peakRes = data.frame(ATAC)
# 
# # Count reads from in-house CUT&Tag dataset
# dir="/Volumes/pu1918/projects/mrc_bdr/ephemeral/cutandtag"
# Total_ATAC_inPeakData = c()
# for(sample in sampleList){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   bamFile = paste0(dir, "/alignment/bam/len100/", sample, "_", dup, "_bowtie2.mapped.sorted.len100.bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ATAC_inPeakData = rbind(Total_ATAC_inPeakData, data.frame(Sample = sample, Total_ATAC_inPeakN = Total_ATAC_inPeakN))
# }

# # Count reads from Kaya Okur CUT&Tag dataset
# ## H3K27ac
# Total_ATAC_inPeakData_KO_ac = c()
# for(sample in sampleList_KO_ac){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27ac_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ATAC_inPeakData_KO_ac = rbind(Total_ATAC_inPeakData_KO_ac, data.frame(Sample = sample, Total_ATAC_inPeakN = Total_ATAC_inPeakN))
# }
# ## H3K27me3
# Total_ATAC_inPeakData_KO_me = c()
# for(sample in sampleList_KO_me){
#   peak.gr = GenomicRanges::GRanges(seqnames = peakRes$seqnames, IRanges(start = peakRes$start, end = peakRes$end), strand = "*")
#   if (dup == "rmDup") {
#     bamFile = paste0(datadir, dup, "/H3K27me3_", sample, "_bowtie2_rmDup.mapped.sorted.bam")
#   }
#   fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#   Total_ATAC_inPeakN = counts(fragment_counts)[,1] %>% sum
#   Total_ATAC_inPeakData_KO_me = rbind(Total_ATAC_inPeakData_KO_me, data.frame(Sample = sample, Total_ATAC_inPeakN = Total_ATAC_inPeakN))
# }
# 
# Total_ATAC_inPeakData <- rbind(Total_ATAC_inPeakData, Total_ATAC_inPeakData_KO_ac) %>% rbind(., Total_ATAC_inPeakData_KO_me)
# Total_ATAC_inPeakData

# write.csv(Total_ATAC_inPeakData, paste0(workdir,"/alignment/frip/Total_ATAC_inPeakData_len100.csv"))
```

```{r}
# read in data
Total_ATAC_inPeakData=read.csv(paste0(workdir,"/alignment/frip/Total_ATAC_inPeakData_len100.csv"),row.names=1)
# Combine all fragment count categories
peakData = Total_ATAC_inPeakData
# Make data frame longer
peakData_l = pivot_longer(peakData, cols=c(2:ncol(peakData)), names_to="group", values_to="count")
# Merge with sample fragment counts
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27ac_SRR8383507"] = "SRR8383507"
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27ac_SRR8383508"] = "SRR8383508"
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27me3_SRR11074238"] = "SRR11074238"
alignDupSummary$Sample[alignDupSummary$SampleLabel == "H3K27me3_SRR11074239"] = "SRR11074239"
peakData_l = merge(peakData_l, alignDupSummary, by="Sample", all=FALSE)
# Calculate proportion of total fragment counts
peakData_l$frip = (peakData_l$count / peakData_l$UniqueFragNum) * 100
# display data 
peakData_l[c("Sample","group","SampleLabel","UniqueFragNum","frip","Set")]
```

##### H3K27me3 fragments in ATAC peaks (%) after removing short fragments
```{r}
# calculate H3K27me3 ATAC peak frips after removing short fragments
peakData_l[peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2"),c("frip")] %>% mean() -> m
peakData_l[peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2"),c("frip")] %>% sd() -> s
print(paste0("Mean: ",m))
print(paste0("Standard deviation: ",s))
```
##### H3K27ac fragments in ATAC peaks (%) after removing short fragments
```{r}
# calculate H3K27ac ATAC peak frips after remving short fragments
peakData_l[!(peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2")),c("frip")] %>% mean() -> m
peakData_l[!(peakData_l$SampleLabel %in% c("H3K27me3-ab9733-1","H3K27me3-ab9733-2")),c("frip")] %>% sd() -> s
print(paste0("Mean: ",m))
print(paste0("Standard deviation: ",s))
```

### ENCODE peaks in / not in ATAC
Comparing significance log(q-value) of ENCODE ChIP peaks in or not in ATAC peaks.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}
peakdir ="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ATAC/peaks"
ATAC_path = file.path(peakdir, "K562_ATACseq.mRp.clN_peaks.narrowPeak")
ATAC = ChIPseeker::readPeakFile(ATAC_path, as = "GRanges")

encode_peaks_in_atac = IRanges::subsetByOverlaps(ENCODE_H3K27ac, ATAC)
encode_peaks_in_atac = encode_peaks_in_atac %>% as.data.frame()
qval_in_atac = encode_peaks_in_atac$V9

encode_peaks_not_in_atac = IRanges::subsetByOverlaps(ENCODE_H3K27ac, ATAC, invert = TRUE)
encode_peaks_not_in_atac = encode_peaks_not_in_atac %>% as.data.frame()
qval_not_in_atac = encode_peaks_not_in_atac$V9
```

#### qval_in_atac
```{r}
qval_in_atac %>% summary()
```
#### qval_not_in_atac
```{r}
qval_not_in_atac %>% summary()
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}
boxplot(qval_in_atac, qval_not_in_atac, outline = FALSE, names = c("ENCODE peaks in ATAC", "ENCODE peaks not in ATAC"), 
        ylab = "log(q value)")
```



# CUT&Tag vs ENCODE H3K27ac / H3K27me3 peak overlap across thresholds
Recall: % of CUT&Tag peaks in ENCODE peaks (number of ENCODE peaks recalled by CT --- encode | CT / encode)

Precision: % of ENCODE peaks captured in CUT&Tag peaks (number of CT peaks found in encode --- CT | encode / CT)

```{r}
# load ENCODE ChIP peaks
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")
```

### At select thresholds
```{r}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
ext_df = ext_df[ext_df$Source != "Supplementary",]
## H3K27ac 
h3k27ac_setNames = ext_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = ext_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(peakList, ext_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]

# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}

# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3") )

# add peak set information
encodeOL = merge(encodeOL, ext_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- encodeOL$ol.CTPeakCount / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", encodeOL$ol.ENCODEPeakCount / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", encodeOL$ol.ENCODEPeakCount / encode_ME, NA))
encodeOL
org_encodeOL = encodeOL
```

### All thresholds
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
temp_dir="/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking/ephemeral"

h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="individual" # opts: allsample, newsample, individual
callerdir=c("SEACR","MACS2")
dupList = c("rmDup","withDup")
threshold_list = list(SEACR = c("0.01", "0.03", "0.05", "0.1"), 
                      MACS2 = c("1e-5", "0.001", "0.01", "0.1"))
                                # 0.000001,"1"))

THD_blacklist_counts = c()
THD_peakList = list()
THD_peakList_unfilt = list()
THD_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {

    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
    
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
          
        # check
        # print(paste0(temp_dir,"/peakCalling/",caller,"/",sample,"_",dup,"_", suffix))
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(paste0(temp_dir,"/peakCalling/",caller,"/",
                                                      sample,"_",dup,"_", suffix), as = "GRanges")
       
        # store all peaks in a list
        THD_peakList_unfilt = c(THD_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        THD_blacklist_counts = c(THD_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        THD_peakList = c(THD_peakList, peak_filt)
        # store peak calling information
        THD_callInfo = c(THD_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(THD_peakList) = THD_callInfo
names(THD_peakList_unfilt) = THD_callInfo
names(THD_blacklist_counts) = THD_callInfo
```

## Peak counts
```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(THD_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(THD_peakList[[i]])) }
names(Total_CT_peaks) <- THD_callInfo
data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=15}
# split peak set information and plot bar plot
thd_df=data.frame(Total_CT_peaks)
thd_df$PeakSet = rownames(thd_df)
thd_df$EpMark <- str_split_fixed(thd_df$PeakSet, "_", n=4)[,1]
thd_df$Sample <- str_split_fixed(thd_df$PeakSet, "_", n=5)[,2]
thd_df$Caller <- str_split_fixed(thd_df$PeakSet, "_", n=5)[,3]
thd_df$Dup <- str_split_fixed(thd_df$PeakSet, "_", n=5)[,4]
thd_df$Threshold <- str_split_fixed(thd_df$PeakSet, "_", n=5)[,5]
# thd_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
thd_df <- merge(thd_df, alignDupSummary, by="Sample")

# Calculate scaling factor and insert into data frame
N = ddply(thd_df, .(Caller, SampleLabel), function(x) length(row.names(x)))
N$Fac = N$V1 / max(N$V1)
thd_df = merge(thd_df, N[,-3], by = c("Caller", "SampleLabel"))

options(scipen=999)
thd_df$Threshold <- thd_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(thd_df, aes(Threshold, Total_CT_peaks, fill=Dup, width = 0.9*Fac)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, 200000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Peak widths 
### with and without duplicates {.tabset}
#### H3K27ac
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=30, fig.height=15, fig.show="hold"}
# repeat for each sample peak set separately
info = thd_df # df = only in-house datasets; ext_df = both internal and external
peakTest = c(THD_peakList) # peakList = only in-house datasets; ext_peakList = only external datasets

### Loop over all peak sets 
peakWidths = c()
for (i in 1:length(peakTest)) {
  peaks = peakTest[[i]]
  # name = names(peakTest)[i]
  widths = unlist(as(peaks, "GRangesList")) %>% GenomicRanges::width()
  peakWidths = c(peakWidths, list(widths))
}
names(peakWidths) <- names(peakTest)

# plot boxplot for peak widths
options(scipen=999) # prevent scientific notation

# H3K27ac
peaksets <- info$PeakSet[info$EpMark == "H3K27ac"]
features <- peakWidths[peaksets]
par(mar=c(20,5,5,5))
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        ylab = "Width (bp)", 
        main = "H3K27ac peak widths", 
        log = "y", 
        ylim = c(1, max(unlist(features))),
        las=2,
        cex.names=0.5)

# ## save
# # Open a pdf file
# pdf(paste0(workdir,"/peakCalling/boxplot_peak_width_h3k27ac.pdf"), width = 15, height = 10)
# par(mar=c(18,5,5,5))
# boxplot(features,
#         outline = TRUE,
#         names = names(features),
#         ylab = "Width (bp)",
#         main = "H3K27ac peak widths",
#         log = "y",
#         ylim = c(1, max(unlist(features))),
#         las=2,
#         cex.names=0.2)
# # Close the pdf file
# dev.off()

# Pull all median values
# lapply(features, function(x){ median(x) } ) 
```

#### H3K27me3
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=30, fig.height=15, fig.show="hold"}
# H3K27me3
peaksets <- info$PeakSet[info$EpMark == "H3K27me3"]
features <- peakWidths[peaksets]
par(mar=c(22,5,5,5))
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        ylab = "Width (bp)", 
        main = "H3K27me3 peak widths", 
        log = "y", 
        ylim = c(1, max(unlist(features))),
        las=2,
        cex.names=0.2)

# ## save ##
# # Open a svg file
# svg(paste0(workdir,"/peakCalling/boxplot_peak_width_h3k27me3.svg"), width = 12, height = 10)
# par(mar=c(20,5,5,5))
# boxplot(features,
#         outline = TRUE,
#         names = names(features),
#         ylab = "Width (bp)",
#         main = "H3K27me3 peak widths",
#         log = "y",
#         ylim = c(1, max(unlist(features))),
#         las=2,
#         cex.names=0.2)
# # Close the svg file
# dev.off()

# Pull all median values
# lapply(features, function(x){ median(x) } ) 
```

### without duplicates {.tabset}
#### H3K27ac
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=22, fig.show="hold"}
# define test peak set
info = thd_df # df = only in-house datasets; ext_df = both internal and external
peakTest = c(THD_peakList) # peakList = only in-house datasets; ext_peakList = only external datasets

# remove peaks called with duplicates. this is to be tested in a separate plot.
sel=grep("withDup", info$PeakSet, value=TRUE)
info = info[!(info$PeakSet %in% sel),]
peakTest = peakTest[names(peakTest) %in% info$PeakSet]

### Loop over all peak sets 
peakWidths = c()
for (i in 1:length(peakTest)) {
  peaks = peakTest[[i]]
  # name = names(peakTest)[i]
  widths = unlist(as(peaks, "GRangesList")) %>% GenomicRanges::width()
  peakWidths = c(peakWidths, list(widths))
}
names(peakWidths) <- names(peakTest)


# rename peakWidths list using matching plotlab values in info DF
info$plotlab <- paste0(info$SampleLabel, " ", info$Caller, " ", info$Threshold)
info <- arrange(info, Caller, SampleLabel, Threshold)
renamed_list <- info$plotlab[match( names(peakWidths), info$PeakSet)]
renamed_list <- ifelse(is.na(renamed_list), names(peakWidths), renamed_list)
names(peakWidths) <- renamed_list


# Add ENCODE peaks
peakTest = list(ENCODE_H3K27ac, ENCODE_H3K27me3)
for (i in 1:length(peakTest)) {
 peaks = peakTest[[i]]
  # name = names(peakTest)[i]
  widths = unlist(as(peaks, "GRangesList")) %>% GenomicRanges::width()
  peakWidths = c(peakWidths, list(widths))
}
names(peakWidths)[65] <- c("ENCODE H3K27ac")
names(peakWidths)[66] <- c("ENCODE H3K27me3")

# select h3k27ac
features1 <- peakWidths["ENCODE H3K27ac"]
peaksets2 <- info$plotlab[info$EpMark == "H3K27ac"]
features2 <- peakWidths[peaksets2]
features <- c(features1,features2)
names(features) <- c("ENCODE H3K27ac",peaksets2)

# plot boxplot for peak widths
options(scipen=999) # prevent scientific notation

# H3K27ac boxplots
par(mar=c(10,25,8,5))
par(cex.lab=1.5) # is for y-axis
par(cex.axis=1.5) # is for x-axis
par(cex.main=1.5) # is for x-axis
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        xlab = "logscale width (bp)", 
        main = "H3K27ac by peak caller and threshold", 
        log = "x", 
        ylim = c(50, max(unlist(features))),
        las=2,
        cex.names=0.2,
        horizontal=T)

# ## save
# # Open a svg file
# svg(paste0(workdir,"/peakCalling/boxplot_peak_width_h3k27ac.svg"), width = 12, height = 23)
# par(mar=c(10,25,8,5))
# par(cex.lab=1.5) # is for y-axis
# par(cex.axis=1.5) # is for x-axis
# par(cex.main=1.5) # is for x-axis
# boxplot(features,
#         outline = TRUE, 
#         names = names(features), 
#         xlab = "logscale width (bp)", 
#         main = "H3K27ac by peak caller and threshold", 
#         log = "x", 
#         ylim = c(50, max(unlist(features))),
#         las=2,
#         cex.names=0.2,
#         horizontal=T)
# # Close the svg file
# dev.off()
```


#### H3K27me3
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=22, fig.show="hold"}
# select h3k27me3
features1 <- peakWidths["ENCODE H3K27me3"]
peaksets2 <- info$plotlab[info$EpMark == "H3K27me3"]
features2 <- peakWidths[peaksets2]
features <- c(features1,features2)
names(features) <- c("ENCODE H3K27me3",peaksets2)

# plot boxplot for peak widths
options(scipen=999) # prevent scientific notation

# H3K27me3 boxplots
par(mar=c(10,25,8,5))
par(cex.lab=1.5) # is for y-axis
par(cex.axis=1.5) # is for x-axis
par(cex.main=1.5) # is for x-axis
boxplot(features,
        outline = TRUE, 
        names = names(features), 
        xlab = "logscale width (bp)", 
        main = "H3K27me3 by peak caller and threshold", 
        log = "x", 
        ylim = c(10, max(unlist(features))),
        las=2,
        cex.names=0.2,
        horizontal=T)

# ## save
# # Open a svg file
# svg(paste0(workdir,"/peakCalling/boxplot_peak_width_h3k27me3.svg"), width = 12, height = 18)
# par(mar=c(10,25,8,5))
# par(cex.lab=1.5) # is for y-axis
# par(cex.axis=1.5) # is for x-axis
# par(cex.main=1.5) # is for x-axis
# boxplot(features,
#         outline = TRUE, 
#         names = names(features), 
#         xlab = "logscale width (bp)", 
#         main = "H3K27me3 by peak caller and threshold", 
#         log = "x", 
#         ylim = c(10, max(unlist(features))),
#         las=2,
#         cex.names=0.2,
#         horizontal=T)
# # Close the svg file
# dev.off()
```

#### combined
```{r, fig.width=13, fig.height=20, warning=FALSE}
# stack numbers into dataframe 
df <- stack(peakWidths)
# Rename the columns for clarity
names(df) <- c("Width", "PeakSet")
df$threshold = str_extract(df$PeakSet, "[0-9.]{1,7}$")
df$caller = str_extract(df$PeakSet, "MACS2|SEACR")
df$epmark = str_extract(df$PeakSet, "H3K27ac|H3K27me3")
df$sample = str_replace_all(df$PeakSet, " MACS2| SEACR| [0-9.]{1,7}$| withDup|H3K27ac-|H3K27me3-", "")
df$samplelabel = str_replace_all(df$PeakSet, "H3K27ac-|H3K27me3-", "")
df$samplelabel[df$samplelabel == "ENCODE_H3K27ac"] <- "ENCODE H3K27ac"
df$samplelabel[df$samplelabel == "ENCODE_H3K27me3"] <- "ENCODE H3K27me3"

df$caller[df$samplelabel %in% c("ENCODE H3K27ac","ENCODE H3K27me3")] <- "ENCODE"
df$threshold[df$caller == "ENCODE"] <- NA

df = df[order(df[,4], df[,3]), ]
# df$samplelabel <- factor(df$samplelabel, levels=unique(df$samplelabel))
df$caller <- factor(df$caller, levels=c("ENCODE","MACS2","SEACR"))

# add colour
df$colour <- NA
df$colour[df$samplelabel == "ENCODE H3K27ac"] <- "grey30"
df$colour[df$samplelabel == "ENCODE H3K27me3"] <- "grey40"
df$colour[df$caller == "SEACR" & df$threshold == "0.01"] <- "purple1"
df$colour[df$caller == "SEACR" & df$threshold == "0.03"] <- "purple2"
df$colour[df$caller == "SEACR" & df$threshold == "0.05"] <- "purple3"
df$colour[df$caller == "SEACR" & df$threshold == "0.1"] <- "purple4"
df$colour[df$caller == "MACS2" & df$threshold == "0.00001"] <- "red1"
df$colour[df$caller == "MACS2" & df$threshold == "0.001"] <- "red2"
df$colour[df$caller == "MACS2" & df$threshold == "0.01"] <- "red3"
df$colour[df$caller == "MACS2" & df$threshold == "0.1"] <- "red4"

# rename
df$label[df$caller != "ENCODE"] <- paste0(df$sample[df$caller != "ENCODE"], " (", df$caller[df$caller != "ENCODE"],")")
df$label[df$caller == "ENCODE"] <- df$samplelabel[df$caller == "ENCODE"] 
df$label <- factor(df$label, levels=unique(df$label))

# plot
ggplot(df, aes(x=log(Width), y=label, fill=colour)) + 
  geom_boxplot(alpha=0.9) +
  facet_grid(rows=c("epmark"), scales="free", space="free_y") +
  ylab("") +
  xlab("log width (bp)") +
  theme_bw(base_size=25) +
  scale_fill_manual(values=c(grey30="grey30", grey40="grey40",purple1="purple1",purple2="purple2",purple3="purple3",purple4="purple4",
                             red1="red1", red2="red2", red3="red3", red4="red4"), 
                    labels=c(grey30="ENCODE H3K27ac", grey40="ENCODE H3K27me3",
                             purple1="SEACR 0.01", purple2="SEACR 0.03", purple3="SEACR 0.05", purple4="SEACR 0.1",
                             red1="MACS2 0.00001",red2="MACS2 0.001", red3="MACS2 0.01", red4="MACS2 0.1"),
                    breaks=c("grey30","grey40", "red1","red2","red3","red4","purple1","purple2","purple3","purple4"),
                    name="Key") +
  theme(legend.position = "top",
        legend.key.size = unit(1, 'cm'),
        legend.key.height = unit(0.5, 'cm'),
        legend.text = element_text(size=20)) + 
  guides(fill=guide_legend(nrow=4,byrow=TRUE))

# # save plot (svg)
# ggsave(path = paste0(workdir,"/peakCalling"),
#         filename = paste0("peakWidths_thresholds.svg"),
#         dpi = 1200, width = 9.0,
#         height = 15.0, units ="in")
```

## FRiP scores
Fragments in Peaks
```{r}
# # load ENCODE ChIP peaks
# datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
# ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
# ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")

# peakTest <- c(THD_peakList, list(ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3))
# insample <- unique(thd_df$Sample)
# exsample <- NULL
# sampleList <- c(insample, exsample)
# 
# ac_sample = unique(thd_df$Sample[thd_df$EpMark == "H3K27ac"])
# me_sample = unique(thd_df$Sample[thd_df$EpMark == "H3K27me3"])
#   
# dupList = c("rmDup", "withDup")
# callerList = c("MACS2", "SEACR")
# encodelist = c("ENCODE_H3K27ac", "ENCODE_H3K27me3")
# threshold_list = list(SEACR = c("0.01", "0.03", "0.05", "0.1"), MACS2 = c("0.000001","1e-5", "0.001", "0.01", "0.1"))
# 
# 
# peaksetNames <- thd_df$PeakSet %>% unique
# 
# inPeakData_df = c()
# for (sample in sampleList) {
#   
#   if (sample %in% ac_sample) {epmark = "H3K27ac"}
#   if (sample %in% me_sample) {epmark = "H3K27me3"}
#   
#   for (dup in dupList) {
# 
#   ## define bam file path
#     # in house dataset
#      if (sample %in% insample) { 
#        bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam") } 
#     # external dataset, previously analysed
#      if (sample %in% exsample) { 
#        if (dup == "rmDup") {
#          bamFile = paste0(storedir, "/bam/",dup,"/",sample,"_bowtie2_",dup,".mapped.sorted.bam") }
#        if (dup == "withDup") {
#          bamFile = paste0(storedir, "/bam/",dup,"/",sample,"_",dup,"_bowtie2.mapped.bam") }
#      }
#       
#       for (caller in callerList) {
#         
#         ## define threshold list for relevant peak caller
#         thresholdList = threshold_list[[caller]]
#         
#         for (threshold in thresholdList) {
#         
#           ## define peak set
#           set = paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold)
#           ## announce peak set counted against
#           print(paste0("For peak set ", set))
#           peak.gr = peakTest[[set]]
#           # peak.gr = GenomicRanges::GRanges(seqnames = peaks$seqnames, IRanges(start = peaks$start, end = peaks$end), strand = "*")
#           fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#           inPeakN = counts(fragment_counts)[,1] %>% sum
#           inPeakData_df = rbind(inPeakData_df, data.frame(bamSample = paste0(sample,"_",dup), PeakSet = set, inPeakN = inPeakN))
#           }
#       }
#     
#       for (encode in encodelist) {
#         ## define peak set
#         set = encode
#         ## announce peak set counted against
#         print(paste0("For peak set ", set))
#         peak.gr = peakTest[[set]]
#         fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#         inPeakN = counts(fragment_counts)[,1] %>% sum
#         inPeakData_df = rbind(inPeakData_df, data.frame(bamSample = paste0(sample,"_",dup), PeakSet = set, inPeakN = inPeakN))
#       }
#   } 
# }
# 
# # write.csv(inPeakData_df, paste0(workdir,"/alignment/frip/inpeak_fragment_thresholding_counts.csv"))

```

```{r, fig.width=35, fig.height=10, warning=FALSE}
inPeakData_df = read.csv( paste0(workdir,"/alignment/frip/inpeak_fragment_thresholding_counts.csv"))
## internal dataset; shorter name
data = inPeakData_df$bamSample[nchar(inPeakData_df$bamSample) < 18] %>% str_split_fixed("_",n=2) %>% data.frame() 
inPeakData_df$Dup[nchar(inPeakData_df$bamSample) < 18 ] <- data[,2]
inPeakData_df$Sample[nchar(inPeakData_df$bamSample) < 18 ] <- data[,1]

# add fragment count data
inPeakData_df <- merge(alignDupSummary, inPeakData_df, by="Sample")
# select the appropriate comparison fragment count
inPeakData_df$compareCount = ifelse(inPeakData_df$Dup == "rmDup", inPeakData_df$UniqueFragNum, inPeakData_df$MappedFragNum_hg19)
# calculate frip score
inPeakData_df$frip = inPeakData_df$inPeakN / inPeakData_df$compareCount * 100

### excluding bam-ENCODE CHIP region for this comparison
# add plotting groups -- group by sample SEACR/MACS2 peaks and ENCODE H3K27ac/H3K27me3
inPeakData_df$group <- NA
inPeakData_df$group[grep("SEACR",inPeakData_df$PeakSet)] <- "SEACR"
inPeakData_df$group[grep("MACS2",inPeakData_df$PeakSet)] <- "MACS2"
inPeakData_df$group[grep("ENCODE_H3K27ac",inPeakData_df$PeakSet)] <- "ENCODE_H3K27ac"
inPeakData_df$group[grep("ENCODE_H3K27me3",inPeakData_df$PeakSet)] <- "ENCODE_H3K27me3"
data=inPeakData_df[inPeakData_df$group %in% c("MACS2","SEACR"),]
data$Threshold <- str_split_fixed(data$PeakSet, "_", n=5)[,5] %>% as.numeric %>% as.factor

# construct plot
frip_plot = ggplot(data, aes(Threshold, frip, fill=Dup)) +
geom_bar(aes(fill = Dup), width = 0.7, position = position_dodge(width = 0.75), 
         stat = "identity",alpha = 0.6) +
  theme_light(base_size = 30) + 
  theme(plot.margin = unit(c(0.5,0.5,0.5,1), "cm")) +
  ylim(0, 100) +
  ylab("") +
  xlab("Threshold") +
  ggtitle("Proportion of CUT&Tag fragments in peaks") +
  theme(axis.text.x = element_text(
    # angle = 50, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 20)) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60")) +
   scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  facet_wrap(~group+SampleLabel, scale="free_x",ncol=8)

frip_plot

# # save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_thresholding_frip_score.pdf",
#         dpi = 1200, width = 35.0,
#         height = 15.0, units ="in",
#         plot=frip_plot)
```

## Precision-Recall with and without duplicates
```{r, warning=FALSE}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = thd_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = thd_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(THD_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3") )

# add peak set information
encodeOL = merge(encodeOL, thd_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- encodeOL$ol.CTPeakCount / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", encodeOL$ol.ENCODEPeakCount / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", encodeOL$ol.ENCODEPeakCount / encode_ME, NA))
encodeOL
```

```{r, fig.width=30, fig.height=9, warning=FALSE}
# plotdata = encodeOL
plotdata = encodeOL[encodeOL$Caller == "SEACR",]

ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, shape=Dup, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  theme_bw(base_size = 25) +
  ylim(0,1) + xlim(0,1) +
  ggtitle("Common CUT&Tag and ENCODE ChIP-seq peaks") +
  ylab("Proportion of all CT") +
  xlab("Proportion of all ENCODE ChIP") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  facet_wrap(Caller~EpMark+Dup, scale="free_x", ncol=4)

plotdata = encodeOL[encodeOL$Caller == "MACS2",]

ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, shape=Dup, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  theme_bw(base_size = 25) +
  ylim(0,1) + xlim(0,1) +
  ggtitle("Common CUT&Tag and ENCODE ChIP-seq peaks") +
  ylab("Proportion of all CT") +
  xlab("Proportion of all ENCODE ChIP") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  facet_wrap(Caller~EpMark+Dup, scale="free_x", ncol=4)

# get average metrics across antibodies at each threshold and peak caller
encodeOL = encodeOL %>% dplyr::group_by(EpMark, Caller, Dup, Threshold) %>% 
  dplyr::mutate(Avg.Precision=mean(OL.prop.of.CT), Avg.Recall=mean(OL.prop.of.ENCODE))

plotdata = encodeOL
# plotdata = encodeOL[encodeOL$Caller == "MACS2",] # MACS2 / SEACR

ggplot(plotdata, aes(x=Avg.Recall, y=Avg.Precision, colour=Caller, shape=Dup, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  # scale_size_discrete(range = c(2, 5), name = "Threshold") +
  theme_bw(base_size = 25) +
  # scale_colour_viridis(name = "Antibody", label = labs, 
  #                      discrete = TRUE, begin = 0.1, end = 0.85, 
  #                      option = "mako", alpha = 0.9) +
  ylim(0,1) + xlim(0,1) +
  ggtitle("Common CUT&Tag and ENCODE ChIP-seq peaks") +
  ylab("Avg.Precision") +
  xlab("Avg.Recall") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  facet_wrap(~EpMark+Dup, scale="free_x", ncol=4)


```

```{r, warning=FALSE}
# get average metrics across antibodies at each threshold and peak caller
encodeOL = encodeOL %>% dplyr::group_by(EpMark, Caller, Dup, Threshold) %>%
  dplyr::mutate(Avg.Precision=mean(OL.prop.of.CT), Avg.Recall=mean(OL.prop.of.ENCODE))

# convert proportion to percentage
encodeOL$OL.prop.of.ENCODE <- (encodeOL$OL.prop.of.ENCODE)*100
encodeOL$OL.prop.of.CT <- (encodeOL$OL.prop.of.CT)*100
```

## Precision-recall without duplicates {.tabset}
### H3K27ac + H3K27me3 (Supplementary) 

```{r, fig.width=10, fig.height=6, warning=FALSE}
callername="MACS2" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "q value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle(callername) +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm"))



callername="SEACR" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p2 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "Top.Prop") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle(callername) +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm"))

p1
p2
# 
# # save plot
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p1)
# callername="SEACR"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p2)
# 
# # save plot (svg)
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p1)
# callername="SEACR"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p2)
```

### H3K27ac (Main)
```{r, fig.width=10, fig.height=6, warning=FALSE}
### Also, specify EpMark
mark="H3K27ac"
callername="MACS2" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname & encodeOL$EpMark == mark,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "q value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle(callername) +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm"))

callername="SEACR" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname & encodeOL$EpMark == mark,] 

p2 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "Top.Prop") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle(callername) +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm"))

p1
p2

# # save plot
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p1)
# callername="SEACR"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p2)

# # save plot (svg)
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_H3K27ac_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p1)
# callername="SEACR"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_H3K27ac_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p2)
```

### F1 Scores
Calculate combined precision and recall metric for each peak set called without duplicates
F1 score = true positive / (true positive + 0.5*(false positive + true negative))

```{r, fig.width=9, fig.height=6}
plotdata = encodeOL
plotdata = plotdata[plotdata$Dup == "rmDup",]
# true positive / (true positive + 0.5*(false positive + true negative))
plotdata$f1score = plotdata$ol.CTPeakCount / (plotdata$ol.CTPeakCount + 0.5*(plotdata$ol.CTPeakCount + plotdata$ol.ENCODEPeakCount))
plotdata$Label <- paste0(plotdata$SampleLabel, "(",plotdata$Caller,")")

p1 <- ggplot(plotdata, aes(x=SampleLabel, y=f1score, fill=Caller)) +
  geom_bar(stat="identity", position=position_dodge2(width=0.9)) +
  theme_bw(base_size = 25) +
  scale_fill_viridis(name = "Peak Caller",
                       discrete = TRUE, begin = 0.65, end = 0.9,
                       option = "plasma", alpha = 0.85) +
  # ylim(0,100) + xlim(0,100) +
  ggtitle("") +
  ylab("F1 Score") +
  xlab("") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) + coord_flip()
p1

# save data in house samples
# write.csv(plotdata, paste0(workdir,"/encode_overlap/f1Scores/samples_all.csv"))
```

## MACS2 precision and recall
```{r}
# top MACS2 threshold precision and recall
mark="H3K27ac"      # H3K27ac / H3K27me3
callername="MACS2"  # MACS2 / SEACR
dupname="rmDup"
threshold = 0.00001
encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname & encodeOL$EpMark == mark & encodeOL$Threshold == threshold, c("SampleLabel","PeakSet","MappedFragNum_hg19","UniqueFragNum", "OL.prop.of.CT", "OL.prop.of.ENCODE")] 
```

## SEACR precision and recall
```{r}
# top SEACR threshold precision and recall
mark="H3K27ac"      # H3K27ac / H3K27me3
callername="SEACR"  # MACS2 / SEACR
dupname="rmDup"
threshold = 0.01
encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname & encodeOL$EpMark == mark & encodeOL$Threshold == threshold, c("SampleLabel","PeakSet","MappedFragNum_hg19","UniqueFragNum", "OL.prop.of.CT", "OL.prop.of.ENCODE")] 
```

## MACS2 precision and recall, H3K27me3, rmDup, threshold 0.00001
```{r}
# top MACS2 threshold precision and recall
mark="H3K27me3"      # H3K27ac / H3K27me3
callername="MACS2"  # MACS2 / SEACR
dupname="rmDup"
threshold = 0.00001
encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname & encodeOL$EpMark == mark & encodeOL$Threshold == threshold, c("SampleLabel","PeakSet","MappedFragNum_hg19","UniqueFragNum", "OL.prop.of.CT", "OL.prop.of.ENCODE")] 
```

## SEACR precision and recall, H3K27me3, rmDup, threshold 0.1
```{r}
# top SEACR threshold precision and recall
mark="H3K27me3"      # H3K27ac / H3K27me3
callername="SEACR"  # MACS2 / SEACR
dupname="rmDup"
threshold = 0.1
encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname & encodeOL$EpMark == mark & encodeOL$Threshold == threshold, c("SampleLabel","PeakSet","MappedFragNum_hg19","UniqueFragNum", "OL.prop.of.CT", "OL.prop.of.ENCODE")] 
```



## Precision and Recall at chosen parameters for MACS2 and SEACR, with and without duplicates {.tabset}

### View 1
```{r, fig.width=10, fig.height=8}
# select SEACR and MACS2 peak sets with chosen thresholds: 
# H3K27ac and H3K27me3 MACS2 = 1e-5
# H3K27ac and H3K27me3 SEACR = 0.01 and 0.1, respectively.
plotencodeOL <- rbind( encodeOL[encodeOL$Caller == "MACS2" & encodeOL$Threshold == "0.00001",] ,
                       encodeOL[encodeOL$Caller == "SEACR" & encodeOL$EpMark == "H3K27ac" & encodeOL$Threshold == "0.01",],
                       encodeOL[encodeOL$Caller == "SEACR" & encodeOL$EpMark == "H3K27me3" & encodeOL$Threshold == "0.1",])

colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.CT"]<- "Precision (% of CT)"
colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.ENCODE"] <- "Recall (% of ENCODE)"
encodeOL_restr <- pivot_longer(plotencodeOL, 
                               cols=c("Precision (% of CT)", "Recall (% of ENCODE)"),
                               names_to="OLType", values_to="Proportion")


encodeOL_restr$OLType_Caller <- paste0(encodeOL_restr$OLType, "\n", encodeOL_restr$Caller)

# Precision
plotdata = encodeOL_restr[encodeOL_restr$OLType == "Precision (% of CT)",]
ggplot(plotdata, aes(x=SampleLabel, y=Proportion, fill=c(Dup))) +
         geom_bar(stat = "identity", position = position_dodge(width = 0.75), 
                  width = 0.7, alpha = 0.9, colour="grey10") + 
         facet_grid(Dup ~ ., scales="free") +
  scale_fill_manual(name = ' ',
                    values = c("skyblue","steelblue")) +
  theme_bw(base_size = 20) +
  ylim(0,100) +
  labs(title="Precision (% of CT)", x=NULL, y="Proportion of Peaks") +
          # theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
          theme(legend.position = "bottom",
                 plot.title = element_text(face = "bold")) +
  facet_grid(EpMark~Caller, space="free", scales = "free_y") + coord_flip()

# # Save
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_barplot.svg"),
#         dpi = 1200, width = 10.0,
#         height = 7.5, units ="in")


# Recall
plotdata = encodeOL_restr[encodeOL_restr$OLType == "Recall (% of ENCODE)",]
ggplot(plotdata, aes(x=SampleLabel, y=Proportion, fill=c(Dup))) +
         geom_bar(stat = "identity", position = position_dodge(width = 0.75), 
                  width = 0.7, alpha = 0.9, colour="grey10") + 
         facet_grid(Dup ~ ., scales="free") +
  scale_fill_manual(name = ' ',
                    values = c( "#e1b1a2","#ed6851")) +
  theme_bw(base_size = 20) +
  ylim(0,100) +
  labs(title="Recall (% of ENCODE)", x=NULL, y="Proportion of Peaks") +
          # theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
          theme(legend.position = "bottom",
                 plot.title = element_text(face = "bold")) +
  facet_grid(EpMark~Caller, space="free", scales = "free_y") + coord_flip()

# # Save
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("recall_barplot.svg"),
#         dpi = 1200, width = 10.0,
#         height = 7.5, units ="in")
```

### View 2
```{r, fig.width=15, fig.height=8}
# select SEACR and MACS2 peak sets with chosen thresholds: 
# H3K27ac and H3K27me3 MACS2 = 1e-5
# H3K27ac and H3K27me3 SEACR = 0.01 and 0.1, respectively.
plotencodeOL <- rbind( encodeOL[encodeOL$Caller == "MACS2" & encodeOL$Threshold == "0.00001",] ,
                       encodeOL[encodeOL$Caller == "SEACR" & encodeOL$EpMark == "H3K27ac" & encodeOL$Threshold == "0.01",],
                       encodeOL[encodeOL$Caller == "SEACR" & encodeOL$EpMark == "H3K27me3" & encodeOL$Threshold == "0.1",])

colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.CT"]<- "Precision (% of CT)"
colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.ENCODE"] <- "Recall (% of ENCODE)"
plotencodeOL

encodeOL_restr <- pivot_longer(plotencodeOL, 
                               cols=c("Precision (% of CT)", "Recall (% of ENCODE)"),
                               names_to="OLType", values_to="Proportion")
encodeOL_restr$OLType_Caller <- paste0(encodeOL_restr$OLType, " (", encodeOL_restr$Caller,")")
ggplot(encodeOL_restr, aes(x=SampleLabel, y=Proportion, fill=OLType_Caller)) +
         geom_bar(stat = "identity", position = position_dodge(width = 0.75), width = 0.7) + 
         facet_grid(Dup ~ ., scales="free") +
  scale_fill_viridis(name = NULL, 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "mako", alpha = 0.9) +
  theme_bw(base_size = 18) +
  labs(title="ENCODE - CUT&Tag Overlap", x=NULL, y="Proportion of Peaks") +
          theme(axis.text.x = element_text(angle = 45, hjust = 1),
                legend.position = "bottom",
                 plot.title = element_text(face = "bold"))
```

#### Recall
```{r, warning=FALSE, echo=FALSE, message=FALSE}
# encodeOL_restr[encodeOL_restr$OLType %in% c("Recall (% of ENCODE)"),] %>% data.frame()
encodeOL_restr[encodeOL_restr$OLType %in% c("Recall (% of ENCODE)"), c("SampleLabel","Caller","Dup","EpMark","Proportion")] %>% data.frame()
encodeOL_restr[encodeOL_restr$OLType %in% c("Recall (% of ENCODE)"),] %>% dplyr::group_by(EpMark,Dup,Caller) %>% dplyr::summarise(max.recall=max(Proportion)) %>% data.frame()
```
#### Precision
```{r}
# encodeOL_restr[encodeOL_restr$OLType %in% c("Precision (% of CT)"),] %>% data.frame()
encodeOL_restr[encodeOL_restr$OLType %in% c("Precision (% of CT)"), c("SampleLabel","Caller","Dup","EpMark","Proportion")] %>% data.frame()
encodeOL_restr[encodeOL_restr$OLType %in% c("Precision (% of CT)"),] %>% dplyr::group_by(EpMark,Dup,Caller) %>% dplyr::summarise(max.recall=max(Proportion)) %>% data.frame()
```

## Supplementary Precision and Recall at chosen parameters for MACS2 and SEACR, with and without duplicates
With Kaya Okur and Meers CnR samples, in ENCODE H3K27ac and H3K27me3

```{r}
# List of all called peak sets
peakTest <- c(peakList, ext_peakList, sup_peakList)

# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(peakTest, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(peakTest, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(peakTest, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(peakTest, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(peakTest), ol.CTPeakCount=ct_peaks_h3k27ac, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(peakTest), ol.CTPeakCount=ct_peaks_h3k27me3, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3") )

# add peak set information
peakdf = rbind(sup_df, ext_df) %>% unique
encodeOL = merge(encodeOL, peakdf, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- encodeOL$ol.CTPeakCount / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", encodeOL$ol.ENCODEPeakCount / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", encodeOL$ol.ENCODEPeakCount / encode_ME, NA))
encodeOL
```

```{r, fig.width=18, fig.height=12.5}
plotencodeOL = encodeOL
colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.CT"] <- "Precision (% of CT)"
colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.ENCODE"] <- "Recall (% of ENCODE)"
encodeOL_restr <- pivot_longer(plotencodeOL[,-c(19:20)], 
                               cols=c("Precision (% of CT)", "Recall (% of ENCODE)"),
                               names_to="OLType", values_to="Proportion")
encodeOL_restr$Proportion <- encodeOL_restr$Proportion*100

encodeOL_restr$OLType_Caller <- paste0(encodeOL_restr$OLType, "\n", encodeOL_restr$Caller)

ggplot(encodeOL_restr, aes(x=SampleLabel, y=Proportion, fill=Dup)) +
         geom_bar(stat = "identity", position = position_dodge(width = 0.75), 
                  width = 0.7, alpha = 0.9, colour="grey10") + 
         facet_grid(Dup ~ ., scales="free") +
  scale_fill_manual(name = ' ',
                    values = c("#e1b1a2","#ed6851")) +
  theme_bw(base_size = 20) +
  labs(title="ENCODE - CUT&Tag Overlap", x=NULL, y="% of Peaks") +
          # theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
          theme(legend.position = "bottom",
                 plot.title = element_text(face = "bold")) +
  facet_grid(Group~OLType_Caller) + coord_flip()

# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_supp.svg"),
#         dpi = 1200, width = 17.0,
#         height = 12.0, units ="in")
```

#### Precision/Recall for external samples
```{r}
encodeOL[encodeOL$Source == "External",]
```

```{r}
print("Max precision/Recall for external samples:")
encodeOL[encodeOL$Source == "External","OL.prop.of.ENCODE"] %>% max
```

## Q values of ENCODE peaks captured and not captured by CUT&Tag
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=9, fig.height=9}
# MACS2 -log10(q-value) stored in column V9 for narrowPeak
# Logic: find CT-ChIP peak overlaps, extract q values, loop over each sample
testSet_H3K27ac <- ext_df[ext_df$Caller == "MACS2" & ext_df$Dup == "rmDup" & ext_df$EpMark == "H3K27ac",] %>% pull(PeakSet) %>% unique()
testSet_H3K27me3 <- ext_df[ext_df$Caller == "MACS2" & ext_df$Dup == "rmDup" & ext_df$EpMark == "H3K27me3",] %>% pull(PeakSet) %>% unique()
# testSet = c(testSet_H3K27ac, testSet_H3K27me3)
testSet = c(testSet_H3K27ac)

peakTest <- c(peakList, ext_peakList)
peakTest <- peakTest[testSet]

outDF = data.frame()
for (i in 1:length(peakTest)) {
  
  peaks = peakTest[[i]]
  name = names(peakTest)[i]
  
  if (name %in% testSet_H3K27ac) {encode = ENCODE_H3K27ac
  col="V9"}
  if (name %in% testSet_H3K27me3) {encode = ENCODE_H3K27me3
  col="V7"}
  
  encode_qval_in_ct = IRanges::subsetByOverlaps(encode, peaks) %>% as.data.frame() %>% pull(col)
  encode_qval_not_in_ct = IRanges::subsetByOverlaps(encode, peaks, invert = TRUE) %>% as.data.frame() %>% pull(col)
  
  encode_qval_in_ct %>% summary()
  encode_qval_not_in_ct %>% summary()
  
  outdf = rbind( data.frame(PeakSet=name, type="Captured", value=encode_qval_in_ct), 
                 data.frame(PeakSet=name, type="Not Captured", value=encode_qval_not_in_ct))
  outDF = rbind(outDF, outdf)
 }

# add sample label info
outDF <- merge(outDF, ext_df, by="PeakSet")
outDF$plotLabel <- str_split_fixed(outDF$SampleLabel, "-", n=2)[,2]

p <- ggplot(outDF, aes(x=SampleLabel, y=value, fill=type)) + 
  geom_boxplot(outliers=FALSE, alpha=0.7) + 
  theme_bw(base_size=20) +
  scale_fill_manual(name=NULL, values=c("#C18BB0","#7d3366")) +
  # theme(axis.text.x = element_text(angle=60, hjust=1)) +
  theme(legend.position = "top", plot.title = element_text(face = "bold",hjust=0.5,size=20)) +
  labs(x=NULL, y="-log10(q-value)",
       title="Captured ENCODE ChIP Significance") + coord_flip() 
# +
#     facet_grid(EpMark~., scales="free_y", space="free") + coord_flip()

p
# # save plot
# ggsave(path = paste0(workdir,"/encode_overlap/"),
#         filename = "boxplot_q_values_capture_vs_missed.svg",
#         dpi = 1200, width = 7.5,
#         height = 7.0, units ="in",
#        plot=p)

```
#### Welch Two Sample t-test between captured and missed ENCODE peaks
```{r}
# Compute t-test
captured =  outDF %>% filter(EpMark=="H3K27ac" & type == "Captured")  %>% pull(value)
missed =  outDF %>% filter(EpMark=="H3K27ac" & type == "Not Captured") %>% pull(value)

res <- t.test(captured, missed, alternative = "two.sided")
res
```
## ATAC-seq reads in captured vs missed ENCODE peaks
ATAC-seq libraries: ENCLB918NXF, ENCLB758GEG from https://www.encodeproject.org/experiments/ENCSR483RKN/

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# peakdir ="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ATAC/peaks"
# ATAC_path = file.path(peakdir, "K562_ATACseq.mRp.clN_peaks.narrowPeak")
# ATAC = ChIPseeker::readPeakFile(ATAC_path, as = "GRanges") %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)

# overlaps_ATAC_ENCODE = GenomicRanges::countOverlaps(query = ATAC, subject = ENCODE_H3K27ac)
# overlaps_ENCODE_ATAC = GenomicRanges::countOverlaps(query = ENCODE_H3K27ac, subject = ATAC)
# 
# length(overlaps_ATAC_ENCODE[overlaps_ATAC_ENCODE != 0])
# length(overlaps_ENCODE_ATAC[overlaps_ENCODE_ATAC != 0])
# length(ATAC)
# length(ENCODE_H3K27ac)
# 
# set="newsamples"
# dup="rmDup"
# sampleList <- c("ab177","ab4729","ab9733","diag")
# sampleList_KO <- c("H3K27ac_KO","H3K27me3_KO")
```

```{r}
# path to aligned reads for one ATAC replicate sample
# bamFile ="/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking/resources/ATAC/bam/ENCLB918NXF_REP1.mLb.clN.sorted.bam"
# total_ATAC_reads = 49719474 # (original: 49677798)
# 
# # Logic: find CT-ChIP peak overlaps, count overlapping ATAC reads in both cases, loop over each sample for MACS2 rmDup peaks 
# testSet_H3K27ac <- ext_df[ext_df$Caller == "MACS2" & ext_df$Dup == "rmDup" & ext_df$EpMark == "H3K27ac",] %>% pull(PeakSet) %>% unique()
# testSet_H3K27me3 <- ext_df[ext_df$Caller == "MACS2" & ext_df$Dup == "rmDup" & ext_df$EpMark == "H3K27me3",] %>% pull(PeakSet) %>% unique()
# testSet = c(testSet_H3K27ac, testSet_H3K27me3)
# 
# peakTest <- c(peakList, ext_peakList)
# peakTest <- peakTest[testSet]
# 
# atacCountDF = data.frame()
# for (i in 1:length(peakTest)) {
#   
#   peaks = peakTest[[i]]
#   name = names(peakTest)[i]
#   
#   if (name %in% testSet_H3K27ac) {encode = ENCODE_H3K27ac}
#   if (name %in% testSet_H3K27me3) {encode = ENCODE_H3K27me3}
#   
#   # get overlapping regions
#   encode_in_ct = IRanges::subsetByOverlaps(encode, peaks)
#   encode_not_in_ct = IRanges::subsetByOverlaps(encode, peaks, invert = TRUE)
#   # change seqnames style to remove 'chr' characters for ATAC-seq bam compatibility
#   seqlevelsStyle(encode_in_ct) <- "NCBI"
#   seqlevelsStyle(encode_not_in_ct) <- "NCBI"
#   # count coverage by captured and not captured ENCODE peaks
#   total_in_bases = sum(width(encode_in_ct))
#   total_ex_bases = sum(width(encode_not_in_ct))
#   # count ATAC reads in CT-captured ENCODE peaks
#   capture_fragment_counts = chromVAR::getCounts(bamFile, encode_in_ct, 
#                                         paired = TRUE, # originally FALSE
#                                         by_rg = FALSE, format = "bam")
#   # extract numeric value
#   captureCounts = counts(capture_fragment_counts)[,1] %>% sum
#   # count ATAC reads in CT-not-captured ENCODE peaks
#   missed_fragment_counts = chromVAR::getCounts(bamFile, encode_not_in_ct,
#                                         paired = TRUE, # originally FALSE
#                                         by_rg = FALSE, format = "bam")
#   # extract numeric value
#   missedCounts = counts(missed_fragment_counts)[,1] %>% sum
#   # format into dataframe 
#   df = rbind( 
#     data.frame(PeakSet=name, type="ENCODE in CUT&Tag", 
#                Counts=captureCounts,  
#                total_bases = total_in_bases), 
#     data.frame(PeakSet=name, type="ENCODE not in CUT&Tag", 
#                Counts=missedCounts,  
#                total_bases = total_ex_bases))
#   atacCountDF = rbind(atacCountDF, df)
#   
# }
# 
# # adjust FRiPs for total coverage of ENCODE peak set and multiplied by constant 
# atacCountDF$Counts_adj = atacCountDF$Counts/total_ATAC_reads * (10^9/atacCountDF$total_bases)
# # add line for missed atac fragments
# atacCountDF$missedCounts = total_ATAC_reads - atacCountDF$Counts 
# atacCountDF$missedCounts_adj = atacCountDF$missedCounts/total_ATAC_reads * (10^9/atacCountDF$total_bases)

# add sample label info
# atacCountLabel <- merge(atacCountDF, ext_df, by="PeakSet")

# write.csv(atacCountDF, paste0(workdir,"/analysis/results/atac_counts_in_captured_or_missed_encode_peaks.csv"))
```


```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}
# subset to H3K27ac peak sets and plot average with a standard error bar
atacCountDF = read.csv(paste0(workdir,"/analysis/results/atac_counts_in_captured_or_missed_encode_peaks.csv"),row.names=1)
atacCountDF <- merge(atacCountDF, ext_df, by="PeakSet")
plotavg = atacCountDF %>% filter(EpMark=="H3K27ac") %>% 
              dplyr::group_by(type) %>% 
              dplyr::summarise(avg=mean(Counts_adj),
                               sd=sd(Counts_adj))

ggplot(plotavg, aes(x=type, y=avg)) +
geom_bar(aes(fill = type), width = 0.7, stat = "identity", alpha = 0.7, colour="black") +
geom_errorbar(aes(ymin=avg - sd, ymax=avg + sd), 
                width=0.2, color="black") +
  theme_classic(base_size=20) +
  ylab("ATAC reads (adj. %)") +
  xlab("") +
  ggtitle("ATAC in Captured H3K27ac ENCODE") +
  theme(legend.position = "none") +
  scale_fill_manual(name = NULL, values=c("lightgreen","darkgreen"), 
                    labels = c("Captured", "Missed"))
  
# save plot
# ggsave(path = paste0(workdir,"/encode_overlap/"),
#         filename = "barplot_atac_reads_capture_vs_missed_h3k27ac.svg",
#         dpi = 1200, width = 5.0,
#         height = 7.0, units ="in")

```

```{r}
atacCountDF = read.csv(paste0(workdir,"/analysis/results/atac_counts_in_captured_or_missed_encode_peaks.csv"),row.names=1)
atacCountDF <- merge(atacCountDF, ext_df, by="PeakSet")
# Compute t-test
captured =  atacCountDF %>% filter(EpMark=="H3K27ac" & type == "ENCODE in CUT&Tag")  %>% pull(Counts_adj)
missed =  atacCountDF %>% filter(EpMark=="H3K27ac" & type == "ENCODE not in CUT&Tag") %>% pull(Counts_adj)

res <- t.test(captured, missed, alternative = "two.sided")
res

```

# Precision and Recall for IgG control peak calling {.tabset}
## Peak counts
```{r, warning=FALSE}

h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")


set="individual" # opts: allsample, newsample, individual
callerdir=c("SEACR","MACS2")
dupList = c("rmDup","withDup")


igg_blacklist_counts = c()
igg_peakList = list()
igg_peakList_unfilt = list()
igg_callInfo = list()


for (dup in dupList) {

  for (sample in sampleList) {

    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"}
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"}

      for (caller in callerdir) {

        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q1e-5_peaks.",setting,"Peak") }

        # check
        # print(paste0(workdir,"/peakCalling/iggControl/",caller,"/",sample,"_",dup,"_", suffix))

        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(paste0(workdir,"/peakCalling/iggControl/",caller,"/",sample,"_",dup,"_", suffix), as = "GRanges")

        # store all peaks in a list
        igg_peakList_unfilt = c(igg_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        igg_blacklist_counts = c(igg_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        igg_peakList = c(igg_peakList, peak_filt)
        # store peak calling information
        igg_callInfo = c(igg_callInfo, paste0(sample,"_",caller,"_",dup))
  }

}
}

# name peak lists
names(igg_peakList) = igg_callInfo
names(igg_peakList_unfilt) = igg_callInfo
names(igg_blacklist_counts) = igg_callInfo
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(igg_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(igg_peakList[[i]])) }
names(Total_CT_peaks) <- igg_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=12}
# split peak set information and plot bar plot
igg_df=data.frame(Total_CT_peaks)
igg_df$PeakSet = rownames(igg_df)
igg_df$Sample <- str_split_fixed(igg_df$PeakSet, "_", n=3)[,1]
igg_df$Caller <- str_split_fixed(igg_df$PeakSet, "_", n=3)[,2]
igg_df$Dup <- str_split_fixed(igg_df$PeakSet, "_", n=3)[,3]
igg_df$Source = "InHouse"
igg_df$control = "IgG"

# add sample label
# igg_df <- igg_df %>%
#   mutate(SampleLabel = ifelse(Sample %in% metadata$Sample, metadata$Label[match(Sample, metadata$Sample)], Sample))
igg_df = merge(igg_df, alignResult[c("Sample","SampleLabel")], by="Sample")
# extract epigenetic mark information
igg_df$EpMark <- str_split_fixed(igg_df$SampleLabel, "-", n=3)[,1]


plotdata = rbind(igg_df, org_df)

options(scipen=999)
PeakN_plot = ggplot(plotdata, aes(SampleLabel, Total_CT_peaks, fill=Dup
                                )) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", colour="grey1", alpha=0.5) +
  scale_fill_manual(name = "", values = c("violet","purple4")) +
  theme_light(base_size=20) +
  ggtitle("Number of sample peaks") +
  xlab("Sample") +
  ylab("") +
  # theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(axis.text = element_text(size = 15)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 25, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "right") +
  theme(strip.background = element_rect(fill="grey50")) +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, 100000) +
  facet_grid( EpMark+control ~ Caller, scales="free_y", space = "free_y") +
  coord_flip()

PeakN_plot
```

## Peak widths
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=22, fig.show="hold"}
# repeat for each sample peak set seperately
info = igg_df # df = only in-house datasets; ext_df = both internal and external
info$PeakSet[info$control == "IgG"] <- paste0(info$PeakSet[info$control == "IgG"],"_igg")
info = plyr::arrange(info, EpMark, Caller, Sample)
info$plotlab = paste0(info$SampleLabel," ", info$Caller, " ", info$Dup, " ", info$control)

igg_peakList_rename <- igg_peakList
names(igg_peakList_rename) <- paste0(names(igg_peakList_rename), "_igg")
peakTest = c(peakList, igg_peakList_rename, ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3) # peakList = only in-house datasets; ext_peakList = only external datasets


### Loop over all peak sets
# peakTest = c(ext_peakList, peakList) # peakList = only in-house datasets; ext_peakList = only external datasets
peakWidths = c()
for (i in 1:length(peakTest)) {
  peaks = peakTest[[i]]
  # name = names(peakTest)[i]
  widths = unlist(as(peaks, "GRangesList")) %>% GenomicRanges::width()
  peakWidths = c(peakWidths, list(widths))
}
names(peakWidths) <- names(peakTest)

# rename peakWidths list using matching plotlab values in info DF
renamed_list <- info$plotlab[match(names(peakWidths), info$PeakSet)]
renamed_list <- ifelse(is.na(renamed_list), names(peakWidths), renamed_list)
names(peakWidths) <- renamed_list

ord = c("ENCODE_H3K27ac", info$plotlab[info$EpMark == "H3K27ac"], "ENCODE_H3K27me3", info$plotlab[info$EpMark == "H3K27me3"])
reordered_list <- peakWidths[match(ord, names(peakWidths))]

features = reordered_list

# plot boxplot for peak widths
options(scipen=999) # prevent scientific notation

par(mar=c(10,30,8,5))
par(cex.lab=1.5) # is for y-axis
par(cex.axis=1.5) # is for x-axis
par(cex.main=1.5)
boxplot(features,
        outline = TRUE,
        names = names(features),
        # ylab = "Width (bp)",
        xlab = "logscale width (bp)",
        main = "Peak width distribution",
        # log = "y",
        log = "x",
        # ylim = c(1, max(unlist(features))),
        # xlim = c(1, max(unlist(features))),
        las=2,
        cex.names=0.2,
        horizontal=T)
```

## Precision/Recall
```{r}
# load ENCODE ChIP peaks
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")
```

```{r}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac
h3k27ac_setNames = igg_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3
h3k27me3_setNames = igg_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(igg_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){

  sample_peaks_in_ref = c()

  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){

  ref_in_sample_peaks = c()

  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3") )

# add peak set information
encodeOL = merge(encodeOL, igg_df[igg_df$control=="IgG",], by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- encodeOL$ol.CTPeakCount / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", encodeOL$ol.ENCODEPeakCount / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", encodeOL$ol.ENCODEPeakCount / encode_ME, NA))
encodeOL
igg_encodeOL = encodeOL
###
```

```{r, fig.width=25, fig.height=12}

ggplot(igg_encodeOL, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, shape=Dup)) +
  geom_point(size=4, alpha = 0.8) +
  # scale_size_discrete(range = c(1, 5), name = " ") +
  theme_bw(base_size = 20) +
  # scale_colour_viridis(name = "Antibody", label = labs,
  #                      discrete = TRUE, begin = 0.1, end = 0.85,
  #                      option = "mako", alpha = 0.9) +
  ylim(0,1) + xlim(0,1) +
  ggtitle("Common CUT&Tag and ENCODE ChIP-seq peaks") +
  ylab("Proportion of all CT") +
  xlab("Proportion of all ENCODE ChIP") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  facet_wrap(Caller~EpMark+Dup, scale="free_x", ncol=4)

```


```{r, fig.width=16, fig.height=12.5}
# barplot for precision and recall
org_encodeOL$control <- "none"
cols = intersect(colnames(org_encodeOL), colnames(igg_encodeOL))
plotencodeOL = rbind(igg_encodeOL[cols], org_encodeOL[cols])

# only internal samples
plotencodeOL = plotencodeOL[plotencodeOL$Source == "InHouse",]

# change labels
colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.CT"] <- "Precision (% of CT)"
colnames(plotencodeOL)[colnames(plotencodeOL) == "OL.prop.of.ENCODE"] <- "Recall (% of ENCODE)"
encodeOL_restr <- pivot_longer(plotencodeOL[,-c(19:20)],
                               cols=c("Precision (% of CT)", "Recall (% of ENCODE)"),
                               names_to="OLType", values_to="Proportion")
# Convert proportion to percentage
encodeOL_restr$Proportion <- encodeOL_restr$Proportion*100
# Create label
encodeOL_restr$OLType_Caller <- paste0(encodeOL_restr$OLType, "\n", encodeOL_restr$Caller)
# Plot
ggplot(encodeOL_restr, aes(x=SampleLabel, y=Proportion, fill=control)) +
         geom_bar(stat = "identity", position = position_dodge(width = 0.75),
                  width = 0.7, alpha = 0.9, colour="grey10") +
         facet_grid(control ~ ., scales="free") +
  scale_fill_manual(name = ' ',
                    values = c("steelblue","skyblue")) +
  theme_bw(base_size = 20) +
  labs(title="ENCODE-CUT&Tag Overlap with IgG Control", x=NULL, y="% of Peaks") +
  theme(legend.position = "right",
        plot.title = element_text(face = "bold")
        # ,
        # axis.text = element_text(size = 20)
        ) +
  facet_grid(EpMark+Dup~OLType_Caller, scales="free_y", space="free") +
  coord_flip()
# # save
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_igg_control.svg"),
#         dpi = 1200, width = 16.0,
#         height = 10.0, units ="in")
```


# Precision and Recall for MACS2 lambda activated; q-values {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="individual" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="MACS2"
# dupList = c("rmDup","withDup")
dupList="rmDup"
threshold_list = list(
                      # SEACR = c("0.01", "0.03", "0.05", "0.1"), 
                      MACS2 = c("1e-5", "0.001", "0.01", "0.1"))
                                # 0.000001,"1"))

par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/qval_lambda/",sample,"_",dup,"_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=5)[,3]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=5)[,5]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
par_df <- merge(par_df, alignDupSummary, by="Sample")

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, 200000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall  
```{r}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```


```{r, fig.width=10, fig.height=6}

callername="MACS2" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "q value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("MACS2: Q-values, Lambda") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# # save plot
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_MACS2_Qval_lambda_",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p1)
# # save plot (svg)
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_MACS2_Qval_lambda_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p1)

```


# Precision and Recall for MACS2 no lamda; p-values {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="individual" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="MACS2"
# dupList = c("rmDup","withDup")
dupList="rmDup"
threshold_list = list(
                      # SEACR = c("0.01", "0.03", "0.05", "0.1"), 
                      MACS2 = c("1e-5", "0.001", "0.01", "0.1"))
                                # 0.000001,"1"))

par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("p",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/pval_nolambda/",sample,"_",dup,"_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=5)[,3]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=5)[,5]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
par_df <- merge(par_df, alignDupSummary, by="Sample")

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall  
```{r}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```


```{r, fig.width=10, fig.height=6}

callername="MACS2" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "p value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("MACS2: P-values, No Lambda") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# # save plot
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_MACS2_Pval_nolambda_",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p1)
# # save plot (svg)
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_MACS2_Pval_nolambda_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p1)

```


# Precision and Recall for MACS2 lambda activated; p-values {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="individual" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="MACS2"
# dupList = c("rmDup","withDup")
dupList="rmDup"
threshold_list = list(MACS2 = c("1e-5", "0.001", "0.01", "0.1"))

par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("p",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/pval_lambda/",sample,"_",dup,"_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=5)[,3]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=5)[,5]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
par_df <- merge(par_df, alignDupSummary, by="Sample")

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall 
```{r}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```


```{r, fig.width=10, fig.height=6}

callername="MACS2" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "p value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("MACS2: P-values, Lambda") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# save plot
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_MACS2_Pval_lambda_",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p1)
# # save plot (svg)
# callername="MACS2"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_MACS2_Pval_lambda_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p1)

```

# Precision and Recall for SEACR relaxed {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="individual" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="SEACR"
# dupList = c("rmDup","withDup")
dupList="rmDup"
threshold_list = list(SEACR = c("0.01", "0.03", "0.05", "0.1"))


par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.relaxed.bed") }
        if (caller == "MACS2") { suffix=paste0("p",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/relaxed/",sample,"_",dup,"_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=5)[,3]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=5)[,5]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
par_df <- merge(par_df, alignDupSummary, by="Sample")

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall 
```{r, warning=FALSE}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac"),
                   data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```


```{r, fig.width=10, fig.height=6, warning=FALSE}

callername="SEACR" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "Top.Prop") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "magma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("SEACR: Top Proportions, Relaxed") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# save plot
# callername="SEACR"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_SEACR_relaxed_",callername,"_",dupname,".pdf"),
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",
#         plot=p1)
# # save plot (svg)
# callername="SEACR"
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_SEACR_relaxed_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 10.0,
#         height = 6.0, units ="in",
#         plot=p1)

```

# Precision and Recall for MACS2 merged samples {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
# h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
# h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
h3k27ac_sampleList=c("h3k27ac_newsample")
# h3k27me3_sampleList=c("h3k27me3_newsample")
# sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)
sampleList = c(h3k27ac_sampleList)


# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="merge" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="MACS2"
dupList = c("rmDup","withDup")
# dupList="rmDup"
threshold_list = list(
  MACS2 = c("1e-6", "3e-6", "5e-6", "1e-5", "3e-5", "5e-5", "1e-4", "3e-4" ,"5e-4",
            "0.001", "0.003", "0.005" ,"0.01" ,"0.03" ,"0.05" ,"0.1", "0.3", "0.5"),
  SEACR = c("0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07", "0.08", "0.09", 
            "0.1", "0.11", "0.12", "0.13", "0.14", "0.15"))


par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/",sample,"_",dup,"_merge_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r, warning=FALSE}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=6)[,1]
par_df$Sample <- "all"
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=6)[,4]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=6)[,5]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=6)[,6]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
# par_df <- merge(par_df, alignDupSummary, by="Sample")
par_df$SampleLabel <- par_df$Sample

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall 
```{r, warning=FALSE}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac")
                   # ,
                   # data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3,
                   #            ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```

```{r, fig.width=8.5, fig.height=6, warning=FALSE}
options(digits=5)

callername="MACS2" # MACS2 / SEACR
# dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername 
                    # & encodeOL$Dup == dupname
                    ,] 

# edit restrict to select thresholds
plotdata = plotdata[plotdata$Threshold %in% c("0.00001","0.001","0.01","0.1"),]


p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=Dup, size=Threshold)) + 
  geom_line(size = 1.5) + geom_point(alpha = 0.7) + 
  scale_size_discrete(range = c(1, 4), name = "q value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.8) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("MACS2") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_allmerged_",callername,".svg"),
#         dpi = 1200, width = 7.5,
#         height = 5.5, units ="in",
#         plot=p1)

```

## F1 Score
```{r, fig.width=7.5, fig.height=6, warning=FALSE}
data = plotdata
# true postive / (true positive + 0.5*(false positive + true negative))
data$f1score = data$OL.prop.of.CT / (data$OL.prop.of.CT + 0.5*(data$OL.prop.of.CT + data$OL.prop.of.ENCODE))

callername="MACS2" # MACS2 / SEACR
# dupname="rmDup"
# plotdata = data[data$Caller == callername,] 
plotdata = data

p1 <- ggplot(plotdata, aes(x=Threshold, y=f1score, colour=Dup, group = Dup)) + 
  geom_line(linewidth = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "q value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample (N=6)", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.9) +
  # ylim(0,100) + xlim(0,100) +
  ggtitle("MACS2") +
  ylab("F1 Score") +
  xlab("q value") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1


# write.csv(data, paste0(workdir,"/encode_overlap/f1Scores/allmerged_macs2.csv"))

# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("f1score_linegraph_allmerged_",callername,".svg"),
#         dpi = 1200, width = 7.5,
#         height = 6.0, units ="in",
#         plot=p1)
```


# Precision and Recall for MACS2 merge replicates {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
# h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
# h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
h3k27ac_sampleList=c("ab177", "ab4729", "diag")
h3k27me3_sampleList=c("ab9733")
# sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)
sampleList = c(h3k27ac_sampleList)


# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="newsamples" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="MACS2"
# dupList = c("rmDup","withDup")
dupList="rmDup"
# threshold_list = list(
#   MACS2 = c("1e-6", "3e-6", "5e-6", "1e-5", "3e-5", "5e-5", "1e-4", "3e-4" ,"5e-4",
#             "0.001", "0.003", "0.005" ,"0.01" ,"0.03" ,"0.05" ,"0.1", "0.3", "0.5"),
#   SEACR = c("0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07", "0.08", "0.09", 
#             "0.1", "0.11", "0.12", "0.13", "0.14", "0.15"))
threshold_list = list(MACS2 = c("1e-5","0.001","0.01","0.1"))

par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0(set,"_seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/", sample,"_",dup,"_",set,"_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=5)[,3]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=5)[,5]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
# par_df <- merge(par_df, alignDupSummary, by="Sample")
par_df$SampleLabel <- par_df$Sample

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall 
```{r, warning=FALSE}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac")
                   # ,
                   # data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3,
                   #            ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```

```{r, fig.width=9, fig.height=6, warning=FALSE}

callername="MACS2" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "q value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Merged Samples", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("MACS2") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# # save plot
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_antibodyreps_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 8.0,
#         height = 5.5, units ="in",
#         plot=p1)

```

## F1 Score
```{r, fig.width=7, fig.height=6, warning=FALSE}
data = plotdata
# true postive / (true positive + 0.5*(false positive + true negative))
data$f1score = data$OL.prop.of.CT / (data$OL.prop.of.CT + 0.5*(data$OL.prop.of.CT + data$OL.prop.of.ENCODE))

callername="MACS2" # MACS2 / SEACR
dupname="rmDup"
# plotdata = data[data$Caller == callername,] 
plotdata = data

p1 <- ggplot(plotdata, aes(x=Threshold, y=f1score, colour=SampleLabel, group = SampleLabel)) + 
  geom_line(linewidth = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "q value") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.9) +
  # ylim(0,100) + xlim(0,100) +
  ggtitle("MACS2") +
  ylab("F1 Score") +
  xlab("q value") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# write.csv(data, paste0(workdir,"/encode_overlap/f1Scores/antibodyreps_macs2.csv"))
# 
# # save plot
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("f1score_linegraph_antibodyreps_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 7.0,
#         height = 5.5, units ="in",
#         plot=p1)
```



# Precision and Recall for SEACR merged samples {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
# h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
# h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
h3k27ac_sampleList=c("h3k27ac_newsample")
h3k27me3_sampleList=c("h3k27me3_newsample")
# sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)
sampleList = c(h3k27ac_sampleList)


# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="merge" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="SEACR"
dupList = c("rmDup","withDup")
# dupList="rmDup"
threshold_list = list(
  MACS2 = c("1e-6", "3e-6", "5e-6", "1e-5", "3e-5", "5e-5", "1e-4", "3e-4" ,"5e-4",
            "0.001", "0.003", "0.005" ,"0.01" ,"0.03" ,"0.05" ,"0.1", "0.3", "0.5"),
  SEACR = c("0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07", "0.08", "0.09", 
            "0.1", "0.11", "0.12", "0.13", "0.14", "0.15"))


par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0("seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/",sample,"_",dup,"_merge_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r, warning=FALSE}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=6)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=6)[,3]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=6)[,4]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=6)[,5]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=6)[,6]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
# par_df <- merge(par_df, alignDupSummary, by="Sample")
par_df$SampleLabel <- par_df$Sample

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall 
```{r, warning=FALSE}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac")
                   # ,
                   # data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3, 
                   #            ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```

```{r, fig.width=8.5, fig.height=6, warning=FALSE}
callername="SEACR" # MACS2 / SEACR
# dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername 
                    # & encodeOL$Dup == dupname
                    ,] 
## edit subset to select thresholds
plotdata = plotdata[plotdata$Threshold %in% c("0.01","0.03","0.05","0.1"),]

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=Dup, size=Threshold)) + 
  geom_line(size = 0.7, alpha = 0.5) + geom_point(alpha = 0.5) + 
  scale_size_discrete(range = c(2, 5), name = "Top.Prop") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("SEACR") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1


# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_allmerge_",callername,".svg"),
#         dpi = 1200, width = 7.5,
#         height = 5.5, units ="in",
#         plot=p1)

```

## F1 Score
```{r, fig.width=8, fig.height=6, warning=FALSE}
data = plotdata
# true postive / (true positive + 0.5*(false positive + true negative))
data$f1score = data$OL.prop.of.CT / (data$OL.prop.of.CT + 0.5*(data$OL.prop.of.CT + data$OL.prop.of.ENCODE))

callername="SEACR" # MACS2 / SEACR
# dupname="rmDup"
# plotdata = data[data$Caller == callername,] 
plotdata=data 

p1 <- ggplot(plotdata, aes(x=Threshold, y=f1score, colour=Dup, group = Dup)) + 
  geom_line(linewidth = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "Top.Prop") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.9) +
  # ylim(0,100) + xlim(0,100) +
  ggtitle("SEACR") +
  ylab("F1 Score") +
  xlab("Threshold") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# write.csv(data, paste0(workdir,"/encode_overlap/f1Scores/allmerged_seacr.csv"))
# 
# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("f1score_linegraph_allmerged_",callername,".svg"),
#         dpi = 1200, width = 7.0,
#         height = 5.25, units ="in",
#         plot=p1)
```


# Precision and recall for SEACR merge replicates {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
# h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
# h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
h3k27ac_sampleList=c("ab177", "ab4729", "diag")
h3k27me3_sampleList=c("ab9733")
# sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)
sampleList = c(h3k27ac_sampleList)


# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="newsamples" # opts: allsample, newsample, individual
# callerdir=c("SEACR","MACS2")
callerdir="SEACR"
# dupList = c("rmDup","withDup")
dupList="rmDup"
# threshold_list = list(
#   MACS2 = c("1e-6", "3e-6", "5e-6", "1e-5", "3e-5", "5e-5", "1e-4", "3e-4" ,"5e-4",
#             "0.001", "0.003", "0.005" ,"0.01" ,"0.03" ,"0.05" ,"0.1", "0.3", "0.5"),
#   SEACR = c("0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07", "0.08", "0.09", 
#             "0.1", "0.11", "0.12", "0.13", "0.14", "0.15"))
threshold_list = list(MACS2 = c("1e-5","0.001","0.01","0.1"),
                      SEACR = c("0.01","0.03","0.05","0.1"))

par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0("seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/", sample,"_",dup,"_",set,"_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r, warning=FALSE}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=5)[,3]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=5)[,5]
# par_df$SampleLabel <- paste0(thd_df$EpMark, "-", thd_df$Sample)

# add sample label from prior table
# par_df <- merge(par_df, alignDupSummary, by="Sample")
par_df$SampleLabel <- par_df$Sample

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(Threshold, Total_CT_peaks, fill=Dup)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(~Caller+SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall 
```{r, warning=FALSE}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac")
                   # ,
                   # data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3,
                   #            ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```

```{r, fig.width=8, fig.height=6, warning=FALSE}

callername="SEACR" # MACS2 / SEACR
dupname="rmDup"
plotdata = encodeOL[encodeOL$Caller == callername & encodeOL$Dup == dupname,] 

p1 <- ggplot(plotdata, aes(x=OL.prop.of.ENCODE, y=OL.prop.of.CT, colour=SampleLabel, size=Threshold)) + 
  geom_line(size = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "Top.Prop") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample (N=2)", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.9) +
  ylim(0,100) + xlim(0,100) +
  ggtitle("SEACR") +
  ylab("Precision (% of CUT&Tag Peaks)") +
  xlab("Recall (% of ENCODE Peaks)") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("precision_recall_curve_antibodyreps_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 7.5,
#         height = 5.5, units ="in",
#         plot=p1)

```


## F1 Score
```{r, fig.width=8, fig.height=6, warning=FALSE}
data = encodeOL
# true postive / (true positive + 0.5*(false positive + true negative))
data$f1score = data$OL.prop.of.CT / (data$OL.prop.of.CT + 0.5*(data$OL.prop.of.CT + data$OL.prop.of.ENCODE))

callername="SEACR" # MACS2 / SEACR
dupname="rmDup"
# plotdata = data[data$Caller == callername,] 
plotdata=data 

p1 <- ggplot(plotdata, aes(x=Threshold, y=f1score, colour=SampleLabel, size=Threshold, group = SampleLabel)) + 
  geom_line(linewidth = 0.7) + geom_point(alpha = 0.6) + 
  scale_size_discrete(range = c(2, 5), name = "Threshold") +
  theme_bw(base_size = 25) +
  scale_colour_viridis(name = "Sample (N=2)", 
                       discrete = TRUE, begin = 0.1, end = 0.85,
                       option = "plasma", alpha = 0.9) +
  # ylim(0,100) + xlim(0,100) +
  ggtitle("SEACR") +
  ylab("F1 Score") +
  xlab("Threshold") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) 
p1

# write.csv(data, paste0(workdir,"/encode_overlap/f1Scores/antibodyreps_seacr.csv"))


# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("f1score_linegraph_antibodyreps_",callername,"_",dupname,".svg"),
#         dpi = 1200, width = 7.5,
#         height = 5.5, units ="in",
#         plot=p1)
```


# Precision and Recall for MACS2 and SEACR 8M read depth {.tabset}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
h3k27ac_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27ac_sample.csv"),header=FALSE)[[1]]
# h3k27me3_sampleList = read.delim(paste0(workdir, "/sampleinfo/h3k27me3_sample.csv"),header=FALSE)[[1]]
# sampleList = c(h3k27ac_sampleList, h3k27me3_sampleList)
sampleList = c(h3k27ac_sampleList)

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

set="8M" # opts: allsample, newsample, individual, 8M
callerdir=c("SEACR","MACS2")
dupList="rmDup"
threshold_list = list(SEACR = c("0.01","0.03","0.05","0.1"), MACS2 = c("1e-5","0.001","0.01","0.1"))

par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (dup in dupList) {
  for (sample in sampleList) {
    # for MACS2, define narrow or broad peak setting
    if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                          epmark = "H3K27me3"} 
    if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                          epmark = "H3K27ac"} 
  
      for (caller in callerdir) {
        ## define which threshold list to use based on peak calling tool
        thresholdList = threshold_list[[caller]]
        
        for (threshold in thresholdList) {
        # for peak caller, define the peak file name suffix
        if (caller == "SEACR") { suffix=paste0("seacr_top",threshold,"_peaks.stringent.bed") }
        if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
        # check
          peakfile=paste0(workdir,"/peakCalling/",caller,"/", sample,"_",dup,"_",set,"_", suffix)
          # print(peakfile)
        
        # read in peak regions
        peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
       
        # store all peaks in a list
        par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
        # count peaks in blacklist regions
        blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
        # store peaks in blacklist regions
        par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
        # filter out peaks in blacklist regions and irregular chromosomes
        peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
        # store filtered peak list
        par_peakList = c(par_peakList, peak_filt)
        # store peak calling information
        par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",dup,"_",threshold))
        
        }
  }
    
}
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r, warning=FALSE}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=35, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Caller <- str_split_fixed(par_df$PeakSet, "_", n=5)[,3]
par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Threshold <- str_split_fixed(par_df$PeakSet, "_", n=5)[,5]

# add sample label from prior table
par_df <- merge(par_df, alignDupSummary, by="Sample")
# par_df$SampleLabel <- par_df$Sample

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

PeakN_plot = ggplot(par_df, aes(x=Threshold, y=Total_CT_peaks, fill=Caller)) +
  geom_bar(aes(fill = Dup), width = 0.7, position = "dodge", stat = "identity", alpha=0.6) + 
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_light(base_size=30) + 
  ggtitle("Number of peaks") +
  xlab("Threshold") +
  ylab("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom") +
  theme(strip.background =element_rect(fill="grey60"))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) +
  facet_wrap(Caller~SampleLabel, scales="free_x", ncol=8)

PeakN_plot
```

## Precision-Recall 
```{r, warning=FALSE}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac")
                   # ,
                   # data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3,
                   #            ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```

## F1 Score
```{r, fig.width=9, fig.height=6, warning=FALSE}
data = encodeOL
# true positive / (true positive + 0.5*(false positive + true negative))
data$f1score = data$OL.prop.of.CT / (data$OL.prop.of.CT + 0.5*(data$OL.prop.of.CT + data$OL.prop.of.ENCODE))
plotdata = data
plotdata$Label <- paste0(plotdata$SampleLabel, "(",plotdata$Caller,")")

p1 <- ggplot(plotdata, aes(x=SampleLabel, y=f1score, fill=Caller)) +
  geom_bar(stat="identity", position=position_dodge2(width=0.9)) +
  theme_bw(base_size = 25) +
  scale_fill_viridis(name = "Peak Caller",
                       discrete = TRUE, begin = 0.65, end = 0.9,
                       option = "plasma", alpha = 0.85) +
  # ylim(0,100) + xlim(0,100) +
  ggtitle("") +
  ylab("F1 Score") +
  xlab("") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) + coord_flip()
p1

# write.csv(data, paste0(workdir,"/encode_overlap/f1Scores/samples_8M.csv"))
# 
# 
# # save plot
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("f1score_barplot_antibodycaller_",dupname,".svg"),
#         dpi = 1200, width = 8.5,
#         height = 5.0, units ="in",
#         plot=p1)
```



# F1 scores (Supplementary)
```{r, warning=FALSE}
# read in data
inpath=paste0(workdir,"/encode_overlap/f1Scores/")
fileList = list.files(inpath)
collectdf = data.frame()
for (file in fileList) {
  df = read.csv(paste0(inpath, file), row.names=1)
  df$file = file
  
  # if (file == "samples_all.csv") {
  #   df$Threshold <- "0.00001"
  #   df$Threshold[df$Caller == "SEACR"] <- "0.01"
  # }
  # 
  if (ncol(collectdf)!=0) {
    comcols = intersect(colnames(collectdf), colnames(df))
    collectdf = rbind(collectdf[comcols], df[comcols]) 
  }
   if (ncol(collectdf)==0) {
   collectdf = rbind(collectdf, df) 
   }
}

collectdf$SampleLabel[collectdf$SampleLabel == "all" & collectdf$Dup == "withDup"] <- "All (with dups, N=6)"
collectdf$SampleLabel[collectdf$SampleLabel == "all" & collectdf$Dup == "rmDup"] <- "All (without dups, N=6)"
collectdf$SampleLabel[collectdf$SampleLabel == "newsample" & collectdf$Dup == "withDup"] <- "All (with dups, N=6)"
collectdf$SampleLabel[collectdf$SampleLabel == "newsample" & collectdf$Dup == "rmDup"] <- "All (without dups, N=6)"

collectdf$SampleLabel[collectdf$SampleLabel == "diag"] <- "H3K27ac-diag (N=2)"
collectdf$SampleLabel[collectdf$SampleLabel == "ab4729"] <- "H3K27ac-ab4729 (N=2)"
collectdf$SampleLabel[collectdf$SampleLabel == "ab177"] <- "H3K27ac-ab177 (N=2)"

collectdf$SampleLabel[collectdf$file == "samples_8M.csv"] <- paste0(collectdf$SampleLabel[collectdf$file == "samples_8M.csv"] ," (8M)")
collectdf$SampleLabel[collectdf$file == "samples_all.csv"] <- paste0(collectdf$SampleLabel[collectdf$file == "samples_all.csv"] ," (Full)")

collectdf$SampleLabel <- factor(collectdf$SampleLabel, levels=unique(collectdf$SampleLabel))

# remove me3
collectdf = collectdf[collectdf$EpMark == "H3K27ac",]

collectdf$Threshold <- as.factor(collectdf$Threshold)

collectdf$f1score <- as.numeric(collectdf$f1score)
```

```{r, fig.width=12, fig.height=12, warning=FALSE}
ggplot(collectdf, aes(x=Threshold, y=SampleLabel, fill=f1score)) +
  geom_tile() +
  facet_grid(~Caller, scales = "free_x") + 
  theme_bw(base_size = 25) +
  theme(legend.position = "top", 
        legend.key.size = unit(1.2, 'cm'),
        legend.text = element_text(size=20)) +
  scale_fill_viridis(name = "F-1 Score",
                       discrete = FALSE, begin = 0.01, end = 0.99,
                       option = "plasma", alpha = 0.99) 

# # save plot (svg)
# ggsave(path = paste0(workdir,"/encode_overlap"),
#         filename = paste0("f1scores_H3K27ac_merged_sample.svg"),
#         dpi = 1200, width = 10.0,
#         height = 9.0, units ="in")
```

# Read correlation
Measuring the similarity between replicates and antibodies by correlating reads.

## 500bp genome-wide bins (hg19)
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
counts = read.csv(paste0(workdir, "/correlation/hg19_500bp_ranges_samples_correlations.txt"), sep = "\t", header = FALSE)

# individual samples (v2)
colnames(counts) = c("chr", "start", "end", "H3K27ac ab177178 1", "H3K27ac ab177178 2",
                     "H3K27me3 ab9733 1", "H3K27me3 ab9733 2", "H3K27ac ab4729 1", "H3K27ac ab4729 2",
                     "H3K27ac Diagenode 1", "H3K27ac Diagenode 2", "H3K27ac ab177178 HDup",
                     "H3K27ac ActiveMotif HDup",
                     "ActiveMotif_H3K27ac",
                     "H3K27ac ab4729 HDup","H3K27ac Diagenode 100x HDup","H3K27ac Diagenode 50x HDup", "H3K27me3 ab9733 HDup", 
                     "H3K27ac Kaya-Okur 1", "H3K27ac Kaya-Okur 2", "H3K27me3 Kaya-Okur 1", "H3K27me3 Kaya-Okur 2", 
                     "H3K27ac Diagenode 50x TSA", "H3K27me3 scCT", 
                     "H3K27ac Meers CnR","H3K27me3 Meers CnR",
                     "ENCODE H3K27ac", "ENCODE H3K27me3", "ENCODE H3K4me1", "ENCODE H3K4me3", "ENCODE H3K9ac", 
                     "ENCODE H3K9me3", "ENCODE H3K36me3","ENCODE DNase")


count_cut <- counts[,-c(14,23,24)]              # remove "ActiveMotif_H3K27ac" , "H3K27ac-diag50x-TSA", "H3K27me3-scCT"  
count_cut <- counts[,-c(14,23,24,29,30,31,32,33,34)]     # remove "ActiveMotif_H3K27ac" , "H3K27ac-diag50x-TSA", "H3K27me3-scCT",
                                                        # "ENCODE H3K4me1","ENCODE H3K4me3", "ENCODE H3K9me3", "ENCODE H3K36me3", "ENCODE DNase"   

```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# same order as bam list
names = colnames(count_cut)[-c(1:3)]
counts_copy = count_cut
counts_copy = counts_copy[,4:length(counts_copy)] %>% as.matrix() %>% preprocessCore::normalize.quantiles() %>% round() %>% cor(method = "pearson")
colnames(counts_copy) = names
rownames(counts_copy) = names

counts_copy[counts_copy <= 0] = 0
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}
# round the counts
counts_rounded = counts_copy %>% round(2)
# assign colour based on epigenetic mark
colNames = colnames(counts_rounded)
ColColors <- ifelse(grepl("H3K27ac", colNames), "skyblue1", "#127688")
# plot
heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
          cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
          lhei = c(1, 5), lwid = c(1, 4), margins = c(15,15),
          ColSideColors = ColColors)

# save
# svglite(paste0(workdir,"/correlation/heatmap_hg19bin_correlation.svg"), width = 8, height = 8)
# heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
#           cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
#           lhei = c(1, 5), lwid = c(1, 4), margins = c(15,15),
#           ColSideColors = ColColors)
# dev.off()

# other options:
# col = col = colorRampPalette(brewer.pal(9, "BuPu"))(100)
# col2 = c(col, col)
#heatmap.2(x = counts, col = "viridis", trace = "none", density.info = "none", cellnote = counts, cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", lhei = c(1, 10), lwid = c(1, 7), margins = c(20, 20))
```

## H3K27ac ENCODE ranges
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
markName="H3K27ac_ENCFF044JNJ"
counts = read.csv(paste0(workdir,"/correlation/", markName, "_sample_correlations.txt"), sep = "\t", header = FALSE)
# remove peak calling columns
counts = counts[-c(4:10)]
colnames(counts) = c("chr", "start", "end", "H3K27ac ab177178 1", "H3K27ac ab177178 2",
                     "H3K27me3 ab9733 1", "H3K27me3 ab9733 2", "H3K27ac ab4729 1", "H3K27ac ab4729 2",
                     "H3K27ac Diagenode 1", "H3K27ac Diagenode 2", "H3K27ac ab177178 HDup",
                     "H3K27ac ActiveMotif HDup",
                     "ActiveMotif_H3K27ac",
                     "H3K27ac ab4729 HDup","H3K27ac Diagenode 100x HDup","H3K27ac Diagenode 50x HDup", "H3K27me3 ab9733 HDup", 
                     "H3K27ac Kaya-Okur 1", "H3K27ac Kaya-Okur 2", "H3K27me3 Kaya-Okur 1", "H3K27me3 Kaya-Okur 2", 
                     "H3K27ac Diagenode 50x TSA", "H3K27me3 scCT", 
                     "H3K27ac Meers CnR","H3K27me3 Meers CnR",
                     "ENCODE H3K27ac", "ENCODE H3K27me3", "ENCODE H3K4me1", "ENCODE H3K4me3", "ENCODE H3K9ac", 
                     "ENCODE H3K9me3", "ENCODE H3K36me3","ENCODE DNase")
# remove comparisons not used
# count_cut <- counts[,-c(14,23,24)]              # remove "ActiveMotif_H3K27ac" , "H3K27ac-diag50x-TSA", "H3K27me3-scCT"  
count_cut <- counts[,-c(14,23,24,29,30,31,32,33,34)]     # remove "ActiveMotif_H3K27ac" , "H3K27ac-diag50x-TSA", "H3K27me3-scCT",
                                                        # "ENCODE H3K4me1","ENCODE H3K4me3", "ENCODE H3K9me3", "ENCODE H3K36me3", "ENCODE DNase"   

# same order as bam list
names = colnames(count_cut)[-c(1:3)]
counts_copy = count_cut
counts_copy = counts_copy[,4:length(counts_copy)] %>% as.matrix() %>% preprocessCore::normalize.quantiles() %>% round() %>% cor(method = "pearson")
colnames(counts_copy) = names
rownames(counts_copy) = names

counts_copy[counts_copy <= 0] = 0
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}
# round the counts
counts_rounded = counts_copy %>% round(2)
# assign colour based on epigenetic mark
colNames = colnames(counts_rounded)
ColColors <- ifelse(grepl("H3K27ac", colNames), "skyblue1", "#127688")
# plot
heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
          cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
          lhei = c(1, 5), lwid = c(1, 4), margins = c(15,15),
          ColSideColors = ColColors)

# # save
# svglite(paste0(workdir,"/correlation/heatmap_encodeh3k27ac_correlation.svg"), width = 8, height = 8)
# heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
#           cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
#           lhei = c(1, 5), lwid = c(1, 4), margins = c(15,15),
#           ColSideColors = ColColors)
# dev.off()
```

## H3K27ac ENCODE ranges (main figure)
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}
markName="H3K27ac_ENCFF044JNJ"
counts = read.csv(paste0(workdir,"/correlation/", markName, "_sample_correlations.txt"), sep = "\t", header = FALSE)
# remove peak calling columns
counts = counts[-c(4:10)]
# rename columns
colnames(counts) = c("chr", "start", "end", "H3K27ac ab177178 1", "H3K27ac ab177178 2",
                     "H3K27me3 ab9733 1", "H3K27me3 ab9733 2", "H3K27ac ab4729 1", "H3K27ac ab4729 2",
                     "H3K27ac Diagenode 1", "H3K27ac Diagenode 2", 
                     "H3K27ac ab177178 HDup",
                     "H3K27ac ActiveMotif HDup",
                     "ActiveMotif_H3K27ac",
                     "H3K27ac ab4729 HDup","H3K27ac Diagenode 100x HDup","H3K27ac Diagenode 50x HDup", "H3K27me3 ab9733 HDup", 
                     "H3K27ac Kaya-Okur 1", "H3K27ac Kaya-Okur 2", "H3K27me3 Kaya-Okur 1", "H3K27me3 Kaya-Okur 2", 
                     "H3K27ac Diagenode 50x TSA", "H3K27me3 scCT", 
                     "H3K27ac Meers CnR","H3K27me3 Meers CnR",
                     "ENCODE H3K27ac", "ENCODE H3K27me3", "ENCODE H3K4me1", "ENCODE H3K4me3", "ENCODE H3K9ac", 
                     "ENCODE H3K9me3", "ENCODE H3K36me3","ENCODE DNase")

count_cut <- counts[,-c(12,13,14,15,16,17,18,23,24,25,26,29,30,31,32,33,34)]     # remove "ActiveMotif_H3K27ac" , "H3K27ac-diag50x-TSA", "H3K27me3-scCT",# "ENCODE H3K4me1","ENCODE H3K4me3", "ENCODE H3K9me3", "ENCODE H3K36me3", "ENCODE DNase"
# "H3K27ac ab177178 HDup", "H3K27ac ActiveMotif HDup", "H3K27ac ab4729 HDup", "H3K27ac Diagenode 100x HDup" ,"H3K27ac Diagenode 50x HDup" ,
# "H3K27me3 ab9733 HDup",  "H3K27ac Meers CnR", "H3K27me3 Meers CnR"

# same order as bam list
names = colnames(count_cut)[-c(1:3)]
counts_copy = count_cut
counts_copy = counts_copy[,4:length(counts_copy)] %>% as.matrix() %>% preprocessCore::normalize.quantiles() %>% round() %>% cor(method = "pearson")
colnames(counts_copy) = names
rownames(counts_copy) = names

counts_copy[counts_copy <= 0] = 0
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=6, fig.height=6}
# round the counts
counts_rounded = counts_copy %>% round(2)
# assign colour based on epigenetic mark
colNames = colnames(counts_rounded)
ColColors <- ifelse(grepl("H3K27ac", colNames), "skyblue1", "#127688")
# plot
heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
          cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
          lhei = c(1, 3.5), lwid = c(1, 3.5), margins = c(12,12),
          ColSideColors = ColColors)

# save
# svglite(paste0(workdir,"/correlation/heatmap_encodeh3k27ac_correlation.mainfig.svg"), width = 6, height = 6)
# heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
#           cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
#           lhei = c(1, 3.5), lwid = c(1, 3.5), margins = c(12,12),
#           ColSideColors = ColColors)
# dev.off()
```

## H3K27me3 ENCODE ranges
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=7.5}
markName="H3K27me3_ENCFF000BXB"
counts = read.csv(paste0(workdir,"/correlation/", markName, "_sample_correlations.txt"), sep = "\t", header = FALSE)
# remove peak calling columns
counts = counts[-c(4:9)]
# rename columns
colnames(counts) = c("chr", "start", "end", "H3K27ac ab177178 1", "H3K27ac ab177178 2",
                     "H3K27me3 ab9733 1", "H3K27me3 ab9733 2", "H3K27ac ab4729 1", "H3K27ac ab4729 2",
                     "H3K27ac Diagenode 1", "H3K27ac Diagenode 2", 
                     "H3K27ac ab177178 HDup", "H3K27ac ActiveMotif HDup", "H3K27ac ab4729 HDup",
                     "H3K27ac Diagenode 100x HDup","H3K27ac Diagenode 50x HDup", "H3K27me3 ab9733 HDup", 
                     "H3K27ac Kaya-Okur 1", "H3K27ac Kaya-Okur 2", "H3K27me3 Kaya-Okur 1", "H3K27me3 Kaya-Okur 2", 
                     "H3K27ac Meers CnR","H3K27me3 Meers CnR",
                     "ENCODE H3K27ac", "ENCODE H3K27me3", "ENCODE H3K4me1", "ENCODE H3K4me3", "ENCODE H3K9ac", 
                     "ENCODE H3K9me3", "ENCODE H3K36me3","ENCODE DNase")
# remove comparisons not used
count_cut = counts[-c(26:31)] # additional ENCODE

# same order as bam list
names = colnames(count_cut)[-c(1:3)]
counts_copy = count_cut
counts_copy = counts_copy[,4:length(counts_copy)] %>% as.matrix() %>% preprocessCore::normalize.quantiles() %>% round() %>% cor(method = "pearson")
colnames(counts_copy) = names
rownames(counts_copy) = names

counts_copy[counts_copy <= 0] = 0
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}
# round the counts
counts_rounded = counts_copy %>% round(2)
# assign colour based on epigenetic mark
colNames = colnames(counts_rounded)
ColColors <- ifelse(grepl("H3K27ac", colNames), "skyblue1", "#127688")
# plot
heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
          cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
          lhei = c(1, 5), lwid = c(1, 4), margins = c(15,15),
          ColSideColors = ColColors)

# # save
# svglite(paste0(workdir,"/correlation/heatmap_encodeh3kme3_correlation.svg"), width = 8, height = 8)
# heatmap.2(x = counts_rounded, col = "plasma", trace = "none", density.info = "none", 
#           cexRow = 1, cexCol = 1, notecex = 1, notecol = "black", 
#           lhei = c(1, 5), lwid = c(1, 4), margins = c(15,15),
#           ColSideColors = ColColors)
# dev.off()
```



# Peak correlation

Description: Select peak lists from SEACR, MACS2 in internal and external dataset, 
as well as ENCODE ChIP-seq H3K27ac and H3K27me3. Internal sample peaks included 
only for high quality replicates.

```{r}
# load ENCODE ChIP peaks
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")
```

```{r}
# all peak sets
peakTest =  c(peakList, ext_peakList, 'ENCODE H3K27ac'=ENCODE_H3K27ac, 'ENCODE H3K27me3'=ENCODE_H3K27me3) # internal sample peaks, external sample peaks, and ENCODE peaks

# optional: specify and exclude peak sets with duplicates
withDup_setNames = grep("withDup", names(peakTest), value=TRUE)
keepNames = setdiff(names(peakTest), withDup_setNames)
peakTest = peakTest[keepNames]

# specify names by peak caller
SEACR_setNames = grep("SEACR", names(peakTest), value=TRUE)
MACS2_setNames = grep("MACS2", names(peakTest), value=TRUE)
ENCODE_setNames = grep("ENCODE", names(peakTest), value=TRUE)

DBA_SEACR = NULL
DBA_MACS2 = NULL
DBA_mixed = NULL

# define test set as sample 
testSet <- c( peakTest[SEACR_setNames], peakTest[MACS2_setNames] )
# specify sample labels -- when using only rmDup
df=data.frame(PeakSet=names(testSet))
df=merge(df, ext_df, by="PeakSet")
df=df[match(names(testSet), df$PeakSet),]
df$PeakSetLabel <- paste0(df$SampleLabel," (", df$Caller, ")")

# edit labels
df$PeakSetLabel <- c( "H3K27ac ab177178 1 (SEACR)","H3K27ac ab177178 2 (SEACR)","H3K27ac ab4729 1 (SEACR)","H3K27ac ab4729 2 (SEACR)",
                      "H3K27ac Diagenode 1 (SEACR)","H3K27ac Diagenode 2 (SEACR)","H3K27me3 ab9733 1 (SEACR)","H3K27me3 ab9733 2 (SEACR)",
                      "H3K27ac Kaya-Okur (SEACR)","H3K27ac Kaya-Okur (SEACR)","H3K27me3 Kaya-Okur (SEACR)", "H3K27me3 Kaya-Okur (SEACR)",
                      "H3K27ac ab177178 1 (MACS2)","H3K27ac ab177178 2 (MACS2)","H3K27ac ab4729 1 (MACS2)","H3K27ac ab4729 2 (MACS2)",
                      "H3K27ac Diagenode 1 (MACS2)","H3K27ac Diagenode 2 (MACS2)","H3K27me3 ab9733 1 (MACS2)","H3K27me3 ab9733 2 (MACS2)",
                      "H3K27ac Kaya-Okur (MACS2)","H3K27ac Kaya-Okur (MACS2)","H3K27me3 Kaya-Okur (MACS2)", "H3K27me3 Kaya-Okur (MACS2)" )

# define test set as sample and ENCODE ChIP peaks
testSet <- c( peakTest[SEACR_setNames], peakTest[MACS2_setNames],  peakTest[ENCODE_setNames])
names(testSet) <- c(df$PeakSetLabel, ENCODE_setNames)

  
for(i in 1:length(testSet)){
  
  sampID = names(testSet)[[i]]
  peak.caller = str_extract(sampID, "SEACR|MACS2|ENCODE")
  
  DBA_mixed = dba.peakset(DBA = DBA_mixed, 
                           peaks = data.frame(testSet[[i]]), 
                           peak.caller = peak.caller,
                           sampID = names(testSet)[i] # names(testSet)[i] or sampleNames[i]
                           )
}


# define test set as sample SEACR and ENCODE ChIP peaks
testSet <- c( peakTest[SEACR_setNames], peakTest[ENCODE_setNames] )
for(i in 1:length(testSet)){
   DBA_SEACR = dba.peakset(DBA = DBA_SEACR, peaks = data.frame(testSet[[i]]), sampID = names(testSet)[i])
}
# define test set as sample MACS2 and ENCODE ChIP peaks
testSet <- c( peakTest[MACS2_setNames], peakTest[ENCODE_setNames] )
for(i in 1:length(testSet)){
   DBA_MACS2 = dba.peakset(DBA = DBA_MACS2, peaks = data.frame(testSet[[i]]), sampID = names(testSet)[i])
}
```

## All peaks
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=15}
DiffBind::dba.plotHeatmap(DBA_mixed, lhei = c(1,5), lwid = c(1,5), keysize = 0.75, 
                          cexRow = 1.25, cexCol = 1.25, margin = 40, colScheme="BuPu",
                           colSideCols = c("orange2","yellow","grey" ),
                           ColAttributes=DBA_CALLER)

# # save
# svglite(paste0(workdir,"/correlation/heatmap_allpeak_correlation.svg"), width = 11, height = 11)
# DiffBind::dba.plotHeatmap(DBA_mixed, lhei = c(1,5.5), lwid = c(1,5.5), keysize = 0.75, 
#                           cexRow = 1.25, cexCol = 1.25, margin = 20, colScheme="BuPu",
#                            colSideCols = c("orange2","yellow","grey" ),
#                            ColAttributes=DBA_CALLER)
# dev.off()
```

## SEACR
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=15}
DiffBind::dba.plotHeatmap(DBA_SEACR, lhei = c(1,5), lwid = c(1,5), keysize = 0.75, cexRow = 1.75, cexCol = 1.75, margin = 40,colScheme="Blues")
```

## MACS2
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=15}
DiffBind::dba.plotHeatmap(DBA_MACS2, lhei = c(1,5), lwid = c(1,5), keysize = 0.75, cexRow = 1.75, cexCol = 1.75, margin = 40,colScheme="Blues")
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=11, fig.height=11}
# Separating peak sets by epigenetic mark
# all peak sets
peakTest =  c(peakList, 
              ext_peakList, 
              ENCODE_H3K27ac=ENCODE_H3K27ac, 
              ENCODE_H3K27me3=ENCODE_H3K27me3) # internal sample peaks, external sample peaks, and ENCODE peaks

# optional: specify and exclude peak sets with duplicates
withDup_setNames = grep("withDup", names(peakTest), value=TRUE)
keepNames = setdiff(names(peakTest), withDup_setNames)
peakTest = peakTest[keepNames]

## editing peak set names
df=data.frame(PeakSet=names(peakTest))
df=merge(df, ext_df, by="PeakSet")
df=df[match(names(peakTest), df$PeakSet),] %>% na.omit ## optional: na.omit() the last 2 which are ENCODE_H3K27ac and ENCODE_H3K27me3
df$PeakSetLabel <- paste0(df$SampleLabel," (", df$Caller, ")")
names(peakTest) <- c (df$PeakSetLabel , "ENCODE_H3K27ac", "ENCODE_H3K27me")


# specify names by peak caller
H3K27ac_setNames = grep("H3K27ac", names(peakTest), value=TRUE)
H3K27me3_setNames = grep("H3K27me3", names(peakTest), value=TRUE)

DBA_H3K27ac = NULL
DBA_H3K27me3 = NULL

# define test set as H3K27ac sample and ENCODE ChIP peaks
testSet <- peakTest[H3K27ac_setNames]
for(i in 1:length(testSet)){
  
  setname = names(testSet)[[i]]
  sampID = setname
  peak.caller = str_extract(setname, "SEACR|MACS2|ENCODE")
  if (is.na(peak.caller)) {peak.caller="other"}
  factor =  str_extract(setname, "ab[0-9]{3,4}|diag|ENCODE") 
  if (is.na(factor)) {factor="other"}
  
  DBA_H3K27ac = dba.peakset(DBA = DBA_H3K27ac, 
                           peaks = data.frame(testSet[[i]]), 
                           sampID = sampID,
                           peak.caller = peak.caller
                           )
}

# define test set as H3K27me3 sample and ENCODE ChIP peaks
testSet <- peakTest[H3K27me3_setNames]
for(i in 1:length(testSet)){
   DBA_H3K27me3 = dba.peakset(DBA = DBA_H3K27me3, peaks = data.frame(testSet[[i]]), 
                           sampID = names(testSet)[i] # names(testSet)[i] or sampleNames[i]
                           )
}

```

### H3K27ac
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=11, fig.height=11}
# To summarise: For occupancy analysis, dba.peakset() generates a merged consenus 
# peak set for all samples, and a score is calculated for each sample using its peak 
# length. This is normalised across each peak into a z-score (a deviation from the mean)
# and this is correlated pairwise between samples to derive Pearsons correlations
# across all of the peaks.

DBA_H3K27ac_test = NULL
testSet <- peakTest[H3K27ac_setNames]
for(i in 1:length(testSet)){
  
  setname = names(testSet)[[i]]
  sampID = setname
  peak.caller = str_extract(setname, "SEACR|MACS2|ENCODE")
  if (is.na(peak.caller)) {factor="other"}
  factor =  str_extract(setname, "ab[0-9]{3,4}|diag|ENCODE") 
  if (is.na(factor)) {factor="other"}
  
  DBA_H3K27ac_test = dba.peakset(DBA = DBA_H3K27ac_test, 
                           peaks = data.frame(testSet[[i]]), 
                           sampID = sampID,
                           peak.caller = peak.caller
                           )
}

DiffBind::dba.plotHeatmap(DBA_H3K27ac_test, lhei = c(1,5), lwid = c(1,5), 
                          keysize = 0.75, 
                          cexRow = 1.25, 
                          cexCol = 1.25, 
                          margin = 40, 
                          colScheme="BuPu" ,
                          colSideCols = c("orange2","yellow","grey" ),
                          ColAttributes=DBA_CALLER
                          )

```

#### H3K27ac PCA
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=10}
dba.plotPCA(DBA_H3K27ac_test, attributes=c(DBA_ID))
```

### H3K27ac
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=11, fig.height=11}
DiffBind::dba.plotHeatmap(DBA_H3K27ac, lhei = c(1,5), lwid = c(1,5), keysize = 0.75, cexRow = 1.25, cexCol = 1.25, margin = 40, colScheme="BuPu")

# svglite(paste0(workdir,"/correlation/heatmap_h3k27ac_correlation.svg"), width = 10, height = 10)
# 
# DiffBind::dba.plotHeatmap(DBA_H3K27ac, lhei = c(1,5), lwid = c(1,5), 
#                           keysize = 0.75, 
#                           cexRow = 1.25, 
#                           cexCol = 1.25, 
#                           margin = 40, 
#                           colScheme="BuPu" ,
#                           colSideCols = c("orange2","yellow","grey" ),
#                           ColAttributes=DBA_CALLER
#                           )
# 
# dev.off()
```

### H3K27me3
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=12, fig.height=12}
DiffBind::dba.plotHeatmap(DBA_H3K27me3, lhei = c(1,5), lwid = c(1,5), keysize = 0.75, cexRow = 1.25, cexCol = 1.25, margin = 40, colScheme="BuPu")
```


# Fingerprint plot
Quantifying genome-wide localisation of CUT&Tag fragments by counting reads in bins and ranking from lowest to highest coverage. A more localised signal, indicated by smaller area under the curve, suggests higher signal to nose ratio.

```{r, fig.width=15, fig.height=6, warning=FALSE}
# Read in counts data
ac_counts = read.csv(paste0(workdir, "/heatmap/cumulative_read_enrichment/H3K27ac_fingerprint_2M.tab"), 
                     header = FALSE, sep = "\t", stringsAsFactors = FALSE)
me_counts = read.csv(paste0(workdir, "/heatmap/cumulative_read_enrichment/H3K27me3_fingerprint_2M.tab"),
                     header = FALSE, sep = "\t", stringsAsFactors = FALSE)

# Rename
ac_colnames = ac_counts[2,] %>% gsub("'", "", .)
colnames(ac_counts) = ac_colnames
ac_counts = ac_counts[-c(1,2),]

me_colnames = me_counts[2,] %>% gsub("'", "", .)
colnames(me_counts) = me_colnames
me_counts = me_counts[-c(1,2),]

# Order H3K27ac
ac_counts_ordered = data.frame("Rank" = 1:nrow(ac_counts)/nrow(ac_counts))

for(i in 1:length(ac_counts)){
  ac_counts[,i] = as.numeric(ac_counts[,i])
  ordered_col = ac_counts[,i][order(ac_counts[,i], decreasing = FALSE)]
  cumsum_ordered_col = cumsum(ordered_col)
  cumsum_ordered_col = cumsum_ordered_col / max(cumsum_ordered_col)
  ac_counts_ordered = cbind(ac_counts_ordered, as.data.frame(cumsum_ordered_col))
}
colnames(ac_counts_ordered) = c("Rank", ac_colnames)
ac_counts_cumsum_melt = melt(ac_counts_ordered, id.vars = c("Rank"))
ac_counts_cumsum_melt = ac_counts_cumsum_melt %>% mutate(Bold = ifelse(variable == "ENCODE_H3K27ac", T, F))


# Order H3K27me3
me_counts_ordered = data.frame("Rank" = 1:nrow(me_counts)/nrow(me_counts))

for(i in 1:length(me_counts)){
  me_counts[,i] = as.numeric(me_counts[,i])
  ordered_col = me_counts[,i][order(me_counts[,i], decreasing = FALSE)]
  cumsum_ordered_col = cumsum(ordered_col)
  cumsum_ordered_col = cumsum_ordered_col / max(cumsum_ordered_col)
  me_counts_ordered = cbind(me_counts_ordered, as.data.frame(cumsum_ordered_col))
}

colnames(me_counts_ordered) = c("Rank", me_colnames)
me_counts_cumsum_melt = melt(me_counts_ordered, id.vars = "Rank")
me_counts_cumsum_melt = me_counts_cumsum_melt %>% mutate(Bold = ifelse(variable == "ENCODE_H3K27me3", T, F))


# Plot
ac_counts_cumsum_melt$Mark = "H3K27ac"
me_counts_cumsum_melt$Mark = "H3K27me3"
combined_cumsum = ac_counts_cumsum_melt %>% rbind(me_counts_cumsum_melt)

combined_cumsum_plot = ggplot(combined_cumsum, aes(Rank, value)) +  
  geom_line(aes(col = variable, linewidth=Bold)) +
  theme_bw() +
  ylab("Fraction w.r.t. bin with highest coverage") +
  xlab("Rank") +
  theme(legend.title = element_blank()) +
  theme(legend.text = element_text(size = 16)) +
  theme(legend.position =  "right") +
  theme(legend.background = element_rect(size = 0.5, linetype = "solid", colour = "grey")) +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  scale_colour_manual(name = "",
                      labels = c(ac_colnames, me_colnames),
                      values = c("#000059", "steelblue3",
                                 "#981EA3", "#c178c7", 
                                 "#8e0039" , "#cc0052",
                                 "#ed6851","#f4a496",
                                 "#fba13a",
                                 "#000059", "steelblue3",
                                 "#981EA3", "#c178c7", 
                                 "#fba13a")) +
  scale_linewidth_manual(values=c(1,2.2)) +
  guides(linewidth = FALSE) +
  guides(colour = guide_legend(override.aes = list(linewidth = 6))) +
  xlim(0.5, 1)

# facet by epigenetic mark
plot = combined_cumsum_plot + facet_wrap(~Mark) + 
        theme(strip.text.x = element_text(size = 20)) + # edit facet heading size
        theme(plot.margin = unit(c(1,2,1,2), "cm"))
plot

# save plot
# ggsave(path = paste0(rootdir,"/heatmap/cumulative_read_enrichment/"),
#         filename = "fingerprint_plot_combined.svg",
#         dpi = 1200, width = 14.5,
#         height = 5.5, units ="in",
#         plot=plot)
```


# Downsampled H3K27ac CT FRiPs
Peak calling was repeated after downsampling alignment files to defined total number of fragments with MACS2. Fragments in peaks (FRiP) were calculated for these new peak sets.

```{r, fig.width=20, fig.height=20}

# sampleList <- c("IGF128036","IGF128037","IGF128040","IGF128041","IGF128042","IGF128043")
# countList <- c("0.5M", "1M", "1.5M", "2M")
# callerList = c("MACS2", "SEACR")
# dup="rmDup"
# 
# ## CT sample peaks ## 
# inPeakData_df = c()
# for (sample in sampleList) {
#   
#   for (count in countList) {
#     ## define sample bam file path
#     bamFile = paste0(temp_dir, "/alignment/bam/downsample/", sample,"_", dup,"_",count,".mapped.bam")
# 
#       for (caller in callerList) {
#         
#         # define peak file path
#         if (caller == "SEACR") {suffix = "rmDup_individual_seacr_top0.01_peaks.stringent.bed"}
#         if (caller == "MACS2") {suffix = "rmDup_q1e-5_peaks.narrowPeak"}
#         
#         # announce process
#         print(paste("Calculating FRiP for", sample, count, caller))
#         
#         # read in peak file
#         peak_unfilt = ChIPseeker::readPeakFile(paste0(temp_dir, "/peakCalling/", caller, "/",sample,"_", count, "_",suffix), as = "GRanges")
#         # filter out peaks in blacklist regions and irregular chromosomes
#         peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
#         
#         fragment_counts = chromVAR::getCounts(bamFile, peak_filt, paired = TRUE, by_rg = FALSE, format = "bam")
#         inPeakN = counts(fragment_counts)[,1] %>% sum
#         inPeakData_df = rbind(inPeakData_df, data.frame(Sample = paste0(sample,"_",count,"_",caller), inPeakN = inPeakN))
#         
#   }
#   } 
# }
# ## End of CT sample peaks ## 
# 
# 
# ## ENCODE peaks ##
# for (count in countList) {
#   # get peaks
#   peak_filt = ChIPseeker::readPeakFile(paste0(storedir, "/FRiPs_vs_ENCODE/peaks/ENCODE_H3K27ac_", count, ".bed"), as = "GRanges")
#   # define bam file
#   bamFile=paste0(storedir,"/FRiPs_vs_ENCODE/bam/ENCODE_H3K27ac_",count,"_bowtie2_rmDup.mapped.bam")
#   fragment_counts = chromVAR::getCounts(bamFile, peak_filt, paired = FALSE, by_rg = FALSE, format = "bam") # note: paired = FALSE
#   inPeakN = counts(fragment_counts)[,1] %>% sum
#   inPeakData_df = rbind(inPeakData_df, data.frame(Sample = paste0("ENCODE_H3K27ac_",count), inPeakN = inPeakN))
# }
# ## End of ENCODE peaks ##


# save
# write.csv(inPeakData_df, paste0(workdir,"/alignment/frip/inpeak_fragment_counts_downsample.csv"))
```

## By sample
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=15, fig.height=8}
# set caller
caller="MACS2" # SEACR or MACS2

# read in frip score
inPeakData_df = read.csv(paste0(workdir,"/alignment/frip/inpeak_fragment_counts_downsample.csv"), row.names = 1)

## CT sample
ct_samples=grep("IGF",inPeakData_df$Sample, value=T)
ct_inPeakData_df = inPeakData_df[inPeakData_df$Sample %in% ct_samples, ]
ct_inPeakData_df$SampleName = str_split_fixed(ct_inPeakData_df$Sample, "_", n=3)[,1]
ct_inPeakData_df$Count = str_split_fixed(ct_inPeakData_df$Sample, "_", n=3)[,2]
ct_inPeakData_df$Caller = str_split_fixed(ct_inPeakData_df$Sample, "_", n=3)[,3]
# add antibody label
ct_inPeakData_df <- merge(ct_inPeakData_df, unique(ext_df[,c("Sample","SampleLabel")]), by.x = "SampleName", by.y="Sample")
  # select peak caller for main figure
ct_inPeakData_df = ct_inPeakData_df[ct_inPeakData_df$Caller == caller,]

## ENCODE
encode_samples=grep("ENCODE",inPeakData_df$Sample, value=T)
enc_inPeakData_df = inPeakData_df[inPeakData_df$Sample %in% encode_samples, ]
enc_inPeakData_df$SampleName = paste0(str_split_fixed(enc_inPeakData_df$Sample, "_", n=3)[,1],"_", str_split_fixed(enc_inPeakData_df$Sample, "_", n=3)[,2])
enc_inPeakData_df$Count = str_split_fixed(enc_inPeakData_df$Sample, "_", n=3)[,3]
enc_inPeakData_df$Caller = "ENCODE"
enc_inPeakData_df$SampleLabel <- "ENCODE_H3K27ac"

## Combine CT sample and ENCODE
plotdata = rbind(ct_inPeakData_df, enc_inPeakData_df)
plotdata$FragN = ifelse(plotdata$Count == "0.5M", 500000,
                             ifelse(plotdata$Count == "1M", 1000000 ,
                             ifelse(plotdata$Count == "1.5M", 1500000 ,
                             ifelse(plotdata$Count == "2M", 2000000 , NA))))
plotdata$frip = plotdata$inPeakN / plotdata$FragN * 100


# Add max fragment count FRiP scores
inPeakData_df = read.csv(paste0(workdir,"/alignment/frip/inpeak_fragment_counts.csv"), row.names=1)
## CT sample
ct_samples=grep("IGF",inPeakData_df$PeakSet, value=T)
ct_inPeakData_df = inPeakData_df[inPeakData_df$PeakSet %in% ct_samples, ]
ct_inPeakData_df$SampleName = str_split_fixed(ct_inPeakData_df$PeakSet, "_", n=3)[,1]
ct_inPeakData_df$Caller = str_split_fixed(ct_inPeakData_df$PeakSet, "_", n=3)[,2]
ct_inPeakData_df$Dup = str_split_fixed(ct_inPeakData_df$PeakSet, "_", n=3)[,3]
ct_inPeakData_df$Count = "Max"
# filter for rmDup; drop column
ct_inPeakData_df = ct_inPeakData_df[ct_inPeakData_df$Dup == "rmDup",]
ct_inPeakData_df$Dup = NULL
# add antibody label 
sel_ext_df = unique(ext_df[ext_df$EpMark == "H3K27ac", c("Sample","SampleLabel")])
ct_inPeakData_df <- merge(ct_inPeakData_df, sel_ext_df, by.x=c("SampleName"), by.y=c("Sample"))
# add fragments mapped
ct_inPeakData_df <- merge(ct_inPeakData_df, alignDupSummary[,c("SampleLabel", "UniqueFragNum")], by="SampleLabel")
# calculate frip score
ct_inPeakData_df$frip = ct_inPeakData_df$inPeakN / ct_inPeakData_df$UniqueFragNum * 100
 # select peak caller for main figure
 ct_inPeakData_df = ct_inPeakData_df[ct_inPeakData_df$Caller == caller,]
## ENCODE H3K27ac
 ### this file contains only CT fragments mapping to ENCODE peaks - not ENCODE reads mapping to ENCODE peaks
 ### taking values previously derived
enc_inPeakData_df <- data.frame(Sample = "ENCODE_H3K27ac",SampleName="ENCODE_H3K27ac", 
                                SampleLabel="ENCODE_H3K27ac", inPeakN=4140041, FragN=9770603, 
                                Count="Max", Caller="ENCODE")
enc_inPeakData_df$frip <- enc_inPeakData_df$inPeakN / enc_inPeakData_df$FragN * 100

# combine downsampled and full read set
cols<-intersect(intersect(colnames(enc_inPeakData_df), colnames(ct_inPeakData_df)), colnames(plotdata))
plotdata = rbind(plotdata[cols], ct_inPeakData_df[cols], enc_inPeakData_df[cols])


frip_plot = ggplot(plotdata, aes(Count, frip, fill=SampleLabel)) +
geom_bar(aes(fill = SampleLabel), width = 0.7, position = position_dodge(width = 0.75), 
         stat = "identity",alpha = 0.7) +
  theme_bw(base_size = 25) + 
  theme(plot.margin = unit(c(0.5,0.5,0.5,1), "cm")) +
  ylim(0, 60) +
  ylab("% fragments") +
  xlab("Read depth (millions)") +
  ggtitle("Downsampled Fragments in H3K27ac Peaks") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  scale_fill_viridis(name = "", discrete = TRUE, begin = 0.1, end = 0.7, option = "viridis") 

frip_plot

# # save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_frip_score.pdf",
#         dpi = 1200, width = 20.0,
#         height = 20.0, units ="in",x
#         plot=frip_plot)
```

## Average over replicates
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=12, fig.height=8}
# take an average between replicates and plot average with error bar
plotdata$Ab <- ifelse( str_split_fixed(plotdata$SampleLabel, "-", n=3)[,2] != "", 
                       paste0( str_split_fixed(plotdata$SampleLabel, "-", n=3)[,1], "-", str_split_fixed(plotdata$SampleLabel, "-", n=3)[,2]),
                       str_split_fixed(plotdata$SampleLabel, "-", n=3)[,1])
plotdata = plotdata %>% dplyr::group_by(Ab, Caller, Count) %>% dplyr::mutate(avg.frip = mean(frip), sd = sd(frip))

# set order for fragemnt counts
plotdata$Count <- factor(plotdata$Count, levels=c("0.5M","1M","1.5M","2M", "Max"))
# remove 'M' from count group names
plotdata$Count <- ifelse(plotdata$Count != "Max", gsub("M","",plotdata$Count), "Max")

# edit antibody names
plotdata$Ab[plotdata$Ab == "H3K27ac-ab177"] <- "ab177"
plotdata$Ab[plotdata$Ab == "H3K27ac-ab4729"] <- "ab4729"
plotdata$Ab[plotdata$Ab == "H3K27ac-diag"] <- "diag"
plotdata$Ab[plotdata$Ab == "ENCODE_H3K27ac"] <- "ENCODE"
# set order for fragemnt counts
plotdata$Ab <- factor(plotdata$Ab, levels=c("ab177","ab4729","diag","ENCODE"))

frip_plot = ggplot(plotdata, aes(Count, avg.frip, fill=Ab)) + 
  geom_bar(aes(fill = Ab), width = 0.7, position = position_dodge(width = 0.75), stat = "identity") +
  geom_errorbar(aes(ymin = avg.frip-sd, ymax = avg.frip+sd), data = plotdata,  width = 0.5, position = position_dodge(width = 0.75)) +
  geom_point(aes(y = frip), position =  position_dodge(width = 0.75)) +
  theme_bw(base_size = 25) + 
  theme(plot.margin = unit(c(0.5,0.5,0.5,1), "cm")) +
  ylim(0, 50) +
  ylab("% fragments") +
  xlab("Read depth (millions)") +
  ggtitle("Downsampled Fragments in H3K27ac Peaks") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  scale_fill_viridis(name="", discrete = TRUE, begin = 0.1, end = 0.7, option = "magma", alpha = 0.55)

frip_plot

# # save plot
# ggsave(path = paste0(workdir,"/alignment/frip"),
#         filename = "barplot_frip_score.svg",
#         dpi = 1200, width = 12.0,
#         height = 7.0, units ="in",
#         plot=frip_plot)
```

# Functional enrichments
## ChIPseeker
### SEACR
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=6}
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# SEACR + ENCODE
seacrNames = c( grep("SEACR", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakSEACR = peakTest[seacrNames]
# new names for plot context
namedf = data.frame(PeakSet=names(peakSEACR))
namedf = merge( namedf, ext_df, by="PeakSet" )
names(peakSEACR) = c( na.omit(namedf$SampleLabel[match(names(peakSEACR), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakSEACR = peakSEACR[order(names(peakSEACR))]

peakAnnoList = lapply(peakSEACR, annotatePeak, TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene, tssRegion = c(-3000, 3000), verbose = FALSE)
annobar = ChIPseeker::plotAnnoBar(peakAnnoList)
annobar
# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChIPseeker_annotation_barplot_SEACR_rmDup.svg",
#         dpi = 1200, width = 7.0,
#         height = 4.0, units ="in")
```

### MACS2
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=8, fig.height=6}
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# MACS2 + ENCODE
macs2Names = c( grep("MACS2", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakMACS2 = peakTest[macs2Names]
# new names for plot context
namedf = data.frame(PeakSet=names(peakMACS2))
namedf = merge( namedf, ext_df, by="PeakSet" )
names(peakMACS2) = c( na.omit(namedf$SampleLabel[match(names(peakMACS2), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakMACS2 = peakMACS2[order(names(peakMACS2))]

peakAnnoList = lapply(peakMACS2, annotatePeak, TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene, tssRegion = c(-3000, 3000), verbose = FALSE)
annobar = ChIPseeker::plotAnnoBar(peakAnnoList)
annobar

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChIPseeker_annotation_barplot_MACS2_rmDup.svg",
#         dpi = 1200, width = 7.0,
#         height = 4.0, units ="in")
```

## ChromHMM
### SEACR
```{r, fig.height=6,fig.width=8, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# SEACR + ENCODE
seacrNames = c( grep("SEACR", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakSEACR = peakTest[seacrNames]
# new names for plot context
namedf = data.frame(PeakSet=names(peakSEACR))
namedf = merge( namedf, ext_df, by="PeakSet" )
names(peakSEACR) = c( na.omit(namedf$SampleLabel[match(names(peakSEACR), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakSEACR = peakSEACR[order(names(peakSEACR))]



# run ChromHMM
chrHMM_url = "http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeBroadHmm/wgEncodeBroadHmmK562HMM.bed.gz"
chrHMM = genomation::readBed(chrHMM_url)
chrHMM_list = GenomicRanges::split(chrHMM, chrHMM$name, drop = TRUE) 

chrHMM_names = c("Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]", "Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]")
names(chrHMM_list) = chrHMM_names


annotation = genomation::annotateWithFeatures(GenomicRanges::GRangesList(peakSEACR), chrHMM_list)
matrix = genomation::heatTargetAnnotation(annotation, plot = FALSE, precedence = FALSE)

rownames(matrix) = names(peakSEACR)
colnames(matrix) = chrHMM_names
matrix_melt = melt(matrix)
colnames(matrix_melt) = c("Sample", "State", "% Peaks")

# order chromatin state based on number
matrix_melt$State <- factor(matrix_melt$State,levels=c("Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]","Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]"))

ggplot(matrix_melt) +
  theme_bw() +
  geom_tile(aes(x = Sample, y = State, fill = `% Peaks`)) +
  scale_fill_viridis(option = "plasma", limits=c(0,80)) +
  ggpubr::rotate_x_text(angle = 45) +
  theme(text = element_text(size = 15)) +
  # theme(legend.key.size = unit(1, "cm")) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  ggtitle("SEACR") +
  xlab("") +
  ylab("ChromHMM State")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChromHMM_annotation_heatmap_SEACR_rmDup.svg",
#         dpi = 1200, width = 8.0,
#         height = 6, units ="in")
```

### MACS2
```{r, fig.height=6,fig.width=8, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# MACS2 + ENCODE
macs2Names = c( grep("MACS2", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakMACS2 = peakTest[macs2Names]
# new names for plot context
namedf = data.frame(PeakSet=names(peakMACS2))
namedf = merge( namedf, ext_df, by="PeakSet" )
names(peakMACS2) = c( na.omit(namedf$SampleLabel[match(names(peakMACS2), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakMACS2 = peakMACS2[order(names(peakMACS2))]

# run ChromHMM
chrHMM_url = "http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeBroadHmm/wgEncodeBroadHmmK562HMM.bed.gz"
chrHMM = genomation::readBed(chrHMM_url)
chrHMM_list = GenomicRanges::split(chrHMM, chrHMM$name, drop = TRUE) 

chrHMM_names = c("Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]", "Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]")
names(chrHMM_list) = chrHMM_names


annotation = genomation::annotateWithFeatures(GenomicRanges::GRangesList(peakMACS2), chrHMM_list)
matrix = genomation::heatTargetAnnotation(annotation, plot = FALSE, precedence = FALSE)

rownames(matrix) = names(peakMACS2)
colnames(matrix) = chrHMM_names
matrix_melt = melt(matrix)
colnames(matrix_melt) = c("Sample", "State", "% Peaks")

# order chromatin state based on number
matrix_melt$State <- factor(matrix_melt$State,levels=c("Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]","Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]"))

ggplot(matrix_melt) +
  theme_bw() +
  geom_tile(aes(x = Sample, y = State, fill = `% Peaks`)) +
  scale_fill_viridis(option = "plasma", limits=c(0,80)) +
  ggpubr::rotate_x_text(angle = 45) +
  theme(text = element_text(size = 15)) +
  # theme(legend.key.size = unit(1, "cm")) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  ggtitle("MACS2") +
  xlab("") +
  ylab("Chromatin State")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChromHMM_annotation_heatmap_MACS2_rmDup.svg",
#         dpi = 1200, width = 8.0,
#         height = 6, units ="in")
```


### Duplicate-only peaks

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# Obtain duplicate-only peaks:
peakTest_all = c(peakList, ext_peakList, sup_peakList)
nameswithDup = grep("withDup",names(peakTest_all),value=TRUE)
peakTest_withDup = peakTest_all[nameswithDup] 

namesrmDup = grep("rmDup",names(peakTest_all),value=TRUE)
peakTest_rmDup = peakTest_all[namesrmDup]
  
duplicate_only_peaks = c()
for(i in 1:length(peakTest_rmDup)){
  dup_only = IRanges::subsetByOverlaps(peakTest_withDup[[i]], peakTest_rmDup[[i]], invert = TRUE)
  duplicate_only_peaks = c(duplicate_only_peaks, dup_only)
}

# names
names <- str_replace(namesrmDup, "_rmDup","")
duplicate_only_peaks = setNames(duplicate_only_peaks, names)

# new names for plot context
namedf = data.frame(SampleCaller=names, Sample=str_replace(names, "_MACS2|_SEACR",""))
namedf = merge(namedf, alignResult[c("Sample","SampleLabel")], by="Sample")
namedf$Caller <- str_extract(namedf$SampleCaller, "SEACR|MACS2")
namedf$SampleLabel <- paste0(namedf$SampleLabel, " (",namedf$Caller,")")
names(duplicate_only_peaks) = c( namedf$SampleLabel[match(names(duplicate_only_peaks), namedf$SampleCaller)])

# reorder
duplicate_only_peaks = duplicate_only_peaks[order(names(duplicate_only_peaks))]
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=18, fig.height=8}
# run ChromHMM
chrHMM_url = "http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeBroadHmm/wgEncodeBroadHmmK562HMM.bed.gz"
chrHMM = genomation::readBed(chrHMM_url)
chrHMM_list = GenomicRanges::split(chrHMM, chrHMM$name, drop = TRUE) 
chrHMM_names = c("Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]", "Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]")
names(chrHMM_list) = chrHMM_names

annotation_dup_only = genomation::annotateWithFeatures(GenomicRanges::GRangesList(duplicate_only_peaks), chrHMM_list)
matrix = genomation::heatTargetAnnotation(annotation_dup_only, plot = FALSE)

# rownames(matrix) = labels_SEACR_MACS2
# rownames(matrix) = names(peakSEACR)
colnames(matrix) = chrHMM_names
matrix_melt = melt(matrix)
colnames(matrix_melt) = c("Sample", "State", "value")

ggplot(matrix_melt) +
  theme_bw() +
  geom_tile(aes(x = Sample, y = State, fill = value)) +
  scale_fill_viridis(name="% MACS2 Peaks",option = "plasma", limits=c(0,90), breaks=c(0,20,40,60,80,100)) +
  ggpubr::rotate_x_text(angle = 45) +
  theme(text = element_text(size = 15)) +
  theme(legend.key.size = unit(0.8, "cm")) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  ggtitle("ChromHMM States of Duplicate-Specific Peaks") +
  xlab("") +
  ylab("ChromHMM State")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChromHMM_annotation_heatmap_dupOnly_supp.svg",
#         dpi = 1200, width = 15.0,
#         height = 6, units ="in")

```

### Duplicate-only peaks, MACS2 only
```{r,fig.width=10, fig.height=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
names = grep("MACS2", names(duplicate_only_peaks))
duplicate_only_peaks_MACS2 = duplicate_only_peaks[names]
names(duplicate_only_peaks_MACS2) <- gsub(" \\(MACS2\\)","", names(duplicate_only_peaks_MACS2))


annotation_dup_only_MACS2 = genomation::annotateWithFeatures(GenomicRanges::GRangesList(duplicate_only_peaks_MACS2), chrHMM_list)
matrix_MACS2 = genomation::heatTargetAnnotation(annotation_dup_only_MACS2, plot = FALSE)

colnames(matrix_MACS2) = chrHMM_names
matrix_MACS2_melt = melt(matrix_MACS2)
colnames(matrix_MACS2_melt) = c("Sample", "State", "value")

# order chromatin state based on number
matrix_MACS2_melt$State <- factor(matrix_MACS2_melt$State,levels=c("Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]","Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]"))

ggplot(matrix_MACS2_melt) +
  theme_bw() +
  geom_tile(aes(x = Sample, y = State, fill = value)) +
  scale_fill_viridis(name="% Peaks",option = "plasma", limits=c(0,90), breaks=c(0,20,40,60,80,100)) +
  ggpubr::rotate_x_text(angle = 45) +
  theme(text = element_text(size = 15)) +
  theme(legend.key.size = unit(0.8, "cm")) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  ggtitle("Duplicate-Specific MACS2 Peaks") +
  xlab("") +
  ylab("ChromHMM State")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChromHMM_annotation_heatmap_macs2_dupOnly_supp.svg",
#         dpi = 1200, width = 10,
#         height = 6, units ="in")
```

### Duplicate-only peaks, SEACR only
```{r,fig.width=10, fig.height=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
names = grep("SEACR", names(duplicate_only_peaks))
duplicate_only_peaks_SEACR = duplicate_only_peaks[names]
names(duplicate_only_peaks_SEACR) <- gsub(" \\(SEACR\\)","", names(duplicate_only_peaks_SEACR))

annotation_dup_only_SEACR = genomation::annotateWithFeatures(GenomicRanges::GRangesList(duplicate_only_peaks_SEACR), chrHMM_list)
matrix_SEACR = genomation::heatTargetAnnotation(annotation_dup_only_SEACR, plot = FALSE)

colnames(matrix_SEACR) = chrHMM_names
matrix_SEACR_melt = melt(matrix_SEACR)
colnames(matrix_SEACR_melt) = c("Sample", "State", "value")

# order chromatin state based on number
matrix_SEACR_melt$State <- factor(matrix_SEACR_melt$State,levels=c("Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]","Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]"))

ggplot(matrix_SEACR_melt) +
  theme_bw() +
  geom_tile(aes(x = Sample, y = State, fill = value)) +
  scale_fill_viridis(name="% Peaks",option = "plasma", limits=c(0,90), breaks=c(0,20,40,60,80,100)) +
  ggpubr::rotate_x_text(angle = 45) +
  theme(text = element_text(size = 15)) +
  theme(legend.key.size = unit(0.8, "cm")) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  ggtitle("Duplicate-Specific SEACR Peaks") +
  xlab("") +
  ylab("ChromHMM State")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChromHMM_annotation_heatmap_seacr_dupOnly_supp.svg",
#         dpi = 1200, width = 10,
#         height = 6, units ="in")
```

### C&T peaks not in ENCODE H3K27ac, SEACR

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# Collect C&T peaks not in ENCODE:
peakTest_all = c(peakList, ext_peakList, sup_peakList)
peakTest = peakTest_all

CT_peaks_not_in_ENCODE_H3K27ac_set = c()
CT_peaks_not_in_ENCODE_H3K27me3_set = c()

for(i in 1:length(peakTest)){
  not_in_ENCODE_H3K27ac = IRanges::subsetByOverlaps(peakTest[[i]], ENCODE_H3K27ac, invert = TRUE)
  # not_in_ENCODE_H3K27ac = IRanges::subsetByOverlaps(peakTest[[i]], ENCODE_H3K27ac, invert = TRUE)
  # not_in_ENCODE_H3K27me3 = IRanges::subsetByOverlaps(peakTest[[i]], ENCODE_H3K27me3, invert = TRUE)
  CT_peaks_not_in_ENCODE_H3K27ac_set = c(CT_peaks_not_in_ENCODE_H3K27ac_set, not_in_ENCODE_H3K27ac)
  # CT_peaks_not_in_ENCODE_H3K27me3_set = c(CT_peaks_not_in_ENCODE_H3K27me3_set, not_in_ENCODE_H3K27me3)
}

CT_peaks_not_in_ENCODE_H3K27ac_set = setNames(CT_peaks_not_in_ENCODE_H3K27ac_set, names(peakTest))
# CT_peaks_not_in_ENCODE_H3K27me3_set = setNames(CT_peaks_not_in_ENCODE_H3K27me3_set, sampleList_all)

```

```{r,fig.width=18, fig.height=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# select SEACR peaks
names = grep("SEACR", names(CT_peaks_not_in_ENCODE_H3K27ac_set))
CT_peaks_not_in_ENCODE_H3K27ac_set_SEACR = CT_peaks_not_in_ENCODE_H3K27ac_set[names]
names(CT_peaks_not_in_ENCODE_H3K27ac_set_SEACR) <- gsub(" \\(SEACR\\)","", names(CT_peaks_not_in_ENCODE_H3K27ac_set_SEACR))

annotation_not_in_ENCODE_H3K27ac_SEACR = genomation::annotateWithFeatures(GenomicRanges::GRangesList(CT_peaks_not_in_ENCODE_H3K27ac_set_SEACR), chrHMM_list)
matrix = genomation::heatTargetAnnotation(annotation_not_in_ENCODE_H3K27ac_SEACR, plot = FALSE)

colnames(matrix) = names(chrHMM_list)
matrix_melt = melt(matrix)
colnames(matrix_melt) = c("PeakSet", "State", "value")

# new names for plot context
peakdf = rbind(ext_df, sup_df) %>% unique
# namedf = data.frame(PeakSet=matrix_melt$PeakSet)
matrix_melt = merge(matrix_melt, peakdf[c("PeakSet","SampleLabel")], by="PeakSet")
matrix_melt$Dup <- str_extract(matrix_melt$PeakSet, "rmDup|withDup")
matrix_melt$SampleLabel <- paste0(matrix_melt$SampleLabel, " (",matrix_melt$Dup,")")

# order chromatin state based on number
matrix_SEACR_melt$State <- factor(matrix_SEACR_melt$State,levels=c("Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]","Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]"))


ggplot(matrix_melt) +
  theme_bw() +
  geom_tile(aes(x = SampleLabel, y = State, fill = value)) +
  scale_fill_viridis(name="% Peaks",option = "plasma", limits=c(0,90), breaks=c(0,20,40,60,80,100)) +
  ggpubr::rotate_x_text(angle = 45) +
  theme(text = element_text(size = 15)) +
  theme(legend.key.size = unit(0.8, "cm")) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  ggtitle("SEACR Peaks not in ENCODE H3K27ac") +
  xlab("") +
  ylab("ChromHMM State")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChromHMM_annotation_heatmap_seacr_notencode_supp.svg",
#         dpi = 1200, width = 17,
#         height = 6, units ="in")
```

### C&T peaks not in ENCODE H3K27ac, MACS2
```{r,fig.width=18, fig.height=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# select MACS2 peaks
names = grep("MACS2", names(CT_peaks_not_in_ENCODE_H3K27ac_set))
CT_peaks_not_in_ENCODE_H3K27ac_set_MACS2 = CT_peaks_not_in_ENCODE_H3K27ac_set[names]
names(CT_peaks_not_in_ENCODE_H3K27ac_set_MACS2) <- gsub(" \\(MACS2\\)","", names(CT_peaks_not_in_ENCODE_H3K27ac_set_MACS2))

annotation_not_in_ENCODE_H3K27ac_MACS2 = genomation::annotateWithFeatures(GenomicRanges::GRangesList(CT_peaks_not_in_ENCODE_H3K27ac_set_MACS2), chrHMM_list)
matrix = genomation::heatTargetAnnotation(annotation_not_in_ENCODE_H3K27ac_MACS2, plot = FALSE)

colnames(matrix) = names(chrHMM_list)
matrix_melt = melt(matrix)
colnames(matrix_melt) = c("PeakSet", "State", "value")

# new names for plot context
peakdf = rbind(ext_df, sup_df) %>% unique
# namedf = data.frame(PeakSet=matrix_melt$PeakSet)
matrix_melt = merge(matrix_melt, peakdf[c("PeakSet","SampleLabel")], by="PeakSet")
matrix_melt$Dup <- str_extract(matrix_melt$PeakSet, "rmDup|withDup")
matrix_melt$SampleLabel <- paste0(matrix_melt$SampleLabel, " (",matrix_melt$Dup,")")

# order chromatin state based on number
matrix_SEACR_melt$State <- factor(matrix_SEACR_melt$State,levels=c("Active promoter [1]", "Weak promoter [2]", "Poised promoter [3]", "Strong enhancer [4]", "Strong enhancer [5]",  "Weak enhancer [6]", "Weak enhancer [7]", "Insulator [8]", "Transcription transition [9]","Transcription elongation [10]", "Weak transcription [11]", "Repressed [12]", "Heterochromatin [13]", "Repetitive [14]", "Repetitive [15]"))

ggplot(matrix_melt) +
  theme_bw() +
  geom_tile(aes(x = SampleLabel, y = State, fill = value)) +
  scale_fill_viridis(name="% Peaks",option = "plasma", limits=c(0,90), breaks=c(0,20,40,60,80,100)) +
  ggpubr::rotate_x_text(angle = 45) +
  theme(text = element_text(size = 15)) +
  theme(legend.key.size = unit(0.8, "cm")) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  ggtitle("MACS2 Peaks not in ENCODE H3K27ac") +
  xlab("") +
  ylab("ChromHMM State")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "ChromHMM_annotation_heatmap_macs2_notencode_supp.svg",
#         dpi = 1200, width = 17,
#         height = 6, units ="in")
```

### C&T peaks in ENCODE H3K27ac

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# Collect C&T peaks in ENCODE:
CT_peaks_in_ENCODE_H3K27ac_set = c()
CT_peaks_in_ENCODE_H3K27me3_set = c()

peakTest_all = c(peakList, ext_peakList, sup_peakList)
peakTest = peakTest_all

for(i in 1:length(peakTest)){
  in_ENCODE_H3K27ac = IRanges::subsetByOverlaps(peakTest[[i]], ENCODE_H3K27ac)
  # in_ENCODE_H3K27me3 = IRanges::subsetByOverlaps(peakList[[i]], ENCODE_H3K27me3)
  CT_peaks_in_ENCODE_H3K27ac_set = c(CT_peaks_in_ENCODE_H3K27ac_set, in_ENCODE_H3K27ac)
  # CT_peaks_in_ENCODE_H3K27me3_set = c(CT_peaks_in_ENCODE_H3K27me3_set, in_ENCODE_H3K27me3)
}

CT_peaks_in_ENCODE_H3K27ac_set = setNames(CT_peaks_in_ENCODE_H3K27ac_set, names(peakTest))
# CT_peaks_in_ENCODE_H3K27me3_set = setNames(CT_peaks_in_ENCODE_H3K27me3_set, sampleList_all)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=17}
annotation_in_ENCODE_H3K27ac = genomation::annotateWithFeatures(GenomicRanges::GRangesList(CT_peaks_in_ENCODE_H3K27ac_set), chrHMM_list)

matrix = genomation::heatTargetAnnotation(annotation_in_ENCODE_H3K27ac, plot = FALSE)

# rownames(matrix) = labels_SEACR_MACS2
matrix_melt = melt(matrix)
colnames(matrix_melt) = c("Sample", "State", "value")

ggplot(matrix_melt) +
  geom_tile(aes(x = State, y = Sample, fill = value)) +
  ylab("") +
  scale_fill_viridis(option = "plasma") +
  theme_minimal() +
  ggpubr::rotate_x_text(angle = 45) +
  theme(axis.text = element_text(size = 11))
```




## clusterProfiler KEGG {.tabset}
### SEACR
```{r, fig.width=9, fig.height=13, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# SEACR + ENCODE
seacrNames = c( grep("SEACR", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakSEACR = peakTest[seacrNames]
# new names for plot context
namedf = data.frame(PeakSet=names(peakSEACR))
namedf = merge( namedf, ext_df, by="PeakSet" )
names(peakSEACR) = c( na.omit(namedf$SampleLabel[match(names(peakSEACR), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakSEACR = peakSEACR[order(names(peakSEACR))]


peakAnnoList = lapply(peakSEACR, annotatePeak, TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene, tssRegion = c(-3000, 3000), verbose = FALSE)

genes = lapply(peakAnnoList, function(i) as.data.frame(i)$geneId)
names(genes) = sub("_", "\n", names(genes))
compKEGG = clusterProfiler::compareCluster(geneCluster = genes,
                                           fun = "enrichKEGG",
                                           pvalueCutoff = 0.05,
                                           pAdjustMethod = "BH")

KEGG_plot = clusterProfiler::dotplot(compKEGG, showCategory = 10, title = "KEGG Pathway Enrichment Analysis") +
  theme_bw(base_size = 13) +
  ggpubr::rotate_x_text(angle = 45) +
  scale_size_area(max_size = 10)

KEGG_plot

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "clusterProfiler_KEGG_annotation_dotplot_SEACR_rmDup.svg",
#         dpi = 1200, width = 10.0,
#         height = 15.0, units ="in")
```

### MACS2
```{r, fig.width=9, fig.height=13, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# SEACR + ENCODE
seacrNames = c( grep("MACS2", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakSEACR = peakTest[seacrNames]
# new names for plot context
namedf = data.frame(PeakSet=names(peakSEACR))
namedf = merge( namedf, ext_df, by="PeakSet" )
names(peakSEACR) = c( na.omit(namedf$SampleLabel[match(names(peakSEACR), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakSEACR = peakSEACR[order(names(peakSEACR))]


peakAnnoList = lapply(peakSEACR, annotatePeak, TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene, tssRegion = c(-3000, 3000), verbose = FALSE)

genes = lapply(peakAnnoList, function(i) as.data.frame(i)$geneId)
names(genes) = sub("_", "\n", names(genes))
compKEGG = clusterProfiler::compareCluster(geneCluster = genes,
                                           fun = "enrichKEGG",
                                           pvalueCutoff = 0.05,
                                           pAdjustMethod = "BH")

KEGG_plot = clusterProfiler::dotplot(compKEGG, showCategory = 10, title = "KEGG Pathway Enrichment Analysis") +
  theme_bw(base_size = 13) +
  ggpubr::rotate_x_text(angle = 45) +
  scale_size_area(max_size = 10)

KEGG_plot

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "clusterProfiler_KEGG_annotation_dotplot_SEACR_rmDup.svg",
#         dpi = 1200, width = 10.0,
#         height = 15.0, units ="in")
```
## clusterProfiler GO {.tabset}
### SEACR
```{r, fig.width=28, fig.height=50, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# SEACR + ENCODE
seacrNames = c( grep("SEACR", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakSEACR = peakTest[seacrNames]
# new names for plot context
namedf = data.frame(PeakSet=names(peakSEACR))
peakdf = rbind(ext_df, sup_df) %>% unique
namedf = merge( namedf, peakdf, by="PeakSet" )

names(peakSEACR) = c( na.omit(namedf$SampleLabel[match(names(peakSEACR), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakSEACR = peakSEACR[order(names(peakSEACR))]


peakAnnoList = lapply(peakSEACR, annotatePeak, TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene, tssRegion = c(-3000, 3000), verbose = FALSE)

genes = lapply(peakAnnoList, function(i) as.data.frame(i)$geneId)
names(genes) = sub("_", "\n", names(genes))
compGO = clusterProfiler::compareCluster(geneCluster = genes,
                                           OrgDb = "org.Hs.eg.db", 
                                           fun = "enrichGO",
                                           pvalueCutoff = 0.05,
                                           pAdjustMethod = "BH")

clusterProfiler::dotplot(compGO, showCategory = 15) + 
  geom_point(aes(size=GeneRatio,color=-log10(p.adjust))) +
  scale_colour_viridis(option = "plasma", limits=c(1,22), 
                     direction = -1, begin=0.1,end=0.9) +
  theme_bw(base_size = 40) + 
  theme(plot.title = element_text(size = 45)) + 
  ggpubr::rotate_x_text(angle = 45) + 
  theme(legend.key.size = unit(1.5, "cm")) + 
  scale_size_area(max_size = 15) + 
  scale_y_discrete(labels=function(x) str_wrap(x, width=40)) + 
  scale_x_discrete(labels=function(x) str_wrap(x, width=40)) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  theme(legend.position = "top") +
  ggtitle("SEACR") +
  labs(color="-log(p.adj)") +
  xlab("")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "clusterProfiler_GO_annotation_dotplot_SEACR_rmDup.svg",
#         dpi = 1200, width = 23.0,
#         height = 50.0, units ="in",
#        limitsize = FALSE)
```
### MACS2
```{r, fig.width=32, fig.height=50, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# MACS2
peakTest = c(peakList, ext_peakList,
             ENCODE_H3K27ac=ENCODE_H3K27ac, 
             ENCODE_H3K27me3=ENCODE_H3K27me3)
keepNames = names(peakTest) %>% grep("withDup", ., value=T, invert = T)
peakTest = peakTest[keepNames]

# MACS2 + ENCODE
macs2Names = c( grep("MACS2", names(peakTest) , value=T) , grep("ENCODE", names(peakTest) , value=T) )
peakMACS2 = peakTest[macs2Names]
# new names for plot context
namedf = data.frame(PeakSet=names(peakMACS2))
namedf = merge( namedf, ext_df, by="PeakSet" )
names(peakMACS2) = c( na.omit(namedf$SampleLabel[match(names(peakMACS2), namedf$PeakSet)]), "H3K27ac ENCODE", "H3K27me3 ENCODE")
# reorder
peakMACS2 = peakMACS2[order(names(peakMACS2))]


peakAnnoList = lapply(peakMACS2, annotatePeak, TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene, tssRegion = c(-3000, 3000), verbose = FALSE)

genes = lapply(peakAnnoList, function(i) as.data.frame(i)$geneId)
names(genes) = sub("_", "\n", names(genes))
compGO = clusterProfiler::compareCluster(geneCluster = genes,
                                           OrgDb = "org.Hs.eg.db", 
                                           fun = "enrichGO",
                                           pvalueCutoff = 0.05,
                                           pAdjustMethod = "BH")

clusterProfiler::dotplot(compGO, showCategory = 15) + 
  geom_point(aes(size=GeneRatio,color=-log10(p.adjust))) +
  scale_colour_viridis(option = "plasma", limits=c(1,22), 
                     direction = -1, begin=0.1,end=0.9) +
  theme_bw(base_size = 40) + 
  theme(plot.title = element_text(size = 45)) + 
  ggpubr::rotate_x_text(angle = 45) + 
  theme(legend.key.size = unit(1.5, "cm")) + 
  scale_size_area(max_size = 15) + 
  scale_y_discrete(labels=function(x) str_wrap(x, width=40)) + 
  scale_x_discrete(labels=function(x) str_wrap(x, width=40)) +
  theme(plot.title=element_text(face="bold", hjust = 0.5 )) +
  theme(legend.position = "top") +
  ggtitle("MACS2") +
  labs(color="-log(p.adj)") +
  xlab("")

# ggsave(path = paste0(workdir,"/functional"),
#         filename = "clusterProfiler_GO_annotation_dotplot_MACS2_rmDup.svg",
#         dpi = 1200, width = 23.0,
#         height = 50.0, units ="in",
#        limitsize = FALSE)
```


# Promoter overlap
Quantifying number of MACS2 and SEACR peaks overlapping UCSC promoter regions.

## Promoter capture
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
## all CT sample peaks 
peakList_with_ENCODE = c(peakList, ext_peakList, ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3)
sampleList_all_with_ENCODE = names(peakList_with_ENCODE)

# define promoters
promoters = ChIPseeker::getPromoters(TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene)
CT_in_promoters = c()

for(i in 1:length(peakList_with_ENCODE)){
  overlaps = GenomicRanges::countOverlaps(query = peakList_with_ENCODE[[i]], subject = promoters)
  peaks_in_promoters = overlaps[overlaps != 0] %>% length()
  CT_in_promoters = c(CT_in_promoters, peaks_in_promoters)
}

CT_in_promoters_summary = data.frame(Sample = sampleList_all_with_ENCODE, CT_in_promoters = CT_in_promoters)


promoters_captured = c()

for(i in 1:length(peakList_with_ENCODE)){
  overlaps = GenomicRanges::countOverlaps(query = promoters, subject = peakList_with_ENCODE[[i]])
  promoters_in_CT = overlaps[overlaps != 0] %>% length()
  promoters_captured = c(promoters_captured, promoters_in_CT)
}

promoters_in_CT_summary = data.frame(Sample = sampleList_all_with_ENCODE, Promoters_in_CT = promoters_captured)

Total_ENCODE_peaks = data.frame(Sample = c("ENCODE_H3K27ac", "ENCODE_H3K27me3"), 
                                Total_PeakN = c(length(ENCODE_H3K27ac), length(ENCODE_H3K27me3)))

# regenerate relevant CT counts: both inhouse and external dataset peak lists
ext_peakList_unfilt <- c(peakList_unfilt, ext_peakList_unfilt) 
ext_callInfo <- c(callInfo, ext_callInfo)
Total_CT_peaks = c()
for(i in 1:length(ext_peakList_unfilt)){ Total_CT_peaks = c(Total_CT_peaks, length(ext_peakList_unfilt[[i]])) }
names(Total_CT_peaks) <- ext_callInfo
Total_CT_peaks = data.frame(Sample=names(Total_CT_peaks), Total_PeakN=Total_CT_peaks)

# append ENCODE peak counts
Total_CT_peaks_with_ENCODE = Total_CT_peaks[,1:2] %>% rbind(Total_ENCODE_peaks)

promoter_overlaps = CT_in_promoters_summary %>% left_join(promoters_in_CT_summary, by = "Sample") %>% left_join(Total_CT_peaks_with_ENCODE, by = "Sample") %>% unique

promoter_overlaps$Percentage_of_CT_in_promoters = promoter_overlaps$CT_in_promoters / promoter_overlaps$Total_PeakN * 100
promoter_overlaps$Percentage_of_promoters_captured = promoter_overlaps$Promoters_in_CT / length(promoters) * 100
promoter_overlaps
```
```{r, fig.height=5, fig.width=9, warning=FALSE}
# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",promoter_overlaps$Sample,value = TRUE)
promoter_overlaps <- promoter_overlaps[!(promoter_overlaps$Sample %in% dupSample),]
promoter_overlaps$Sample <- factor(promoter_overlaps$Sample, levels=as.character(unique(promoter_overlaps$Sample)))

# Add more informative sample label with antibody names
promoter_overlaps$sampleID <- str_remove(promoter_overlaps$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
promoter_overlaps <- merge(promoter_overlaps, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample")

# add caller info
promoter_overlaps$caller = str_extract(promoter_overlaps$Sample, "MACS2|SEACR|ENCODE")

# add histone mark facet
promoter_overlaps$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", promoter_overlaps$SampleLabel,value = TRUE)
promoter_overlaps$'Modification'[promoter_overlaps$SampleLabel %in% meSample]  <- "H3K27me3"

sel = grep("SEACR",promoter_overlaps$Sample,value=TRUE)
CT_in_promoters_SEACR = promoter_overlaps[promoter_overlaps$Sample %in% sel,"Percentage_of_CT_in_promoters"]
sel = grep("MACS2",promoter_overlaps$Sample,value=TRUE)
CT_in_promoters_MACS2 = promoter_overlaps[promoter_overlaps$Sample %in% sel,"Percentage_of_CT_in_promoters"]

CT_in_promoters_summary = data.frame(Sample = unique(promoter_overlaps$SampleLabel), 
                                     SEACR = CT_in_promoters_SEACR, 
                                     MACS2 = CT_in_promoters_MACS2)
CT_in_promoters_summary_melt = melt(CT_in_promoters_summary)


CT_in_promoters_summary_melt$variable <- factor(CT_in_promoters_summary_melt$variable, levels=c("MACS2","SEACR"))

CT_in_promoters_plot = ggplot(CT_in_promoters_summary_melt, aes(Sample, value, fill = variable)) +
  geom_bar(width = 0.7, position = position_dodge(width = 0.75), stat = "identity", alpha = 0.7) +
  ylim(0, 100) +
  theme_bw() +
  ylab("% of peaks") +
  xlab("") +
  ggtitle("Sample peaks in promoters") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 1)) +
  theme(axis.text = element_text(size = 15)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25)) +
  theme(legend.text = element_text(size = 15)) +
  theme(legend.title = element_text(size = 15)) +
  scale_fill_manual(name=NULL, values=c("#6d1961","steelblue")) +
  coord_flip()

CT_in_promoters_plot

# ggsave(path = paste0(workdir,"/functional"),
#          filename = paste0("sample_peaks_in_promoters_barplot.svg"),
#         dpi = 1200, width = 7.5,
#         height = 5.0, units ="in")
```

```{r, fig.height=5, fig.width=9, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}

sel = grep("SEACR",promoter_overlaps$Sample,value=TRUE)
promoter_overlaps_SEACR = promoter_overlaps[promoter_overlaps$Sample %in% sel,"Percentage_of_promoters_captured"]
sel = grep("MACS2",promoter_overlaps$Sample,value=TRUE)
promoter_overlaps_MACS2 = promoter_overlaps[promoter_overlaps$Sample %in% sel,"Percentage_of_promoters_captured"]

promoter_overlaps_summary = data.frame(Sample = unique(promoter_overlaps$SampleLabel), 
                                       SEACR = promoter_overlaps_SEACR, 
                                       MACS2 = promoter_overlaps_MACS2)
promoter_overlaps_summary_melt = melt(promoter_overlaps_summary)

promoter_overlaps_summary_melt$variable <- factor(promoter_overlaps_summary_melt$variable, levels=c("MACS2","SEACR"))

Promoters_in_CT_plot = ggplot(promoter_overlaps_summary_melt, aes(Sample, value, fill = variable)) +
  geom_bar(width = 0.7, position = position_dodge(width = 0.75), stat = "identity", alpha = 0.7) +
  ylim(0, 100) +
  theme_bw() +
  ylab("% of promoters") +
  xlab("Sample") +
  ggtitle("Captured promoters") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 1)) +
  theme(axis.text = element_text(size = 15)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25)) +
  theme(legend.text = element_text(size = 15)) +
  theme(legend.title = element_text(size = 15)) +
  scale_fill_manual(name=NULL, values=c("#6d1961","steelblue")) +
  coord_flip()


Promoters_in_CT_plot

# ggsave(path = paste0(workdir,"/functional"),
#          filename = paste0("captured_promoters_barplot.svg"),
#         dpi = 1200, width = 7.5,
#         height = 5.0, units ="in")
```


## Sample peaks in promoters
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
avgs = c()
sds = c()

for(i in 1:length(peakList_with_ENCODE)){
  overlaps = IRanges::findOverlaps(query=promoters, subject=peakList_with_ENCODE[[i]]) %>% queryHits
  overlapsAvg = data.frame(table(overlaps))$Freq %>% mean()
  overlapsSD = data.frame(table(overlaps))$Freq %>% sd()
  avgs = c(avgs, overlapsAvg)
  sds = c(sds, overlapsSD)
}

summary = data.frame(Sample = sampleList_all_with_ENCODE, 
                                     Average = avgs,
                                     SD = sds)
summary
```

```{r, fig.height=5, fig.width=9, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",summary$Sample,value = TRUE)
plotdata <- summary[!(summary$Sample %in% dupSample),]
plotdata$Sample <- factor(plotdata$Sample, levels=as.character(unique(plotdata$Sample)))

# Add more informative sample label with antibody names
plotdata$sampleID <- str_remove(plotdata$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
plotdata <- merge(plotdata, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample")

# add caller info
plotdata$caller = str_extract(plotdata$Sample, "MACS2|SEACR|ENCODE")
plotdata$caller <- factor(plotdata$caller, levels=c("MACS2","SEACR"))

# add histone mark facet
plotdata$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", plotdata$SampleLabel,value = TRUE)
plotdata$'Modification'[plotdata$SampleLabel %in% meSample]  <- "H3K27me3"


ggplot(plotdata, aes(SampleLabel, Average, fill = caller)) +
  geom_bar(aes(fill = caller), width = 0.7, position = position_dodge(width = 0.75), stat = "identity", alpha = 0.7) +
  geom_errorbar( aes(ymin = Average-SD, ymax = Average+SD), width = 0.5, position = position_dodge(0.75),  group = caller) +
  ylim(0, 2) +
  theme_bw() +
  ylab("Average") +
  xlab("") +
  ggtitle("Number of sample peaks per promoter") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 1)) +
  theme(axis.text = element_text(size = 15)) +
  theme(axis.title = element_text(size = 18)) +
  theme(plot.title = element_text(size = 25)) +
  theme(legend.text = element_text(size = 15)) +
  theme(legend.title = element_text(size = 15)) +
  scale_fill_manual(name=NULL, values=c("#6d1961", "steelblue")) +
  coord_flip()

# ggsave(path = paste0(workdir,"/functional"),
#          filename = paste0("sample_peaks_per_promoter_barplot.svg"),
#         dpi = 1200, width = 7.5,
#         height = 5.0, units ="in")
```


# STARR-seq 
Quantify capture of STARR-seq enhancer peaks with CUT&Tag by overlap. Also, test within a subset (filtered) of STARR-seq peaks that overlap DNase peaks in K562 cells.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# load STARR-seq peaks
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources"
STARRseq = ChIPseeker::readPeakFile(paste0(datadir, "/STARRseq/STARRseq_hg19_replicated_peaks_ENCSR858MPS.bed"), as = "GRanges")

# load and liftover DNase seq regions
chainfile = rtracklayer::import.chain(system.file(package = "liftOver", "extdata", "hg38ToHg19.over.chain")) # need to install liftOver

datadir = "/Volumes/pu1918/projects/mrc_bdr/live/cutandtag/benchmarking/resources/ENCODE/peaks"
ENCODE_DNase = ChIPseeker::readPeakFile(paste0(datadir, "/DNase_seq_hg38_ENCFF722NSO.bed"), as = "GRanges")
seqlevelsStyle(ENCODE_DNase) = "UCSC" 
ENCODE_DNase = rtracklayer::liftOver(ENCODE_DNase, chainfile) %>% unlist()

# filter STARRseq peaks to overlapping DNase regions
STARRseq_filt = IRanges::subsetByOverlaps(STARRseq, ENCODE_DNase)
```

## allPeaks
```{r, message=FALSE,echo=FALSE,warning=FALSE}
## Define the test peak list
subset = "allPeaks" # set: allPeaks / promoterPeaks

## all CT sample peaks 
peakList_with_ENCODE = c(peakList, ext_peakList, ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3)
sampleList_all_with_ENCODE = names(peakList_with_ENCODE)

## subset these to promoter overlapping and non-overlapping
if (subset == "promoterPeaks") {
  # perform promoter subsetting
  promoters = ChIPseeker::getPromoters(TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene)
  peakList_promoterOL = c()
  peakList_promoterNo_OL = c()

  for(i in 1:length(peakList_with_ENCODE)){
    peaks_in_promoters = IRanges::subsetByOverlaps(peakList_with_ENCODE[[i]], promoters)
    peaks_not_in_promoters = IRanges::subsetByOverlaps(peakList_with_ENCODE[[i]], promoters, invert=TRUE)
    peakList_promoterOL = c(peakList_promoterOL, list(peaks_in_promoters))
    peakList_promoterNo_OL = c(peakList_promoterNo_OL, list(peaks_not_in_promoters))
  }
  
  names(peakList_promoterOL) = sampleList_all_with_ENCODE
  names(peakList_promoterNo_OL) = sampleList_all_with_ENCODE
  
  peakList_promoterOL
  peakList_promoterNo_OL
}

if (subset == "promoterPeaks") {
peakList_with_ENCODE = peakList_promoterOL
# peakList_with_ENCODE = peakList_promoterNo_OL
}
```

### Count overlap
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# count peak overlaps
STARRseq_overlapping_peaks = c()
STARRseq_overlap_prop = c()
STARRseq_missed_peaks = c()
STARRseq_filt_overlapping_peaks = c()
STARRseq_filt_overlap_prop = c()
STARRseq_filt_missed_peaks = c()


for(i in 1:length(peakList_with_ENCODE)){
  STARRseq_overlapping_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq, peakList_with_ENCODE[[i]])
  STARRseq_missed_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq, peakList_with_ENCODE[[i]], invert = TRUE)
  STARRseq_overlap_prop = c(STARRseq_overlap_prop, length(STARRseq_overlapping_peaks[[i]])/length(STARRseq))
  
  STARRseq_filt_overlapping_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq_filt, peakList_with_ENCODE[[i]])
  STARRseq_filt_missed_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq_filt, peakList_with_ENCODE[[i]], invert = TRUE)
  STARRseq_filt_overlap_prop = c(STARRseq_filt_overlap_prop, length(STARRseq_filt_overlapping_peaks[[i]])/length(STARRseq_filt))
}


names(STARRseq_overlapping_peaks) = sampleList_all_with_ENCODE
names(STARRseq_overlap_prop) = sampleList_all_with_ENCODE
names(STARRseq_missed_peaks) = sampleList_all_with_ENCODE

names(STARRseq_filt_overlapping_peaks) = sampleList_all_with_ENCODE
names(STARRseq_filt_overlap_prop) = sampleList_all_with_ENCODE
names(STARRseq_filt_missed_peaks) = sampleList_all_with_ENCODE

STARRseq_peak_overlaps_df = data.frame("Sample" = sampleList_all_with_ENCODE,
                                       "% captured STARR-seq peaks (all)" = (STARRseq_overlap_prop * 100),
                                       "% captured STARR-seq peaks (filt)" = (STARRseq_filt_overlap_prop * 100),
                                       "Total sample peaks" = lapply(peakList_with_ENCODE, length) %>% unlist %>% unname,
                                       check.names = FALSE, row.names = NULL)
STARRseq_peak_overlaps_df
```

### Significance {.tabset}

Check -log10(qval) values of captured and missed STARR-seq peaks and test significance with t-test

#### All
```{r, fig.height=11, fig.width=10, warning=FALSE}
STARRseq_qvals_df = c()

for(i in 1:length(peakList_with_ENCODE)){
  df_captured = data.frame("Sample" = sampleList_all_with_ENCODE[i], "-log10(qval)" = STARRseq_overlapping_peaks[[i]]$V12, "Captured" = "Captured", check.names = FALSE)
  df_missed = data.frame("Sample" = sampleList_all_with_ENCODE[i], "-log10(qval)" = STARRseq_missed_peaks[[i]]$V12, "Captured" = "Missed", check.names = FALSE)
  STARRseq_qvals_df = rbind(STARRseq_qvals_df, rbind(df_captured, df_missed))
}

STARRseq_qvals_df_melt = melt(STARRseq_qvals_df, id.vars = c("Sample", "Captured"))

ggplot(STARRseq_qvals_df_melt, aes(x = value, y = Sample, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 15))
```

#### All (t-test)
```{r, fig.height=10, fig.width=10, warning=FALSE}
tests = c()

for(i in 1:length(sampleList_all_with_ENCODE)){
  captured = STARRseq_qvals_df[(STARRseq_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_qvals_df$Captured == "Captured"),]
  missed = STARRseq_qvals_df[(STARRseq_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var, paired = FALSE, alternative = c("two.sided"))
  tests[[i]] = test
}

names(tests) = sampleList_all_with_ENCODE


# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

#### Filtered
```{r, fig.height=11, fig.width=10, warning=FALSE}

STARRseq_filt_qvals_df = c()
STARRseq_filt_overlapping_peaks_cut = STARRseq_filt_overlapping_peaks[names(STARRseq_filt_overlapping_peaks) != "ENCODE DNase"]
STARRseq_filt_missed_peaks_cut = STARRseq_filt_missed_peaks[names(STARRseq_filt_missed_peaks) != "ENCODE DNase"]

for(i in 1:length(STARRseq_filt_overlapping_peaks_cut)){
  df_captured = data.frame("Sample" = names(STARRseq_filt_overlapping_peaks_cut)[i], "-log10(qval)" = STARRseq_filt_overlapping_peaks_cut[[i]]$V12, "Captured" = "Captured", check.names = FALSE)
  df_missed = data.frame("Sample" = names(STARRseq_filt_missed_peaks_cut)[i], "-log10(qval)" = STARRseq_filt_missed_peaks_cut[[i]]$V12, "Captured" = "Missed", check.names = FALSE)
  STARRseq_filt_qvals_df = rbind(STARRseq_filt_qvals_df, rbind(df_captured, df_missed))
}

STARRseq_filt_qvals_df_melt = melt(STARRseq_filt_qvals_df, id.vars = c("Sample", "Captured"))

ggplot(STARRseq_filt_qvals_df_melt, aes(x = value, y = Sample, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  scale_y_discrete(limits = rev(levels(STARRseq_filt_qvals_df_melt$Sample))) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 15))
```

#### Filtered (t-test)
```{r, fig.height=10, fig.width=10, warning=FALSE}
tests = c()

for(i in 1:length(sampleList_all_with_ENCODE)){
  captured = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_filt_qvals_df$Captured == "Captured"),]
  missed = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_filt_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var, paired = FALSE, alternative = c("two.sided"))
  tests[[i]] = test
}

names(tests) = sampleList_all_with_ENCODE

# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```


### Filtered STARR-seq peak significance, without duplicates
Visualising the significance of STARR-seq peaks filtered for DNase peak overlaps in peaks captured / missed by CUT&Tag.

```{r, fig.height=10, fig.width=9, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",STARRseq_filt_qvals_df_melt$Sample,value = TRUE)
plotdata <- STARRseq_filt_qvals_df_melt[!(STARRseq_filt_qvals_df_melt$Sample %in% dupSample),]

# add caller info
plotdata$caller = str_extract(plotdata$Sample, "MACS2|SEACR|ENCODE")

# Add more informative sample label with antibody names
plotdata$sampleID <- str_remove(plotdata$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
plotdata <- merge(plotdata, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample", all.x=TRUE)
plotdata$SampleLabel[is.na(plotdata$SampleLabel)] <- plotdata$sampleID[is.na(plotdata$SampleLabel)] 
plotdata$SampleLabel <- paste0(plotdata$SampleLabel , " (", plotdata$caller, ")" )

# add histone mark facet
plotdata$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", plotdata$SampleLabel,value = TRUE)
plotdata$'Modification'[plotdata$SampleLabel %in% meSample]  <- "H3K27me3"

# rename
plotdata$label <- str_replace(plotdata$SampleLabel, "^H3K27ac-|H3K27me3-", "")
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27ac (ENCODE)"] <- "ENCODE H3K27ac"
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27me3 (ENCODE)"] <- "ENCODE H3K27me3"

plotdata = plotdata[order(plotdata[,2], plotdata[,6]),]
plotdata$label <- factor(plotdata$label, levels = unique(plotdata$label))

ggplot(plotdata, aes(x = value, y = label, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  # scale_y_discrete(limits = rev(levels(plotdata$SampleLabel))) +
  scale_fill_manual(name=NULL, values=c("#e1b1a2","#ed6851")) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 18)) +
  facet_grid(rows='Modification',  scales = "free_y", space="free")

# ggsave(path = paste0(workdir,"/functional"),
#        filename = paste0("starrseq_overlap_allpeaks_DNasefilt_significance.svg"),
#         dpi = 1200, width = 6.0,
#         height = 8.0, units ="in")
```

#### Welch Two Sample t-test
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
tests = c()

for(i in 1:length(STARRseq_filt_overlapping_peaks_cut)){
  captured = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == names(STARRseq_filt_overlapping_peaks_cut)[i] & STARRseq_filt_qvals_df$Captured == "Captured"),]
  missed = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == names(STARRseq_filt_overlapping_peaks_cut)[i] & STARRseq_filt_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var)
  tests[[i]] = test
}

names(tests) = names(STARRseq_filt_overlapping_peaks_cut)

# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

### Corrected % of STARR-seq peaks captured {.tabset}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Randomly sample 6000 peaks from each sample and compare overlaps:
peakList_sub = c()
N=6000  # used for full peak sets
# N=3000   # used for promoter-overlapping peak sets

for(i in 1:length(peakList_with_ENCODE)){
  peakList_sub[[i]] = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), N), ]
}

names(peakList_sub) = names(peakList_with_ENCODE)
sub_STARRseq_peak_overlaps_df = EpiCompare::overlap_percent(list(STARRseq), peakList_sub)
sub_STARRseq_peak_overlaps_df$"Percentage (filt)" = (EpiCompare::overlap_percent(list(STARRseq_filt), peakList_sub))$Percentage %>% round(3)
val = lapply(peakList_sub, function(x){sum(GenomicRanges::width(x))/10^6}) %>% unlist() %>% round(2) %>% data.frame() 
colnames(val) = "Mb"
val$peaklistName = rownames(val)
sub_STARRseq_peak_overlaps_df <- merge(sub_STARRseq_peak_overlaps_df, val, by.x="peaklist2", by.y="peaklistName", all.x=TRUE)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Keep genome coverage the same:
test_coverage = function(peaks){sum(GenomicRanges::width(peaks)/10^6) %>% unlist() %>% round(0)}
peakList_sub_cov = c()
range_start = 500
# minimum coverage is 8Mb if also using ENCODE DNase peaks in comparison, otherwise can set higher limit
Mb = 8      # used for full peak set + DNase overlap
# Mb = 4        # used for promoter peak set + DNase overlap

for(i in 1:length(peakList_with_ENCODE)){
  #print(paste("Peak", i))
  
  # if included, use all DNase peaks
  if(names(peakList_with_ENCODE)[i] == "ENCODE DNase"){
    range = length(peakList_with_ENCODE$`ENCODE DNase`)
  } else {
    range_start = ((Mb - 2)/test_coverage(peakList_with_ENCODE[[i]]) * length(peakList_with_ENCODE[[i]])) %>% round(0)
    range = range_start:length(peakList_with_ENCODE[[i]])
  }
  
  # test lower bound of range
  test_peaks = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), range[1]), ]
  test_cov = test_peaks %>% test_coverage()

  if(test_cov == Mb){
    peakList_sub_cov[[i]] = test_peaks
  }
  
  if(test_cov < Mb){
    for(x in range){
      sub_peaks = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), x), ]
      coverage = test_coverage(sub_peaks)
      if(coverage == Mb){
        peakList_sub_cov[[i]] = sub_peaks
        break
      } 
    }
  }
  
  if(test_cov > Mb){ 
    print(paste("Adjusting range for peak", i))  
    range_start = range_start - 500
    range = range_start:length(peakList_with_ENCODE[[i]])
    }
  }

names(peakList_sub_cov) = names(peakList_with_ENCODE)
sub_cov_STARRseq_peak_overlaps_df = EpiCompare::overlap_percent(list(STARRseq), peakList_sub_cov)
sub_cov_STARRseq_peak_overlaps_df$"Percentage (filt)" = (EpiCompare::overlap_percent(list(STARRseq_filt), peakList_sub_cov))$Percentage %>% round(3)
val = lapply(peakList_sub_cov, function(x){sum(GenomicRanges::width(x))/10^6}) %>% unlist() %>% round(2) %>% data.frame() 
colnames(val) = "Mb"
val$peaklistName = rownames(val)
sub_cov_STARRseq_peak_overlaps_df <- merge(sub_cov_STARRseq_peak_overlaps_df, val, by.x="peaklist2", by.y="peaklistName", all.x=TRUE)
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
STARRseq_peak_overlaps_df_cut = STARRseq_peak_overlaps_df[STARRseq_peak_overlaps_df$Sample %in% sub_STARRseq_peak_overlaps_df$peaklist2, ]

# print("STARRseq_peak_overlaps_df")
# STARRseq_peak_overlaps_df
# print("STARRseq_peak_overlaps_df_cut")
# STARRseq_peak_overlaps_df_cut
# print("sub_STARRseq_peak_overlaps_df")
# sub_STARRseq_peak_overlaps_df
# print("sub_cov_STARRseq_peak_overlaps_df")
# sub_cov_STARRseq_peak_overlaps_df

sub_STARRseq_peak_overlaps_df = sub_STARRseq_peak_overlaps_df[match(STARRseq_peak_overlaps_df_cut$Sample, sub_STARRseq_peak_overlaps_df$peaklist2),]
sub_cov_STARRseq_peak_overlaps_df = sub_cov_STARRseq_peak_overlaps_df[match(STARRseq_peak_overlaps_df_cut$Sample, sub_cov_STARRseq_peak_overlaps_df$peaklist2),]


STARRseq_capture_summary = data.frame("Sample" = STARRseq_peak_overlaps_df_cut$Sample, "Uncorrected" = STARRseq_peak_overlaps_df_cut$`% captured STARR-seq peaks (all)`, "Corrected" = sub_cov_STARRseq_peak_overlaps_df$Percentage, check.names = FALSE)

STARRseq_capture_summary_filt = data.frame("Sample" = STARRseq_peak_overlaps_df_cut$Sample, "Uncorrected" = STARRseq_peak_overlaps_df_cut$`% captured STARR-seq peaks (filt)`, "Corrected" = sub_cov_STARRseq_peak_overlaps_df$`Percentage (filt)`, check.names = FALSE)

# print("STARRseq_capture_summary")
# STARRseq_capture_summary
# print("STARRseq_capture_summary_filt")
# STARRseq_capture_summary_filt
```


#### All STARR-seq peaks
```{r, fig.height=10, fig.width=10, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
STARRseq_capture_summary_melt = melt(STARRseq_capture_summary)
STARRseq_capture_summary_melt$Sample = factor(STARRseq_capture_summary_melt$Sample, levels = unique(STARRseq_capture_summary_melt$Sample))

ggplot(STARRseq_capture_summary_melt, aes(y = Sample, x = value, fill = variable)) +
  theme_bw() +
  geom_bar(stat = "identity", width = 0.75, position = position_dodge(width = 0.75), color = "black", size = 0.2) +
  scale_y_discrete(limits = rev(levels(STARRseq_capture_summary_melt$Sample))) +
  ylab("") +
  #xlim(0,40) +
  xlab("% of STARR-seq peaks captured") +
  theme(legend.position = "bottom", legend.title = element_blank()) +
  guides(fill = guide_legend(ncol = 2, reverse = FALSE)) +
  theme(text = element_text(size = 12))  
```

#### Filtered STARR-seq peaks (DNase overlap)
```{r, fig.height=10, fig.width=10, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
STARRseq_capture_summary_filt_melt = melt(STARRseq_capture_summary_filt)
STARRseq_capture_summary_filt_melt$Sample = factor(STARRseq_capture_summary_filt_melt$Sample, levels = unique(STARRseq_capture_summary_filt_melt$Sample))

ggplot(STARRseq_capture_summary_filt_melt, aes(y = Sample, x = value, fill = variable)) +
  theme_bw() +
  geom_bar(stat = "identity", width = 0.75, position = position_dodge(width = 0.75), color = "black", size = 0.2) +
  scale_y_discrete(limits = rev(levels(STARRseq_capture_summary_filt_melt$Sample))) +
  ylab("") +
  #xlim(0,40) +
  xlab("% of STARR-seq peaks captured") +
  theme(legend.position = "bottom", legend.title = element_blank()) +
  guides(fill = guide_legend(ncol = 2, reverse = FALSE)) +
  theme(text = element_text(size = 12)) 
```

#### Combine
```{r, fig.height=10, fig.width=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# facet the plot
plotdata = rbind(data.frame(STARRseq_capture_summary_melt, group="All STARR-seq"),
                 data.frame(STARRseq_capture_summary_filt_melt, group="STARR-DNase Overlap"))
plotdata$caller = str_extract(plotdata$Sample, "MACS2|SEACR|ENCODE")

# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",plotdata$Sample,value = TRUE)
plotdata <- plotdata[!(plotdata$Sample %in% dupSample),]
# plotdata$Sample <- factor(plotdata$Sample, levels=as.character(unique(plotdata$Sample)))

# Add more informative sample label with antibody names
plotdata$sampleID <- str_remove(plotdata$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
plotdata <- merge(plotdata, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample", all.x=TRUE)
plotdata$SampleLabel[is.na(plotdata$SampleLabel)] <- plotdata$sampleID[is.na(plotdata$SampleLabel)] 
plotdata$SampleLabel <- paste0(plotdata$SampleLabel , " (", plotdata$caller, ")" )

# add histone mark facet
plotdata$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", plotdata$SampleLabel,value = TRUE)
plotdata$'Modification'[plotdata$SampleLabel %in% meSample]  <- "H3K27me3"

# rename
plotdata$label <- str_replace(plotdata$SampleLabel, "^H3K27ac-|H3K27me3-", "")
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27ac (ENCODE)"] <- "ENCODE H3K27ac"
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27me3 (ENCODE)"] <- "ENCODE H3K27me3"

plotdata = plotdata[order(plotdata[,2], plotdata[,6]),]
plotdata$label <- factor(plotdata$label, levels = unique(plotdata$label))

ggplot(plotdata, aes(y = label, x = value, fill = caller)) +
  theme_bw() +
  geom_bar(stat = "identity", width = 0.75, 
           position = position_dodge(width = 0.75), 
           color = "black", size = 0.2, alpha=0.8) +
  scale_y_discrete(limits = rev(levels(plotdata$SampleLabel))) +
  scale_fill_manual(name=NULL, values=c("grey40","#6d1961","steelblue")) +
  ylab("") +
  xlim(0,60) +
  xlab("% of STARR-seq peaks captured") +
  theme(legend.position = "bottom", legend.title = element_blank()) +
  guides(fill = guide_legend(nrow = 1, reverse = FALSE)) +
  theme(text = element_text(size = 12)) +
  facet_grid(variable+Modification~group, scale="free", space="free_y")

# # save plot
# ggsave(path = paste0(workdir,"/functional"),
#         filename = paste0("starrseq_overlap_allpeaks.svg"),
#         dpi = 1200, width = 5.5,
#         height = 10.0, units ="in")
```


## Promoter overlapping peaks
```{r, message=FALSE,echo=FALSE,warning=FALSE}
## Define the test peak list
subset = "promoterPeaks" # set: allPeaks / promoterPeaks

## all CT sample peaks 
peakList_with_ENCODE = c(peakList, ext_peakList, ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3)
sampleList_all_with_ENCODE = names(peakList_with_ENCODE)

## subset these to promoter overlapping and non-overlapping
if (subset == "promoterPeaks") {
  # perform promoter subsetting
  promoters = ChIPseeker::getPromoters(TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene)
  peakList_promoterOL = c()
  peakList_promoterNo_OL = c()

  for(i in 1:length(peakList_with_ENCODE)){
    peaks_in_promoters = IRanges::subsetByOverlaps(peakList_with_ENCODE[[i]], promoters)
    peaks_not_in_promoters = IRanges::subsetByOverlaps(peakList_with_ENCODE[[i]], promoters, invert=TRUE)
    peakList_promoterOL = c(peakList_promoterOL, list(peaks_in_promoters))
    peakList_promoterNo_OL = c(peakList_promoterNo_OL, list(peaks_not_in_promoters))
  }
  
  names(peakList_promoterOL) = sampleList_all_with_ENCODE
  names(peakList_promoterNo_OL) = sampleList_all_with_ENCODE

}

if (subset == "promoterPeaks") {
peakList_with_ENCODE = peakList_promoterOL
# peakList_with_ENCODE = peakList_promoterNo_OL
}
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# count peak overlaps
STARRseq_overlapping_peaks = c()
STARRseq_overlap_prop = c()
STARRseq_missed_peaks = c()
STARRseq_filt_overlapping_peaks = c()
STARRseq_filt_overlap_prop = c()
STARRseq_filt_missed_peaks = c()


for(i in 1:length(peakList_with_ENCODE)){
  STARRseq_overlapping_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq, peakList_with_ENCODE[[i]])
  STARRseq_missed_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq, peakList_with_ENCODE[[i]], invert = TRUE)
  STARRseq_overlap_prop = c(STARRseq_overlap_prop, length(STARRseq_overlapping_peaks[[i]])/length(STARRseq))
  
  STARRseq_filt_overlapping_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq_filt, peakList_with_ENCODE[[i]])
  STARRseq_filt_missed_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq_filt, peakList_with_ENCODE[[i]], invert = TRUE)
  STARRseq_filt_overlap_prop = c(STARRseq_filt_overlap_prop, length(STARRseq_filt_overlapping_peaks[[i]])/length(STARRseq_filt))
}


names(STARRseq_overlapping_peaks) = sampleList_all_with_ENCODE
names(STARRseq_overlap_prop) = sampleList_all_with_ENCODE
names(STARRseq_missed_peaks) = sampleList_all_with_ENCODE

names(STARRseq_filt_overlapping_peaks) = sampleList_all_with_ENCODE
names(STARRseq_filt_overlap_prop) = sampleList_all_with_ENCODE
names(STARRseq_filt_missed_peaks) = sampleList_all_with_ENCODE

STARRseq_peak_overlaps_df = data.frame("Sample" = sampleList_all_with_ENCODE,
                                       "% captured STARR-seq peaks (all)" = (STARRseq_overlap_prop * 100),
                                       "% captured STARR-seq peaks (filt)" = (STARRseq_filt_overlap_prop * 100),
                                       "Total sample peaks" = lapply(peakList_with_ENCODE, length) %>% unlist %>% unname,
                                       check.names = FALSE, row.names = NULL)
```

### Significance {.tabset}

Check -log10(qval) values of captured and missed STARR-seq peaks and test significance with Welch Two Sample t-test

#### All
```{r, fig.height=11, fig.width=10, warning=FALSE}
STARRseq_qvals_df = c()

for(i in 1:length(peakList_with_ENCODE)){
  df_captured = data.frame("Sample" = sampleList_all_with_ENCODE[i], "-log10(qval)" = STARRseq_overlapping_peaks[[i]]$V12, "Captured" = "Captured", check.names = FALSE)
  df_missed = data.frame("Sample" = sampleList_all_with_ENCODE[i], "-log10(qval)" = STARRseq_missed_peaks[[i]]$V12, "Captured" = "Missed", check.names = FALSE)
  STARRseq_qvals_df = rbind(STARRseq_qvals_df, rbind(df_captured, df_missed))
}

STARRseq_qvals_df_melt = melt(STARRseq_qvals_df, id.vars = c("Sample", "Captured"))

ggplot(STARRseq_qvals_df_melt, aes(x = value, y = Sample, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 15))
```

#### All (t-test)
```{r, fig.height=10, fig.width=10, warning=FALSE}
tests = c()

for(i in 1:length(sampleList_all_with_ENCODE)){
  captured = STARRseq_qvals_df[(STARRseq_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_qvals_df$Captured == "Captured"),]
  missed = STARRseq_qvals_df[(STARRseq_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var, paired = FALSE, alternative = c("two.sided"))
  tests[[i]] = test
}

names(tests) = sampleList_all_with_ENCODE


# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

#### Filtered
```{r, fig.height=11, fig.width=10, warning=FALSE}

STARRseq_filt_qvals_df = c()
STARRseq_filt_overlapping_peaks_cut = STARRseq_filt_overlapping_peaks[names(STARRseq_filt_overlapping_peaks) != "ENCODE DNase"]
STARRseq_filt_missed_peaks_cut = STARRseq_filt_missed_peaks[names(STARRseq_filt_missed_peaks) != "ENCODE DNase"]

for(i in 1:length(STARRseq_filt_overlapping_peaks_cut)){
  df_captured = data.frame("Sample" = names(STARRseq_filt_overlapping_peaks_cut)[i], "-log10(qval)" = STARRseq_filt_overlapping_peaks_cut[[i]]$V12, "Captured" = "Captured", check.names = FALSE)
  df_missed = data.frame("Sample" = names(STARRseq_filt_missed_peaks_cut)[i], "-log10(qval)" = STARRseq_filt_missed_peaks_cut[[i]]$V12, "Captured" = "Missed", check.names = FALSE)
  STARRseq_filt_qvals_df = rbind(STARRseq_filt_qvals_df, rbind(df_captured, df_missed))
}

STARRseq_filt_qvals_df_melt = melt(STARRseq_filt_qvals_df, id.vars = c("Sample", "Captured"))

ggplot(STARRseq_filt_qvals_df_melt, aes(x = value, y = Sample, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  scale_y_discrete(limits = rev(levels(STARRseq_filt_qvals_df_melt$Sample))) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 15))
```

#### Filtered (t-test)
```{r, fig.height=10, fig.width=10, warning=FALSE}
tests = c()

for(i in 1:length(sampleList_all_with_ENCODE)){
  captured = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_filt_qvals_df$Captured == "Captured"),]
  missed = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_filt_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var, paired = FALSE, alternative = c("two.sided"))
  tests[[i]] = test
}

names(tests) = sampleList_all_with_ENCODE

# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

### Filtered STARR-seq peak significance, without duplicates
Visualising the significance of STARR-seq peaks filtered for DNase peak overlaps in peaks captured / missed by CUT&Tag.

```{r, fig.height=10, fig.width=9, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",STARRseq_filt_qvals_df_melt$Sample,value = TRUE)
plotdata <- STARRseq_filt_qvals_df_melt[!(STARRseq_filt_qvals_df_melt$Sample %in% dupSample),]

# add caller info
plotdata$caller = str_extract(plotdata$Sample, "MACS2|SEACR|ENCODE")

# Add more informative sample label with antibody names
plotdata$sampleID <- str_remove(plotdata$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
plotdata <- merge(plotdata, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample", all.x=TRUE)
plotdata$SampleLabel[is.na(plotdata$SampleLabel)] <- plotdata$sampleID[is.na(plotdata$SampleLabel)] 
plotdata$SampleLabel <- paste0(plotdata$SampleLabel , " (", plotdata$caller, ")" )

# add histone mark facet
plotdata$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", plotdata$SampleLabel,value = TRUE)
plotdata$'Modification'[plotdata$SampleLabel %in% meSample]  <- "H3K27me3"

# rename
plotdata$label <- str_replace(plotdata$SampleLabel, "^H3K27ac-|H3K27me3-", "")
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27ac (ENCODE)"] <- "ENCODE H3K27ac"
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27me3 (ENCODE)"] <- "ENCODE H3K27me3"

plotdata = plotdata[order(plotdata[,2], plotdata[,6]),]
plotdata$label <- factor(plotdata$label, levels = unique(plotdata$label))

ggplot(plotdata, aes(x = value, y = label, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  # scale_y_discrete(limits = rev(levels(plotdata$SampleLabel))) +
  scale_fill_manual(name=NULL, values=c("#e1b1a2","#ed6851")) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 18)) +
  facet_grid(rows='Modification',  scales = "free_y", space="free")

# ggsave(path = paste0(workdir,"/functional"),
#        filename = paste0("starrseq_overlap_allpeaks_DNasefilt_significance.svg"),
#         dpi = 1200, width = 6.0,
#         height = 8.0, units ="in")
```

#### Welch Two Sample t-test
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
tests = c()

for(i in 1:length(STARRseq_filt_overlapping_peaks_cut)){
  captured = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == names(STARRseq_filt_overlapping_peaks_cut)[i] & STARRseq_filt_qvals_df$Captured == "Captured"),]
  missed = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == names(STARRseq_filt_overlapping_peaks_cut)[i] & STARRseq_filt_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var)
  tests[[i]] = test
}

names(tests) = names(STARRseq_filt_overlapping_peaks_cut)

# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

### Corrected % of STARR-seq peaks captured

```{r, fig.height=10, fig.width=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Randomly sample 6000 peaks from each sample and compare overlaps:
peakList_sub = c()
# N=6000  # used for full peak sets
N=3000   # used for promoter-overlapping peak sets

for(i in 1:length(peakList_with_ENCODE)){
  peakList_sub[[i]] = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), N), ]
}

names(peakList_sub) = names(peakList_with_ENCODE)
sub_STARRseq_peak_overlaps_df = EpiCompare::overlap_percent(list(STARRseq), peakList_sub)
sub_STARRseq_peak_overlaps_df$"Percentage (filt)" = (EpiCompare::overlap_percent(list(STARRseq_filt), peakList_sub))$Percentage %>% round(3)
val = lapply(peakList_sub, function(x){sum(GenomicRanges::width(x))/10^6}) %>% unlist() %>% round(2) %>% data.frame() 
colnames(val) = "Mb"
val$peaklistName = rownames(val)
sub_STARRseq_peak_overlaps_df <- merge(sub_STARRseq_peak_overlaps_df, val, by.x="peaklist2", by.y="peaklistName", all.x=TRUE)

# Keep genome coverage the same:
test_coverage = function(peaks){sum(GenomicRanges::width(peaks)/10^6) %>% unlist() %>% round(0)}
peakList_sub_cov = c()
range_start = 500
# minimum coverage is 8Mb if also using ENCODE DNase peaks in comparison, otherwise can set higher limit
# Mb = 8      # used for full peak set + DNase overlap
Mb = 4        # used for promoter peak set + DNase overlap

for(i in 1:length(peakList_with_ENCODE)){
  #print(paste("Peak", i))
  
  # if included, use all DNase peaks
  if(names(peakList_with_ENCODE)[i] == "ENCODE DNase"){
    range = length(peakList_with_ENCODE$`ENCODE DNase`)
  } else {
    range_start = ((Mb - 2)/test_coverage(peakList_with_ENCODE[[i]]) * length(peakList_with_ENCODE[[i]])) %>% round(0)
    range = range_start:length(peakList_with_ENCODE[[i]])
  }
  
  # test lower bound of range
  test_peaks = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), range[1]), ]
  test_cov = test_peaks %>% test_coverage()

  if(test_cov == Mb){
    peakList_sub_cov[[i]] = test_peaks
  }
  
  if(test_cov < Mb){
    for(x in range){
      sub_peaks = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), x), ]
      coverage = test_coverage(sub_peaks)
      if(coverage == Mb){
        peakList_sub_cov[[i]] = sub_peaks
        break
      } 
    }
  }
  
  if(test_cov > Mb){ 
    print(paste("Adjusting range for peak", i))  
    range_start = range_start - 500
    range = range_start:length(peakList_with_ENCODE[[i]])
    }
  }

names(peakList_sub_cov) = names(peakList_with_ENCODE)
sub_cov_STARRseq_peak_overlaps_df = EpiCompare::overlap_percent(list(STARRseq), peakList_sub_cov)
sub_cov_STARRseq_peak_overlaps_df$"Percentage (filt)" = (EpiCompare::overlap_percent(list(STARRseq_filt), peakList_sub_cov))$Percentage %>% round(3)
val = lapply(peakList_sub_cov, function(x){sum(GenomicRanges::width(x))/10^6}) %>% unlist() %>% round(2) %>% data.frame() 
colnames(val) = "Mb"
val$peaklistName = rownames(val)
sub_cov_STARRseq_peak_overlaps_df <- merge(sub_cov_STARRseq_peak_overlaps_df, val, by.x="peaklist2", by.y="peaklistName", all.x=TRUE)


STARRseq_peak_overlaps_df_cut = STARRseq_peak_overlaps_df[STARRseq_peak_overlaps_df$Sample %in% sub_STARRseq_peak_overlaps_df$peaklist2, ]

sub_STARRseq_peak_overlaps_df = sub_STARRseq_peak_overlaps_df[match(STARRseq_peak_overlaps_df_cut$Sample, sub_STARRseq_peak_overlaps_df$peaklist2),]
sub_cov_STARRseq_peak_overlaps_df = sub_cov_STARRseq_peak_overlaps_df[match(STARRseq_peak_overlaps_df_cut$Sample, sub_cov_STARRseq_peak_overlaps_df$peaklist2),]


STARRseq_capture_summary = data.frame("Sample" = STARRseq_peak_overlaps_df_cut$Sample, "Uncorrected" = STARRseq_peak_overlaps_df_cut$`% captured STARR-seq peaks (all)`, "Corrected" = sub_cov_STARRseq_peak_overlaps_df$Percentage, check.names = FALSE)

STARRseq_capture_summary_filt = data.frame("Sample" = STARRseq_peak_overlaps_df_cut$Sample, "Uncorrected" = STARRseq_peak_overlaps_df_cut$`% captured STARR-seq peaks (filt)`, "Corrected" = sub_cov_STARRseq_peak_overlaps_df$`Percentage (filt)`, check.names = FALSE)

STARRseq_capture_summary_melt = melt(STARRseq_capture_summary)
STARRseq_capture_summary_melt$Sample = factor(STARRseq_capture_summary_melt$Sample, levels = unique(STARRseq_capture_summary_melt$Sample))

STARRseq_capture_summary_filt_melt = melt(STARRseq_capture_summary_filt)
STARRseq_capture_summary_filt_melt$Sample = factor(STARRseq_capture_summary_filt_melt$Sample, levels = unique(STARRseq_capture_summary_filt_melt$Sample))

# facet the plot
plotdata = rbind(data.frame(STARRseq_capture_summary_melt, group="All STARR-seq"),
                 data.frame(STARRseq_capture_summary_filt_melt, group="STARR-DNase Overlap"))
plotdata$caller = str_extract(plotdata$Sample, "MACS2|SEACR|ENCODE")

# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",plotdata$Sample,value = TRUE)
plotdata <- plotdata[!(plotdata$Sample %in% dupSample),]

# Add more informative sample label with antibody names
plotdata$sampleID <- str_remove(plotdata$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
plotdata <- merge(plotdata, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample", all.x=TRUE)
plotdata$SampleLabel[is.na(plotdata$SampleLabel)] <- plotdata$sampleID[is.na(plotdata$SampleLabel)] 
plotdata$SampleLabel <- paste0(plotdata$SampleLabel , " (", plotdata$caller, ")" )

# add histone mark facet
plotdata$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", plotdata$SampleLabel,value = TRUE)
plotdata$'Modification'[plotdata$SampleLabel %in% meSample]  <- "H3K27me3"

# rename
plotdata$label <- str_replace(plotdata$SampleLabel, "^H3K27ac-|H3K27me3-", "")
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27ac (ENCODE)"] <- "ENCODE H3K27ac"
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27me3 (ENCODE)"] <- "ENCODE H3K27me3"

plotdata = plotdata[order(plotdata[,2], plotdata[,6]),]
plotdata$label <- factor(plotdata$label, levels = unique(plotdata$label))

ggplot(plotdata, aes(y = label, x = value, fill = caller)) +
  theme_bw() +
  geom_bar(stat = "identity", width = 0.75, 
           position = position_dodge(width = 0.75), 
           color = "black", size = 0.2, alpha=0.8) +
  scale_y_discrete(limits = rev(levels(plotdata$SampleLabel))) +
  scale_fill_manual(name=NULL, values=c("grey40","#6d1961","steelblue")) +
  ylab("") +
  xlim(0,60) +
  xlab("% of STARR-seq peaks captured") +
  theme(legend.position = "bottom", legend.title = element_blank()) +
  guides(fill = guide_legend(nrow = 1, reverse = FALSE)) +
  theme(text = element_text(size = 12)) +
  facet_grid(variable+Modification~group, scale="free", space="free_y")
```


## Promoter non-overlapping peaks
```{r, message=FALSE,echo=FALSE,warning=FALSE}
## Define the test peak list
subset = "promoterPeaks" # set: allPeaks / promoterPeaks

## all CT sample peaks 
peakList_with_ENCODE = c(peakList, ext_peakList, ENCODE_H3K27ac=ENCODE_H3K27ac, ENCODE_H3K27me3=ENCODE_H3K27me3)
sampleList_all_with_ENCODE = names(peakList_with_ENCODE)

## subset these to promoter overlapping and non-overlapping
if (subset == "promoterPeaks") {
  # perform promoter subsetting
  promoters = ChIPseeker::getPromoters(TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene)
  peakList_promoterOL = c()
  peakList_promoterNo_OL = c()

  for(i in 1:length(peakList_with_ENCODE)){
    peaks_in_promoters = IRanges::subsetByOverlaps(peakList_with_ENCODE[[i]], promoters)
    peaks_not_in_promoters = IRanges::subsetByOverlaps(peakList_with_ENCODE[[i]], promoters, invert=TRUE)
    peakList_promoterOL = c(peakList_promoterOL, list(peaks_in_promoters))
    peakList_promoterNo_OL = c(peakList_promoterNo_OL, list(peaks_not_in_promoters))
  }
  
  names(peakList_promoterOL) = sampleList_all_with_ENCODE
  names(peakList_promoterNo_OL) = sampleList_all_with_ENCODE
  
}

if (subset == "promoterPeaks") {
# peakList_with_ENCODE = peakList_promoterOL
peakList_with_ENCODE = peakList_promoterNo_OL
}
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# count peak overlaps
STARRseq_overlapping_peaks = c()
STARRseq_overlap_prop = c()
STARRseq_missed_peaks = c()
STARRseq_filt_overlapping_peaks = c()
STARRseq_filt_overlap_prop = c()
STARRseq_filt_missed_peaks = c()


for(i in 1:length(peakList_with_ENCODE)){
  STARRseq_overlapping_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq, peakList_with_ENCODE[[i]])
  STARRseq_missed_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq, peakList_with_ENCODE[[i]], invert = TRUE)
  STARRseq_overlap_prop = c(STARRseq_overlap_prop, length(STARRseq_overlapping_peaks[[i]])/length(STARRseq))
  
  STARRseq_filt_overlapping_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq_filt, peakList_with_ENCODE[[i]])
  STARRseq_filt_missed_peaks[[i]] = IRanges::subsetByOverlaps(STARRseq_filt, peakList_with_ENCODE[[i]], invert = TRUE)
  STARRseq_filt_overlap_prop = c(STARRseq_filt_overlap_prop, length(STARRseq_filt_overlapping_peaks[[i]])/length(STARRseq_filt))
}


names(STARRseq_overlapping_peaks) = sampleList_all_with_ENCODE
names(STARRseq_overlap_prop) = sampleList_all_with_ENCODE
names(STARRseq_missed_peaks) = sampleList_all_with_ENCODE

names(STARRseq_filt_overlapping_peaks) = sampleList_all_with_ENCODE
names(STARRseq_filt_overlap_prop) = sampleList_all_with_ENCODE
names(STARRseq_filt_missed_peaks) = sampleList_all_with_ENCODE

STARRseq_peak_overlaps_df = data.frame("Sample" = sampleList_all_with_ENCODE,
                                       "% captured STARR-seq peaks (all)" = (STARRseq_overlap_prop * 100),
                                       "% captured STARR-seq peaks (filt)" = (STARRseq_filt_overlap_prop * 100),
                                       "Total sample peaks" = lapply(peakList_with_ENCODE, length) %>% unlist %>% unname,
                                       check.names = FALSE, row.names = NULL)
```

### Significance {.tabset}

Check -log10(qval) values of captured and missed STARR-seq peaks and test significance with Welch Two Sample t-test

#### All
```{r, fig.height=11, fig.width=10, warning=FALSE}
STARRseq_qvals_df = c()

for(i in 1:length(peakList_with_ENCODE)){
  df_captured = data.frame("Sample" = sampleList_all_with_ENCODE[i], "-log10(qval)" = STARRseq_overlapping_peaks[[i]]$V12, "Captured" = "Captured", check.names = FALSE)
  df_missed = data.frame("Sample" = sampleList_all_with_ENCODE[i], "-log10(qval)" = STARRseq_missed_peaks[[i]]$V12, "Captured" = "Missed", check.names = FALSE)
  STARRseq_qvals_df = rbind(STARRseq_qvals_df, rbind(df_captured, df_missed))
}

STARRseq_qvals_df_melt = melt(STARRseq_qvals_df, id.vars = c("Sample", "Captured"))

ggplot(STARRseq_qvals_df_melt, aes(x = value, y = Sample, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 15))
```

#### All (t-test)
```{r, fig.height=10, fig.width=10, warning=FALSE}
tests = c()

for(i in 1:length(sampleList_all_with_ENCODE)){
  captured = STARRseq_qvals_df[(STARRseq_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_qvals_df$Captured == "Captured"),]
  missed = STARRseq_qvals_df[(STARRseq_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var, paired = FALSE, alternative = c("two.sided"))
  tests[[i]] = test
}

names(tests) = sampleList_all_with_ENCODE


# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

#### Filtered
```{r, fig.height=11, fig.width=10, warning=FALSE}

STARRseq_filt_qvals_df = c()
STARRseq_filt_overlapping_peaks_cut = STARRseq_filt_overlapping_peaks[names(STARRseq_filt_overlapping_peaks) != "ENCODE DNase"]
STARRseq_filt_missed_peaks_cut = STARRseq_filt_missed_peaks[names(STARRseq_filt_missed_peaks) != "ENCODE DNase"]

for(i in 1:length(STARRseq_filt_overlapping_peaks_cut)){
  df_captured = data.frame("Sample" = names(STARRseq_filt_overlapping_peaks_cut)[i], "-log10(qval)" = STARRseq_filt_overlapping_peaks_cut[[i]]$V12, "Captured" = "Captured", check.names = FALSE)
  df_missed = data.frame("Sample" = names(STARRseq_filt_missed_peaks_cut)[i], "-log10(qval)" = STARRseq_filt_missed_peaks_cut[[i]]$V12, "Captured" = "Missed", check.names = FALSE)
  STARRseq_filt_qvals_df = rbind(STARRseq_filt_qvals_df, rbind(df_captured, df_missed))
}

STARRseq_filt_qvals_df_melt = melt(STARRseq_filt_qvals_df, id.vars = c("Sample", "Captured"))

ggplot(STARRseq_filt_qvals_df_melt, aes(x = value, y = Sample, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  scale_y_discrete(limits = rev(levels(STARRseq_filt_qvals_df_melt$Sample))) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 15))
```

#### Filtered (t-test)
```{r, fig.height=10, fig.width=10, warning=FALSE}
tests = c()

for(i in 1:length(sampleList_all_with_ENCODE)){
  captured = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_filt_qvals_df$Captured == "Captured"),]
  missed = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == sampleList_all_with_ENCODE[i] & STARRseq_filt_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var, paired = FALSE, alternative = c("two.sided"))
  tests[[i]] = test
}

names(tests) = sampleList_all_with_ENCODE

# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

### Filtered STARR-seq peak significance, without duplicates
Visualising the significance of STARR-seq peaks filtered for DNase peak overlaps in peaks captured / missed by CUT&Tag.

```{r, fig.height=10, fig.width=9, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",STARRseq_filt_qvals_df_melt$Sample,value = TRUE)
plotdata <- STARRseq_filt_qvals_df_melt[!(STARRseq_filt_qvals_df_melt$Sample %in% dupSample),]

# add caller info
plotdata$caller = str_extract(plotdata$Sample, "MACS2|SEACR|ENCODE")

# Add more informative sample label with antibody names
plotdata$sampleID <- str_remove(plotdata$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
plotdata <- merge(plotdata, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample", all.x=TRUE)
plotdata$SampleLabel[is.na(plotdata$SampleLabel)] <- plotdata$sampleID[is.na(plotdata$SampleLabel)] 
plotdata$SampleLabel <- paste0(plotdata$SampleLabel , " (", plotdata$caller, ")" )

# add histone mark facet
plotdata$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", plotdata$SampleLabel,value = TRUE)
plotdata$'Modification'[plotdata$SampleLabel %in% meSample]  <- "H3K27me3"

# rename
plotdata$label <- str_replace(plotdata$SampleLabel, "^H3K27ac-|H3K27me3-", "")
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27ac (ENCODE)"] <- "ENCODE H3K27ac"
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27me3 (ENCODE)"] <- "ENCODE H3K27me3"

plotdata = plotdata[order(plotdata[,2], plotdata[,6]),]
plotdata$label <- factor(plotdata$label, levels = unique(plotdata$label))

ggplot(plotdata, aes(x = value, y = label, fill = Captured)) + 
  theme_bw() +
  stat_boxplot(geom = "errorbar", coef = 1.5) + 
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(xlim = c(1, 10)) +
  scale_x_continuous(breaks = seq(1, 10, by = 1)) +
  # scale_y_discrete(limits = rev(levels(plotdata$SampleLabel))) +
  scale_fill_manual(name=NULL, values=c("#e1b1a2","#ed6851")) +
  ylab("") +
  xlab("-log10(qval)") +
  labs(fill = "STARR-seq peaks") +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 18)) +
  facet_grid(rows='Modification',  scales = "free_y", space="free")

# ggsave(path = paste0(workdir,"/functional"),
#        filename = paste0("starrseq_overlap_allpeaks_DNasefilt_significance.svg"),
#         dpi = 1200, width = 6.0,
#         height = 8.0, units ="in")
```

#### Welch Two Sample t-test
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
tests = c()

for(i in 1:length(STARRseq_filt_overlapping_peaks_cut)){
  captured = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == names(STARRseq_filt_overlapping_peaks_cut)[i] & STARRseq_filt_qvals_df$Captured == "Captured"),]
  missed = STARRseq_filt_qvals_df[(STARRseq_filt_qvals_df$Sample == names(STARRseq_filt_overlapping_peaks_cut)[i] & STARRseq_filt_qvals_df$Captured == "Missed"),]
  var_test = var.test(captured$`-log10(qval)`, missed$`-log10(qval)`)
  var = ifelse(var_test$p.value < 0.05, FALSE, TRUE)
  test = t.test(captured$`-log10(qval)`, missed$`-log10(qval)`, var.equal = var)
  tests[[i]] = test
}

names(tests) = names(STARRseq_filt_overlapping_peaks_cut)

# Extract information using regular expressions
extract_results <- function(text) {
 p_value <- sub(".*p-value ([^ ]+).*", "\\1", text)[3]
  return(c(Significance = p_value))
}
# Apply the extraction function to all items in the list
extracted_data <- lapply(tests, extract_results)

# Combine results into a data frame
summary_df <- as.data.frame(do.call(rbind, extracted_data), stringsAsFactors = FALSE)
summary_df$Significance <- formatC(as.numeric(summary_df$Significance), format = "e", digits = 2)

# View the resulting data frame
print(summary_df)
```

### Corrected % of STARR-seq peaks captured

```{r, fig.height=10, fig.width=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Randomly sample 6000 peaks from each sample and compare overlaps:
peakList_sub = c()
# N=6000  # used for full peak sets
N=3000   # used for promoter-overlapping peak sets

for(i in 1:length(peakList_with_ENCODE)){
  peakList_sub[[i]] = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), N), ]
}

names(peakList_sub) = names(peakList_with_ENCODE)
sub_STARRseq_peak_overlaps_df = EpiCompare::overlap_percent(list(STARRseq), peakList_sub)
sub_STARRseq_peak_overlaps_df$"Percentage (filt)" = (EpiCompare::overlap_percent(list(STARRseq_filt), peakList_sub))$Percentage %>% round(3)
val = lapply(peakList_sub, function(x){sum(GenomicRanges::width(x))/10^6}) %>% unlist() %>% round(2) %>% data.frame() 
colnames(val) = "Mb"
val$peaklistName = rownames(val)
sub_STARRseq_peak_overlaps_df <- merge(sub_STARRseq_peak_overlaps_df, val, by.x="peaklist2", by.y="peaklistName", all.x=TRUE)

# Keep genome coverage the same:
test_coverage = function(peaks){sum(GenomicRanges::width(peaks)/10^6) %>% unlist() %>% round(0)}
peakList_sub_cov = c()
range_start = 500
# minimum coverage is 8Mb if also using ENCODE DNase peaks in comparison, otherwise can set higher limit
# Mb = 8      # used for full peak set + DNase overlap
Mb = 4        # used for promoter peak set + DNase overlap

for(i in 1:length(peakList_with_ENCODE)){
  #print(paste("Peak", i))
  
  # if included, use all DNase peaks
  if(names(peakList_with_ENCODE)[i] == "ENCODE DNase"){
    range = length(peakList_with_ENCODE$`ENCODE DNase`)
  } else {
    range_start = ((Mb - 2)/test_coverage(peakList_with_ENCODE[[i]]) * length(peakList_with_ENCODE[[i]])) %>% round(0)
    range = range_start:length(peakList_with_ENCODE[[i]])
  }
  
  # test lower bound of range
  test_peaks = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), range[1]), ]
  test_cov = test_peaks %>% test_coverage()

  if(test_cov == Mb){
    peakList_sub_cov[[i]] = test_peaks
  }
  
  if(test_cov < Mb){
    for(x in range){
      sub_peaks = peakList_with_ENCODE[[i]][sample(length(peakList_with_ENCODE[[i]]), x), ]
      coverage = test_coverage(sub_peaks)
      if(coverage == Mb){
        peakList_sub_cov[[i]] = sub_peaks
        break
      } 
    }
  }
  
  if(test_cov > Mb){ 
    print(paste("Adjusting range for peak", i))  
    range_start = range_start - 500
    range = range_start:length(peakList_with_ENCODE[[i]])
    }
  }

names(peakList_sub_cov) = names(peakList_with_ENCODE)
sub_cov_STARRseq_peak_overlaps_df = EpiCompare::overlap_percent(list(STARRseq), peakList_sub_cov)
sub_cov_STARRseq_peak_overlaps_df$"Percentage (filt)" = (EpiCompare::overlap_percent(list(STARRseq_filt), peakList_sub_cov))$Percentage %>% round(3)
val = lapply(peakList_sub_cov, function(x){sum(GenomicRanges::width(x))/10^6}) %>% unlist() %>% round(2) %>% data.frame() 
colnames(val) = "Mb"
val$peaklistName = rownames(val)
sub_cov_STARRseq_peak_overlaps_df <- merge(sub_cov_STARRseq_peak_overlaps_df, val, by.x="peaklist2", by.y="peaklistName", all.x=TRUE)


STARRseq_peak_overlaps_df_cut = STARRseq_peak_overlaps_df[STARRseq_peak_overlaps_df$Sample %in% sub_STARRseq_peak_overlaps_df$peaklist2, ]

sub_STARRseq_peak_overlaps_df = sub_STARRseq_peak_overlaps_df[match(STARRseq_peak_overlaps_df_cut$Sample, sub_STARRseq_peak_overlaps_df$peaklist2),]
sub_cov_STARRseq_peak_overlaps_df = sub_cov_STARRseq_peak_overlaps_df[match(STARRseq_peak_overlaps_df_cut$Sample, sub_cov_STARRseq_peak_overlaps_df$peaklist2),]


STARRseq_capture_summary = data.frame("Sample" = STARRseq_peak_overlaps_df_cut$Sample, "Uncorrected" = STARRseq_peak_overlaps_df_cut$`% captured STARR-seq peaks (all)`, "Corrected" = sub_cov_STARRseq_peak_overlaps_df$Percentage, check.names = FALSE)

STARRseq_capture_summary_filt = data.frame("Sample" = STARRseq_peak_overlaps_df_cut$Sample, "Uncorrected" = STARRseq_peak_overlaps_df_cut$`% captured STARR-seq peaks (filt)`, "Corrected" = sub_cov_STARRseq_peak_overlaps_df$`Percentage (filt)`, check.names = FALSE)


STARRseq_capture_summary_melt = melt(STARRseq_capture_summary)
STARRseq_capture_summary_melt$Sample = factor(STARRseq_capture_summary_melt$Sample, levels = unique(STARRseq_capture_summary_melt$Sample))

STARRseq_capture_summary_filt_melt = melt(STARRseq_capture_summary_filt)
STARRseq_capture_summary_filt_melt$Sample = factor(STARRseq_capture_summary_filt_melt$Sample, levels = unique(STARRseq_capture_summary_filt_melt$Sample))

# facet the plot
plotdata = rbind(data.frame(STARRseq_capture_summary_melt, group="All STARR-seq"),
                 data.frame(STARRseq_capture_summary_filt_melt, group="STARR-DNase Overlap"))
plotdata$caller = str_extract(plotdata$Sample, "MACS2|SEACR|ENCODE")

# filter out peaks called with duplicates. There are no differences between duplicate inclusion and exclusion.
dupSample = grep("withDup",plotdata$Sample,value = TRUE)
plotdata <- plotdata[!(plotdata$Sample %in% dupSample),]
# plotdata$Sample <- factor(plotdata$Sample, levels=as.character(unique(plotdata$Sample)))

# Add more informative sample label with antibody names
plotdata$sampleID <- str_remove(plotdata$Sample, "MACS2|SEACR") %>% 
    str_remove("rmDup|withDup") %>%
    str_remove("__$")
plotdata <- merge(plotdata, alignDupSummary[c("Sample","SampleLabel")], by.x="sampleID", by.y="Sample", all.x=TRUE)
plotdata$SampleLabel[is.na(plotdata$SampleLabel)] <- plotdata$sampleID[is.na(plotdata$SampleLabel)] 
plotdata$SampleLabel <- paste0(plotdata$SampleLabel , " (", plotdata$caller, ")" )

# add histone mark facet
plotdata$'Modification' <- "H3K27ac"
meSample = grep("H3K27me3", plotdata$SampleLabel,value = TRUE)
plotdata$'Modification'[plotdata$SampleLabel %in% meSample]  <- "H3K27me3"

# rename
plotdata$label <- str_replace(plotdata$SampleLabel, "^H3K27ac-|H3K27me3-", "")
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27ac (ENCODE)"] <- "ENCODE H3K27ac"
plotdata$label[plotdata$SampleLabel == "ENCODE_H3K27me3 (ENCODE)"] <- "ENCODE H3K27me3"

plotdata = plotdata[order(plotdata[,2], plotdata[,6]),]
plotdata$label <- factor(plotdata$label, levels = unique(plotdata$label))

ggplot(plotdata, aes(y = label, x = value, fill = caller)) +
  theme_bw() +
  geom_bar(stat = "identity", width = 0.75, 
           position = position_dodge(width = 0.75), 
           color = "black", size = 0.2, alpha=0.8) +
  scale_y_discrete(limits = rev(levels(plotdata$SampleLabel))) +
  scale_fill_manual(name=NULL, values=c("grey40","#6d1961","steelblue")) +
  ylab("") +
  xlim(0,60) +
  xlab("% of STARR-seq peaks captured") +
  theme(legend.position = "bottom", legend.title = element_blank()) +
  guides(fill = guide_legend(nrow = 1, reverse = FALSE)) +
  theme(text = element_text(size = 12)) +
  facet_grid(variable+Modification~group, scale="free", space="free_y")
```


# TSA {.tabset}
Read in peaks, count number of peaks, calculate ENCODE precision and recall, and FRiP scores.

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.height=10}
# read in peak files
sampleList = c("Abcam-ab4729", "Abcam-ab177178", "Diagenode_50x", "Diagenode_100x")
h3k27ac_sampleList = sampleList

# hg19 blacklisted regions
hg19_blacklist = ChIPseeker::readPeakFile(paste0(workdir,"/resources/hg19/hg19-blacklist.v2.bed.gz"), as = "GRanges")

# peak list directory
peakpath="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis/TSA/peakCalling"

setList=c("TSA","sub") # opts: allsample, newsample, individual, 8M, TSA, sub
# callerdir=c("SEACR","MACS2")
callerdir=c("MACS2")
dupList="rmDup"
threshold_list = list(SEACR = c("0.01"), MACS2 = c("0.00001"))

par_blacklist_counts = c()
par_peakList = list()
par_peakList_unfilt = list()
par_callInfo = list()

for (set in setList) {
  for (dup in dupList) {
    for (sample in sampleList) {
      # for MACS2, define narrow or broad peak setting
      if (sample %in% h3k27me3_sampleList) { setting = "broad"
                                            epmark = "H3K27me3"} 
      if (sample %in% h3k27ac_sampleList) { setting = "narrow"
                                            epmark = "H3K27ac"} 
    
        for (caller in callerdir) {
          ## define which threshold list to use based on peak calling tool
          thresholdList = threshold_list[[caller]]
          
          for (threshold in thresholdList) {
          # for peak caller, define the peak file name suffix
          if (caller == "SEACR") { suffix=paste0("seacr_top",threshold,"_peaks.stringent.bed") }
          if (caller == "MACS2") { suffix=paste0("q",threshold,"_peaks.",setting,"Peak") }
          # check
            peakfile=paste0(peakpath,"/",caller,"/", sample,"_",set,"_", suffix)
            # print(peakfile)
          
          # read in peak regions
          peak_unfilt = ChIPseeker::readPeakFile(peakfile, as = "GRanges")
         
          # store all peaks in a list
          par_peakList_unfilt = c(par_peakList_unfilt, peak_unfilt)
          # count peaks in blacklist regions
          blacklist_count = length(IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist))
          # store peaks in blacklist regions
          par_blacklist_counts = c(par_blacklist_counts, blacklist_count)
          # filter out peaks in blacklist regions and irregular chromosomes
          peak_filt = IRanges::subsetByOverlaps(peak_unfilt, hg19_blacklist, invert = TRUE) %>% BRGenomics::tidyChromosomes(keep.X = TRUE, keep.Y = TRUE)
          # store filtered peak list
          par_peakList = c(par_peakList, peak_filt)
          # store peak calling information
          par_callInfo = c(par_callInfo, paste0(epmark,"_",sample,"_",caller,"_",set,"_",threshold))
          
          }
    }
      
  }
  }
}

# name peak lists
names(par_peakList) = par_callInfo
names(par_peakList_unfilt) = par_callInfo
names(par_blacklist_counts) = par_callInfo
```

## Peak counts
```{r}
# Count number of peaks per set
Total_CT_peaks = c()
for(i in 1:length(par_peakList)){ Total_CT_peaks = c(Total_CT_peaks, length(par_peakList[[i]])) }
names(Total_CT_peaks) <- par_callInfo

data.frame(Total_CT_peaks)
```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=12, fig.height=10}
# split peak set information and plot bar plot
par_df=data.frame(Total_CT_peaks)
par_df$PeakSet = rownames(par_df)
par_df$EpMark <- str_split_fixed(par_df$PeakSet, "_", n=4)[,1]
# par_df$Sample <- str_split_fixed(par_df$PeakSet, "_", n=5)[,2]
par_df$Sample <- str_extract(par_df$PeakSet, c("Abcam-ab4729|Abcam-ab177178|Diagenode_50x|Diagenode_100x"))
par_df$SampleLabel <- par_df$Sample 
par_df$Caller <- str_extract(par_df$PeakSet, "MACS2|SEACR")
# par_df$Dup <- str_split_fixed(par_df$PeakSet, "_", n=5)[,4]
par_df$Set <- str_extract(par_df$PeakSet, "TSA|sub")
par_df$Threshold <- 0.00001

options(scipen=999)
par_df$Threshold <- par_df$Threshold %>% as.numeric() %>% as.factor

ggplot(par_df, aes(x=Sample, y=Total_CT_peaks, fill=Set)) +
  geom_bar(aes(fill = Set), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.6, colour="black") +
  scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  theme_bw(base_size=30) + 
  ylab("Total peaks") +
  xlab("") +
  ggtitle("") +
  theme(axis.text.x = element_text(
    # angle = 45, 
    hjust = 0.5)) +
  theme(axis.text = element_text(size = 20)) +
  theme(axis.title = element_text(size = 25)) +
  theme(plot.title = element_text(size = 35, face="bold")) +
  theme(legend.text = element_text(size = 25)) +
  theme(legend.title = element_blank()) +
  theme(legend.position = "right") +
  theme(strip.background =element_rect(fill="grey60"))+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  ylim(0, max(par_df$Total_CT_peaks)+1000) 

# save plot
# ggsave(path = paste0(workdir,"/TSA"),
#         filename = paste0("peakcounts_MACS2.svg"),
#         dpi = 1200, width = 8.0,
#         height = 7.0, units ="in")
```

## Precision-Recall 
```{r}
# Get peak set names for ENCODE ChIP peak comparison for the appropriate epigenetic mark
## H3K27ac 
h3k27ac_setNames = par_df %>% dplyr::filter(EpMark == "H3K27ac") %>% pull(PeakSet) %>% unique() %>% sort
## H3K27me3 
h3k27me3_setNames = par_df %>% dplyr::filter(EpMark == "H3K27me3") %>% pull(PeakSet) %>% unique() %>% sort

# List of all called peak sets
peakTest <- c(par_peakList)
H3K27ac_peakList = peakTest[h3k27ac_setNames]
H3K27me3_peakList = peakTest[h3k27me3_setNames]


# find peak set overlaps
count_ct_overlaps = function(peak_list, reference){
  
  sample_peaks_in_ref = c()
  for(i in 1:length(peak_list)){
    ct_overlaps_count = GenomicRanges::countOverlaps(query = peak_list[[i]], subject = reference)
    sample_in_reference = ct_overlaps_count[ct_overlaps_count != 0] %>% length()
    sample_peaks_in_ref = c(sample_peaks_in_ref, sample_in_reference)
  }
  return(sample_peaks_in_ref)
}

# find encode overlaps
count_encode_overlaps = function(peak_list, reference){
  
  ref_in_sample_peaks = c()
  for(i in 1:length(peak_list)){
    enc_overlaps_count = GenomicRanges::countOverlaps(query = reference, subject = peak_list[[i]])
    reference_in_sample = enc_overlaps_count[enc_overlaps_count != 0] %>% length()
    ref_in_sample_peaks = c(ref_in_sample_peaks, reference_in_sample)
  }
  return(ref_in_sample_peaks)
}
# count CT peaks overlapping ENCODE peaks
ct_peaks_h3k27ac = count_ct_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# ct_peaks_h3k27me3 = count_ct_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously
# count ENCODE peaks overlapping ENCODE peaks
enc_peaks_h3k27ac = count_encode_overlaps(H3K27ac_peakList, ENCODE_H3K27ac) # ENCODE_H3K27ac loaded previously
# enc_peaks_h3k27me3 = count_encode_overlaps(H3K27me3_peakList, ENCODE_H3K27me3) # ENCODE_H3K27me3 loaded previously

# combine
encodeOL <- rbind( data.frame(PeakSet=names(H3K27ac_peakList), ol.CTPeakCount=ct_peaks_h3k27ac, 
                              ol.ENCODEPeakCount=enc_peaks_h3k27ac, Group="ENCODE H3K27ac")
                   # ,
                   # data.frame(PeakSet=names(H3K27me3_peakList), ol.CTPeakCount=ct_peaks_h3k27me3,
                   #            ol.ENCODEPeakCount=enc_peaks_h3k27me3,Group="ENCODE H3K27me3")
                   )

# add peak set information
encodeOL = merge(encodeOL, par_df, by="PeakSet")
# calculate proportion of overlapping CT peaks relative to total CT peaks
encodeOL$OL.prop.of.CT <- (encodeOL$ol.CTPeakCount)*100 / encodeOL$Total_CT_peaks
# count ENCODE peak proportion
encode_AC = NROW(ENCODE_H3K27ac)
encode_ME = NROW(ENCODE_H3K27me3)
# calculate proportion of union relative to all ENCODE peaks
encodeOL$OL.prop.of.ENCODE <- ifelse(encodeOL$Group == "ENCODE H3K27ac", (encodeOL$ol.ENCODEPeakCount)*100 / encode_AC,
                                  ifelse(encodeOL$Group == "ENCODE H3K27me3", (encodeOL$ol.ENCODEPeakCount)*100 / encode_ME, NA))
encodeOL
```

```{r, fig.width=9, fig.height=6, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
plotdata = encodeOL
colnames(plotdata)[12] <- "Precision (%)"
colnames(plotdata)[13] <- "Recall (%)"

plotdata = pivot_longer(plotdata, cols=c("Precision (%)","Recall (%)"))

ggplot(plotdata, aes(x=Sample, y=value, fill=Set)) +
  geom_bar(stat="identity", position=position_dodge2(width=0.9)) +
  theme_bw(base_size = 25) +
  scale_fill_viridis(name = "Peak Caller",
                       discrete = TRUE, begin = 0.65, end = 0.9,
                       option = "plasma", alpha = 0.85) +
  # ylim(0,100) + xlim(0,100) +
  ggtitle("") +
  ylab("") +
  xlab("") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(size = 22, face="bold")) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.position = "right") +
  theme(legend.key.height = unit(0.7, "cm")) +
  theme(legend.key.size = unit(1, "cm")) +
   guides(color = guide_legend(override.aes = list(size = 6))) + 
  facet_grid(~name, scales="free_y", space="free_y") 

# save plot
# ggsave(path = paste0(workdir,"/TSA"),
#         filename = paste0("precision_recall_MACS2.svg"),
#         dpi = 1200, width = 9.5,
#         height = 6.0, units ="in")
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# load ENCODE ChIP peaks
datadir="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUTnTag-benchmarking-analysis/resources/ENCODE/peaks/"
ENCODE_H3K27ac = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27ac_ENCFF044JNJ.bed.narrowPeak"), as = "GRanges")
ENCODE_H3K27me3 = ChIPseeker::readPeakFile(paste0(datadir, "/H3K27me3_ENCFF000BXB.bed.broadPeak"), as = "GRanges")
```

## FRiP scores
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# Calculate fragments within CT peaks and ENCODE ChIP-seq peaks 
# Loop over each sample
# -- Reading in bam files is quite resource intensive, so can take some time

# # peak file directory
# peakpath="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis/TSA/peakCalling"
# # bam file directory
# bampath="/Volumes/pu1918/projects/neurogenomics-lab/live/Projects/CUT_n_TAG/CUTnTag_analysis/TSA/alignment/bam"
# 
# 
# peakTest <- c(par_peakList)
# encodelist <- list(ENCODE_H3K27ac=ENCODE_H3K27ac)
# sampleList = c("Abcam-ab4729", "Abcam-ab177178", "Diagenode_50x", "Diagenode_100x")
# 
# # dupList = c("rmDup", "withDup")
# # callerList = c("MACS2", "SEACR")
# # encodelist = c("ENCODE_H3K27ac", "ENCODE_H3K27me3")
# dupList = c("rmDup")
# callerList = c("MACS2")
# encodelist = c("ENCODE_H3K27ac")
# setList=c("TSA","sub")
# 
# peaksetNames <- names(peakTest)
# inPeakData_df = c()
# 
# for (sample in sampleList) {
#   for (dup in dupList) {
#       for (set in setList) {
# 
#     # ## define bam file path
#     # # in house dataset
#     #  if (sample %in% insample) {
#     #    bamFile = paste0(workdir, "/alignment/bam/", sample, "_", dup, "_bowtie2.mapped.sorted.bam") }
#     # # external dataset, previously analysed
#     #  if (sample %in% exsample) {
#     #    if (dup == "rmDup") {
#     #      bamFile = paste0(storedir, "/bam/",dup,"/",sample,"_bowtie2_",dup,".mapped.sorted.bam") }
#     #    if (dup == "withDup") {
#     #      bamFile = paste0(storedir, "/bam/",dup,"/",sample,"_",dup,"_bowtie2.mapped.bam") }
#     #  }
#         bamFile = paste0(bampath, "/", sample, "_", set, ".sorted.rmDup.bam")
# 
#       for (caller in callerList) {
#         ## define peak set
#         peakset = paste0("H3K27ac_",sample,"_",caller,"_",set,"_0.00001")
#         ## announce peak set counted against
#         print(paste0("For peak set ", peakset))
#         peak.gr = peakTest[[peakset]]
#         # peak.gr = GenomicRanges::GRanges(seqnames = peaks$seqnames, IRanges(start = peaks$start, end = peaks$end), strand = "*")
#         fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#         inPeakN = counts(fragment_counts)[,1] %>% sum
#         inPeakData_df = rbind(inPeakData_df, data.frame(bamSample = paste0(sample,"_",set), PeakSet = peakset, inPeakN = inPeakN))
#       }
#   }
#   }
# }
# 
# inPeakData_df_save = inPeakData_df
#  
# ## ENCODE peak FRiP scores
# inPeakData_df_encode = c()
# for (sample in sampleList) {
#   for (dup in dupList) {
#       for (set in setList) {
#         
#          bamFile = paste0(bampath, "/", sample, "_", set, ".sorted.rmDup.bam")
# 
#         ## define peak set
#         peakset = encodelist[1]
#         ## announce peak set counted against
#         print(paste0("For peak set ", names(peakset)))
#         peak.gr = peakset[[1]]
#         fragment_counts = chromVAR::getCounts(bamFile, peak.gr, paired = TRUE, by_rg = FALSE, format = "bam")
#         inPeakN = counts(fragment_counts)[,1] %>% sum
#         inPeakData_df_encode = rbind(inPeakData_df_encode, data.frame(bamSample = paste0(sample,"_",set), PeakSet = names(peakset), inPeakN = inPeakN))
#       }
#     }
# }
# 
# # combine and save counts
# inPeakData_df$group <- "Sample Peaks"
# inPeakData_df_encode$group <- "H3K27ac ENCODE"
# outdf = rbind(inPeakData_df, inPeakData_df_encode) 
# # write.csv(outdf, paste0(workdir,"/TSA/inpeak_fragment_counts_tsa.csv"))

```

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
# Plot fragment in peak proportions
# inPeakData_df <- read.csv(paste0(workdir,"/alignment/frip/inpeak_fragment_counts.csv"), row.names = 1)
inPeakData_df <- read.csv(paste0(workdir,"/TSA/inpeak_fragment_counts_tsa.csv"), row.names = 1)

# rename
inPeakData_df$group[inPeakData_df$group == "sample"] <- "Sample Peaks"
inPeakData_df$group[inPeakData_df$group == "encode"] <- "H3K27ac ENCODE"

# read in count total fragments
readcount=read.table(paste0(workdir,"/TSA/fragment_counts.tsv"))
colnames(readcount) = c("bamSample","ReadCount")
readcount$FragCount = readcount$ReadCount/2

# add fragment count data
inPeakData_df <- merge(readcount, inPeakData_df, by="bamSample")
# select the appropriate comparison fragment count
# inPeakData_df$compareCount = ifelse(inPeakData_df$Dup == "rmDup", inPeakData_df$UniqueFragNum, inPeakData_df$MappedFragNum_hg19)
inPeakData_df$compareCount <- inPeakData_df$FragCount
# calculate frip score
inPeakData_df$frip = inPeakData_df$inPeakN / inPeakData_df$compareCount * 100

inPeakData_df$Set <- str_extract(inPeakData_df$bamSample, "TSA|sub")
inPeakData_df$SampleLabel <- substr(inPeakData_df$bamSample, 1, nchar(inPeakData_df$bamSample)-4)
inPeakData_df$group <- factor(inPeakData_df$group, c("Sample Peaks", "H3K27ac ENCODE"))
```

``` {r, fig.width=10, fig.height=8, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
ggplot(inPeakData_df, aes(SampleLabel, frip, fill=Set)) +
  geom_bar(aes(fill = Set), width = 0.7, position = position_dodge(width = 0.75), 
           stat = "identity", alpha = 0.6, colour="black") +
  theme_bw(base_size = 25) + 
  theme(plot.margin = unit(c(0.5, 0.5, 0.5, 1), "cm")) +
  ylim(0, 40) +
  ylab("% of fragments in peaks") +
  xlab("") +
  ggtitle("CUT&Tag fragments in ENCODE and sample peaks") +
  theme(axis.text = element_text(size = 18)) +
  theme(axis.title = element_text(size = 20)) +
  theme(plot.title = element_text(size = 25)) +
  theme(legend.text = element_text(size = 18)) +
  theme(legend.title = element_text(size = 18)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(legend.position = "bottom") +
  theme(
      strip.background=element_rect(colour="grey40",fill="grey80"),
      strip.text = element_text(colour = 'black')) +
  # scale_fill_manual(values = c("skyblue","steelblue")) +
    # scale_fill_manual(values = c("#ff8d99","#d82f3a")) +
    scale_fill_manual(name=NULL, values = c("violet","purple4")) +
  facet_wrap(~group, scales="free_x", ncol=4, nrow=1, strip.position = "top")

# # save plot
# ggsave(path = paste0(workdir,"/TSA"),
#         filename = paste0("frips_sample_encode.svg"),
#         dpi = 1200, width = 9.5,
#         height = 7.0, units ="in")
```

# Session info 

```{r}
sessionInfo()
```










